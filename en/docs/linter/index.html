<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design in Python: A Style Checker</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  <img src="../logo.svg" alt="site logo" class="logo" />
  <a href="../">Software Design in Python</a>
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../introduction/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../tester/">
      A Testing Framework
    </a>
  </li>
  
  <li>
    <a href="../interpreter/">
      An Interpreter
    </a>
  </li>
  
  <li>
    <a href="../backup/">
      Versioned File Backups
    </a>
  </li>
  
  <li>
    <a href="../cache/">
      A File Cache
    </a>
  </li>
  
  <li>
    <a href="../persistence/">
      Object Persistence
    </a>
  </li>
  
  <li>
    <a href="../binary/">
      Binary Storage
    </a>
  </li>
  
  <li>
    <a href="../builder/">
      A Build Manager
    </a>
  </li>
  
  <li>
    <a href="../templating/">
      A Static Site Generator
    </a>
  </li>
  
  <li>
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li>
    <a href="../server/">
      A Web Server
    </a>
  </li>
  
  <li>
    <a href="../matching/">
      Matching Patterns
    </a>
  </li>
  
  <li>
    <a href="../parser/">
      Parsing Text
    </a>
  </li>
  
  <li>
    <a href="../linter/">
      <strong>A Style Checker</strong>
    </a>
  </li>
  
  <li>
    <a href="../vm/">
      A Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      A Debugger
    </a>
  </li>
  
  <li>
    <a href="../packman/">
      A Package Manager
    </a>
  </li>
  
  <li>
    <a href="../dataframe/">
      A Dataframe
    </a>
  </li>
  
  <li>
    <a href="../database/">
      A Database
    </a>
  </li>
  
  <li class="todo">
    <a href="../pipeline/">
      A Pipeline Runner
    </a>
  </li>
  
  <li>
    <a href="../editor/">
      An Editor
    </a>
  </li>
  
  <li>
    <a href="../conclusion/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../bibliography/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contributing/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../credits/">
      Credits
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 14: A Style Checker</h1>


          
            
  

  

  

  

  

  

  

  

  

  

  

  

  
  <ul class="syllabus">
  
  <li markdown="1">An abstract syntax tree (AST) represents the elements of a program as a data structure.</li>
  
  <li markdown="1">A linter checks that a program conforms to a set of style and usage rules.</li>
  
  <li markdown="1">Linters typically use the Visitor design pattern to find nodes of interest in an AST.</li>
  
  <li markdown="1">Programs can modify a program's AST and then unparse it to create modified versions of the original program.</li>
  
  <li markdown="1">Dynamic code modification is very powerful, but the technique can produce insecure and unmaintainable code.</li>
  
  </ul>
  

  

  

  

  

  

  

  


            
<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#abstract_syntax_tree" markdown="1">abstract syntax tree</a>, <a class="gl-ref" href="../glossary/#bytecode" markdown="1">bytecode</a>, <a class="gl-ref" href="../glossary/#decorator" markdown="1">decorator</a>, <a class="gl-ref" href="../glossary/#false_negative" markdown="1">false negative</a>, <a class="gl-ref" href="../glossary/#linter" markdown="1">linter</a>, <a class="gl-ref" href="../glossary/#method_injection" markdown="1">method injection</a>, <a class="gl-ref" href="../glossary/#scope" markdown="1">scope</a>, <a class="gl-ref" href="../glossary/#topological_order" markdown="1">topological order</a>, <a class="gl-ref" href="../glossary/#unparsing" markdown="1">unparsing</a>, <a class="gl-ref" href="../glossary/#visitor_pattern" markdown="1">Visitor pattern</a>
</p>


            <div class="page-toc"></div>
            <p>This book relies on about 2500 lines of Python to turn Markdown into HTML,
fill in cross-references,
and so on.
To keep that code readable,
we use <a href="https://black.readthedocs.io/">black</a>, <a href="https://flake8.pycqa.org/">flake8</a>, and <a href="https://pycqa.github.io/isort/">isort</a>
to check that lines aren&rsquo;t too long,
that classes and functions have consistent names,
that modules are imported in a consistent order,
and dozens of other things.</p>
<p>Checking tools are often called <a class="gl-ref" href="../glossary/#linter" markdown="1">linters</a>
because an early tool like this for the C programming language was called <code>lint</code>.
Many projects insist that code pass checks like these
before being committed to version control.
To show how they work,
this chapter builds a trio of simple linting tools
that find duplicate keys in dictionaries,
look for unused variables,
and create a table showing which classes in a hierarchy define which methods.
As a bonus,
we then show how these tools can be used to extract documentation
and to create code as well as check it.</p>
<h2 id="linter-machinery">Section 14.1: Machinery</h2>
<p>Our starting point is Python&rsquo;s <a href="https://docs.python.org/3/library/ast.html">ast</a> module,
which parses Python code and produces an <a class="gl-ref" href="../glossary/#abstract_syntax_tree" markdown="1">abstract syntax tree</a>
that represents the structure of the code.
For example,
suppose we have this short program:</p>
<div class="code-sample lang-py" title="simple.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">double</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue"><a class="fig-ref" href="../linter/#linter-ast-simple">Figure 14.1</a> shows the main parts of this program&rsquo;s AST.
Each node represents one element of the program,
and each node&rsquo;s children are the element nested within it.</p>
<figure id="linter-ast-simple">
  <img src="./linter_ast_simple.svg" alt="Simple AST"/>
  <figcaption markdown="1">Figure 14.1: The abstract syntax tree for a simple Python program.</figcaption>
</figure>

<p>We say &ldquo;main parts of the AST&rdquo; because
the full structure includes placeholders for elements
that aren&rsquo;t present in this program.
To see the full thing,
we can use <code>ast.parse</code> to turn our short program into an AST
and <code>ast.dump</code> to display it:</p>
<div class="code-sample lang-py" title="dump_ast.py">
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</code></pre></div>
</div>
<div class="code-sample lang-sh" title="dump_ast_simple.sh">
<div class="highlight"><pre><span></span><code>python dump_ast.py simple.py
</code></pre></div>
</div>
<div class="code-sample lang-out" title="dump_ast_simple.out">
<div class="highlight"><pre><span></span><code>Module(
    body=[
        FunctionDef(
            name=&#39;double&#39;,
            args=arguments(
                posonlyargs=[],
                args=[
                    arg(arg=&#39;x&#39;)],
                kwonlyargs=[],
                kw_defaults=[],
                defaults=[]),
            body=[
                Return(
                    value=BinOp(
                        left=Constant(value=2),
                        op=Mult(),
                        right=Name(id=&#39;x&#39;, ctx=Load())))],
            decorator_list=[]),
        Assign(
            targets=[
                Name(id=&#39;result&#39;, ctx=Store())],
            value=Call(
                func=Name(id=&#39;double&#39;, ctx=Load()),
                args=[
                    Constant(value=3)],
                keywords=[])),
        Expr(
            value=Call(
                func=Name(id=&#39;print&#39;, ctx=Load()),
                args=[
                    Name(id=&#39;result&#39;, ctx=Load())],
                keywords=[]))],
    type_ignores=[])
</code></pre></div>
</div>
<p class="continue">Looking at the node representing the definition of the function <code>double</code>,
it has:</p>
<ul>
<li>a <code>name</code>;</li>
<li>an <code>arguments</code> node that stores information about the function&rsquo;s arguments;</li>
<li>a <code>body</code> that holds a list of the statements making up the function; and</li>
<li>a list of decorators applied to the function (which is empty).</li>
</ul>
<p>If we want a list of all the functions defined in this module,
we can walk through this tree to find all the <code>FunctionDef</code> nodes
and record their <code>name</code> properties.
Since each node&rsquo;s structure is a little different,
we would have to write one function for each type of node
that knew which fields of that node were worth exploring.</p>
<p>Luckily for us,
the <a href="https://docs.python.org/3/library/ast.html">ast</a> module comes with tools that can do this for us.
The class <code>ast.NodeVisitor</code> uses
the <span class="ix-entry" ix-key="Visitor pattern;design pattern!Visitor" markdown="1"><a class="gl-ref" href="../glossary/#visitor_pattern" markdown="1">Visitor</a></span> design pattern
to recurse through an AST.
Each time it reaches a new node of type <code>Thing</code>,
it looks for a method called <code>visit_Thing</code>;
for example,
when it reaches a <code>FunctionDef</code> node it looks for <code>visit_FunctionDef</code>.
If that method has been defined,
<code>NodeVisitor</code> calls it with the node as an argument.
The class <code>CollectNames</code> uses this machinery
to create a list of all the function and variable names
defined in a program:</p>
<div class="code-sample lang-py" title="walk_ast.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">CollectNames</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">visit_Assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_FunctionDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">col_offset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">({</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="p">},</span> <span class="p">{</span><span class="n">node</span><span class="o">.</span><span class="n">col_offset</span><span class="p">})</span>
</code></pre></div>
</div>
<p class="continue">A few things worth noting about this class are:</p>
<ol>
<li>
<p>The constructor of <code>CollectNames</code> invokes
    the constructor of <code>NodeVisitor</code>
    using <code>super().__init__()</code>
    before doing anything else.</p>
</li>
<li>
<p>The methods <code>visit_Assign</code> and <code>visit_FunctionDef</code>
    must call explicitly <code>self.generic_visit(node)</code> explicitly
    to recurse down through their children.
    By requiring this to be explicit,
    <code>NodeVisitor</code> gives programmers control on whether and when recursion takes place.</p>
</li>
<li>
<p>The method <code>position</code> relies on the fact that
    every node in the ATS keeps track of
    where in the source code it came from.</p>
</li>
</ol>
<p>To use this class,
we read in a source program that we want to analyze,
parse it,
and then call the <code>visit</code> method of our class to trigger recursion:</p>
<div class="code-sample lang-py" title="walk_ast.py">
<div class="highlight"><pre><span></span><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="n">collector</span> <span class="o">=</span> <span class="n">CollectNames</span><span class="p">()</span>
<span class="n">collector</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">collector</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Here&rsquo;s its output for our simple test program:</p>
<div class="code-sample lang-sh" title="walk_ast.sh">
<div class="highlight"><pre><span></span><code>python walk_ast.py simple.py
</code></pre></div>
</div>
<div class="code-sample lang-out" title="walk_ast.out">
<div class="highlight"><pre><span></span><code>{&#39;double&#39;: {(1, 0)}, &#39;result&#39;: {(4, 0)}}
</code></pre></div>
</div>
<p>With a little more work we could record class names as well,
and then check that (for example)
class names use CamelCase
while function and variable names use pothole_case.
We&rsquo;ll tackle this in the exercises.</p>
<h2 id="linter-find">Section 14.2: Finding Things</h2>
<p>Many programs store their configuration in dictionaries.
As those dictionaries grow larger,
it&rsquo;s easy for programmer to redefine values by accident.
Python doesn&rsquo;t consider this an error—for example,
both <code>no_duplicates</code> and <code>has_duplicates</code> are valid two-element dictionaries:</p>
<div class="code-sample lang-py" title="has_duplicate_keys.py">
<div class="highlight"><pre><span></span><code><span class="n">no_duplicates</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;first&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;second&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>

<span class="n">has_duplicates</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;third&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;fourth&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;fourth&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;third&quot;</span><span class="p">:</span> <span class="mi">6</span><span class="p">}</span>
</code></pre></div>
</div>
<div class="callout">
<h3>Overwriting, not Appending</h3>
<p>Programmers who are new to Python sometimes believe that
the &ldquo;extra&rdquo; values in the dictionary <code>has_duplicates</code>
should be put in a list,
so that (for example) the key <code>"third"</code> has the value <code>[3, 6]</code>.
This behavior would be perfectly reasonable,
but it isn&rsquo;t what Python does.</p>
</div>
<p>We can built a linter that finds dictionaries like <code>has_duplicates</code>
in just 17 lines of code.
We define a <code>visit_Dict</code> method for <code>NodeVisitor</code> to call;
in it,
we add each constant key to an instance of <code>Counter</code>
(a specialized <code>dict</code> that counts entries`)
and then look for keys that have been seen more than once:</p>
<div class="code-sample lang-py" title="find_duplicate_keys.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">FindDuplicateKeys</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">visit_Dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                <span class="n">seen</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">problems</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">problems</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">problems</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">problems</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">problems</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;duplicate key(s) </span><span class="se">{{</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="se">}}</span><span class="s2"> at line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">Its output for the file containing our two example dictionaries is:</p>
<div class="code-sample lang-out" title="has_duplicate_keys_ast.out">
<div class="highlight"><pre><span></span><code>Module(
    body=[
        Assign(
            targets=[
                Name(id=&#39;no_duplicates&#39;, ctx=Store())],
            value=Dict(
                keys=[
                    Constant(value=&#39;first&#39;),
                    Constant(value=&#39;second&#39;)],
                values=[
                    Constant(value=1),
                    Constant(value=2)])),
        Assign(
            targets=[
                Name(id=&#39;has_duplicates&#39;, ctx=Store())],
            value=Dict(
                keys=[
                    Constant(value=&#39;third&#39;),
                    Constant(value=&#39;fourth&#39;),
                    Constant(value=&#39;fourth&#39;),
                    Constant(value=&#39;third&#39;)],
                values=[
                    Constant(value=3),
                    Constant(value=4),
                    Constant(value=5),
                    Constant(value=6)]))],
    type_ignores=[])
</code></pre></div>
</div>
<div class="callout">
<h3>As Far as We Can Go</h3>
<p><code>FindDuplicateKeys</code> only considers constant keys,
so it won&rsquo;t find duplicate keys that are created on the fly:</p>
<div class="code-sample lang-py" title="function_keys.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">label</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;label&quot;</span>

<span class="n">actually_has_duplicate_keys</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s2">&quot;la&quot;</span> <span class="o">+</span> <span class="s2">&quot;bel&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">label</span><span class="p">():</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;l&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="s2">&quot;l&quot;</span><span class="p">]):</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p>We could try adding logic to handle this,
but one of the fundamental theorems of computer science is that
it&rsquo;s impossible to create a program that can predict the output of arbitrary other programs.
Our linter can therefore produce <a class="gl-ref" href="../glossary/#false_negative" markdown="1">false negatives</a>,
i.e.,
tell us there aren&rsquo;t problems when there actually are.</p>
</div>
<p>Finding unused variables—ones that are assigned values but never used—is
more challenging than our previous examples.
The problem is <a class="gl-ref" href="../glossary/#scope" markdown="1">scope</a>:
a variable defined in a function or method might have the same name
as one defined elsewhere,
but they are different variables.</p>
<p>Let&rsquo;s start by defining a class that handles modules and functions.
Since functions can be defined inside modules,
and inside other functions,
our class&rsquo;s constructor creates a list that we will use as a stack
to keep track of what scopes we&rsquo;re currently in:</p>
<div class="code-sample lang-py" title="find_unused_variables.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">FindUnusedVariables</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">visit_Module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_FunctionDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Each time we encounter a new scope
we push a triple onto the stack with a name,
a set to hold the variables that are used in the scope,
and another set to hold the variables that are defined in the scope.
We then call <code>NodeVisitor.generic_visitor</code> to trigger recursion,
pop the record we just pushed off the stack,
and report any problems:</p>
<div class="code-sample lang-py" title="find_unused_variables.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="n">unused</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">store</span> <span class="o">-</span> <span class="n">scope</span><span class="o">.</span><span class="n">load</span>
        <span class="k">if</span> <span class="n">unused</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">unused</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unused in </span><span class="si">{</span><span class="n">scope</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p>We could just use a list of three values to record information for each scope,
but it&rsquo;s a little cleaner to use <code>namedtuple</code>
from Python&rsquo;s standard library:</p>
<div class="code-sample lang-py" title="find_unused_variables.py">
<div class="highlight"><pre><span></span><code><span class="n">Scope</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Scope&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;load&quot;</span><span class="p">,</span> <span class="s2">&quot;store&quot;</span><span class="p">])</span>
</code></pre></div>
</div>
<p>The last part of the puzzle is <code>visit_Name</code>.
If the variable&rsquo;s value is being read,
the node will have a property <code>.ctx</code> (short for &ldquo;context&rdquo;) of type <code>Load</code>.
If the variable is being written to,
the node&rsquo;s <code>.ctx</code> property will be an instance of <code>Store</code>.
Checking this property allows us to put the name in the right set
in the scope that&rsquo;s at the top of the stack:</p>
<div class="code-sample lang-py" title="find_unused_variables.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">visit_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Load</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">load</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Store</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unknown context&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Once again,
we can run this by reading the source of a program,
converting it to an AST,
constructing an instance of <code>FindUnusedVariables</code>,
and running its <code>visit</code> method:</p>
<div class="code-sample lang-py" title="find_unused_variables.py">
<div class="highlight"><pre><span></span><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">FindUnusedVariables</span><span class="p">()</span>
<span class="n">finder</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</code></pre></div>
</div>
<p>To test our code,
let&rsquo;s create a program that has some unused variables:</p>
<div class="code-sample lang-py" title="has_unused_variables.py">
<div class="highlight"><pre><span></span><code><span class="n">used</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">distractor</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">not_used</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">distractor</span>


<span class="k">def</span> <span class="nf">no_unused</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">param</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">has_unused</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
    <span class="n">used</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">param</span>
    <span class="n">not_used</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">param</span>
    <span class="n">distractor</span> <span class="o">=</span> <span class="s2">&quot;distraction&quot;</span>
    <span class="k">return</span> <span class="n">used</span>
</code></pre></div>
</div>
<p>When we run our linter we get:</p>
<div class="code-sample lang-out" title="find_unused_variables.out">
<div class="highlight"><pre><span></span><code>unused in has_unused: distractor, not_used
unused in global: not_used
</code></pre></div>
</div>
<p>For our last example of finding things,
let&rsquo;s build a tool that tells us which methods are defined in which classes.
(We used a tool like this when writing this book
to keep track of examples that evolved step by step.)
Here&rsquo;s a test file that defines four classes,
each of which defines or redefines some methods:</p>
<div class="code-sample lang-py" title="inheritance_example.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Parent</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">red</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">green</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">LeftChild</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">green</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">blue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">RightChild</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">red</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">blue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">GrandChild</span><span class="p">(</span><span class="n">LeftChild</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">red</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">blue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">orange</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</code></pre></div>
</div>
<p>As before,
our class&rsquo;s constructor creates a stack to keep track of where we are.
It also creates a couple of dictionaries to keep track of
how classes inherit from each other
and the methods each class defines:</p>
<div class="code-sample lang-py" title="inheritance.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">FindClassesAndMethods</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">methods</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div>
</div>
<p>When we encounter a new class definition,
we push its name on the stack,
record its parents,
and create an empty set to hold its methods:</p>
<div class="code-sample lang-py" title="inheritance.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">visit_ClassDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
        <span class="k">assert</span> <span class="n">class_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">class_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">methods</span><span class="p">[</span><span class="n">class_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">class_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">bases</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</code></pre></div>
</div>
<p>When we encounter a function definition,
the first thing we do is check the stack.
If it&rsquo;s empty,
we&rsquo;re looking at a top-level function rather than a method,
so there&rsquo;s nothing for us to do.
(We actually should recurse through the function&rsquo;s children,
since it&rsquo;s possible to define classes inside functions,
but we&rsquo;ll leave as an exercise.)
If this function definition is inside a class,
on the other hand,
we add its name to our records:</p>
<div class="code-sample lang-py" title="inheritance.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">visit_FunctionDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">class_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">methods</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
        <span class="k">assert</span> <span class="n">method_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">methods</span><span class="p">[</span><span class="n">class_name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">methods</span><span class="p">[</span><span class="n">class_name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Once we&rsquo;re done searching the AST we print out a table
of the classes and methods we&rsquo;ve seen (<a class="tbl-ref" href="../linter/#linter-inheritance">Table 14.1</a>).
We could make this display easier to read—for example,
we could sort the classes from parent to child
and display methods in the order in which they were first defined—but
none of that requires us to inspect the AST.</p>
<div class="table"><table id="linter-inheritance"><caption>Table 14.1: Inheritance and methods</caption>
<thead>
<tr>
<th></th>
<th>GrandChild</th>
<th>LeftChild</th>
<th>Parent</th>
<th>RightChild</th>
</tr>
</thead>
<tbody>
<tr>
<td>blue</td>
<td>X</td>
<td>X</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td>green</td>
<td></td>
<td>X</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>orange</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>red</td>
<td>X</td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
</tbody>
</table>
</div>
<h2 id="linter-extension">Section 14.3: Extension</h2>
<p>It&rsquo;s easy to check a single style rule by extending <code>NodeVisitor</code>,
but what if we want to check dozens of rules?
Traversing the AST dozens of times would be inefficient.
And what if we want people to be able to add their own rules?
Inheritance is the wrong tool for this:
if several people each create their own <code>NodeVisitor</code> with a <code>visit_Name</code> method,
we&rsquo;d have to inherit from all those classes
and then have the new class&rsquo;s <code>visit_Name</code> call up to all of its parents&rsquo; equivalent methods.</p>
<p>One way around this is to <a class="gl-ref" href="../glossary/#method_injection" markdown="1">inject</a> methods into classes
after they have been defined.
The code fragment below creates a new class called <code>BlankNodeVisitor</code>
that doesn&rsquo;t add anything to <code>NodeVisitor</code>,
then uses <code>setattr</code> to add a method to it after it has been defined:</p>
<div class="code-sample lang-py" title="injection.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">BlankNodeVisitor</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">print_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>


<span class="nb">setattr</span><span class="p">(</span><span class="n">BlankNodeVisitor</span><span class="p">,</span> <span class="s2">&quot;visit_Name&quot;</span><span class="p">,</span> <span class="n">print_name</span><span class="p">)</span>
</code></pre></div>
</div>
<p>This trick works because classes and objects are just specialized dictionaries
(for some large value of &ldquo;just&rdquo;).
If we create an object of <code>BlankNodeVisitor</code> and call its <code>visit</code> method:</p>
<div class="code-sample lang-py" title="injection.py">
<div class="highlight"><pre><span></span><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">BlankNodeVisitor</span><span class="p">()</span>
<span class="n">finder</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</code></pre></div>
</div>
<p>then the inherited <code>generic_visit</code> method does what it always does.
When it encounters a <code>Name</code> node,
it looks in the object for something called <code>visit_Name</code>.
Since it doesn&rsquo;t find anything,
it looks in the object&rsquo;s class for something with that name,
finds our injected method,
and calls it.</p>
<p>With a bit more work we could have our injected method save and then call
whatever <code>visit_Name</code> method was there when it was added to the class,
but we would quickly run into a problem.
As we&rsquo;ve seen in earlier examples,
the methods that handle nodes are responsible for deciding
whether and when to recurse into those nodes&rsquo; children.
If we pile method on top of one another,
then either each one is going to trigger recursion
(so we recurse many times)
or there will have to be some way for each one to signal
whether it did that
so that other methods don&rsquo;t.</p>
<p>To avoid this complication,
most systems use a different approach.
Consider this class:</p>
<div class="code-sample lang-py" title="register.py">
<div class="highlight"><pre><span></span><code><span class="n">Handler</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Handler&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;func&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">RegisterNodeVisitor</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">add_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeType</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">handler</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nodeType</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="p">[</span><span class="n">nodeType</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="p">[</span><span class="n">nodeType</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="n">handler</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">handler</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</code></pre></div>
</div>
<p>The <code>add_handler</code> method takes three parameters:
the type of node a callback function is meant to handle,
the function itself,
and an optional extra piece of data to pass to the function
along with an AST node.
It saves the handler function and the data in a lookup table
indexed by the type of node the function is meant to handle.
Each of the methods inherited from <code>NodeVisitor</code>
then looks up handlers for its node type and runs them.</p>
<p>So what do handlers look like?
Each one is a function that takes a node and some data as input
and does whatever it&rsquo;s supposed to do:</p>
<div class="code-sample lang-py" title="register.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">count_names</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">counter</span><span class="p">):</span>
    <span class="n">counter</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>
</div>
<p>Setting up the visitor is a bit more complicated,
since we have to create and register the handler:</p>
<div class="code-sample lang-py" title="register.py">
<div class="highlight"><pre><span></span><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

<span class="n">finder</span> <span class="o">=</span> <span class="n">RegisterNodeVisitor</span><span class="p">()</span>
<span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="n">finder</span><span class="o">.</span><span class="n">add_handler</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">count_names</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>

<span class="n">finder</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">However,
we can now register as many handlers as we want
for each kind of node.</p>
<h2 id="linter-docs">Section 14.4: Generating Documentation</h2>
<p>Many programmers believe they&rsquo;re more likely to write documentation and keep it up to date
if it is close to the code.
Tools that extract specially-formatted comments from code and turn them into documentation
have been around since at least the 1980s;
both <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a href="https://www.mkdocs.org/">MkDocs</a> are popular ones for Python.</p>
<p>Generating documentation isn&rsquo;t the same as checking code style,
but they share some tooling.
Let&rsquo;s start by building a <code>NodeVisitor</code> that extracts and saves docstrings:</p>
<div class="code-sample lang-py" title="doc_extract.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Extract</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extraction class.&quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="n">filenames</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Entry-level method.&quot;&quot;&quot;</span>
        <span class="n">extracter</span> <span class="o">=</span> <span class="n">Extract</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                <span class="n">module_name</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="o">.</span><span class="n">stem</span>
                <span class="n">extracter</span><span class="o">.</span><span class="n">extract_from</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">extracter</span><span class="o">.</span><span class="n">seen</span>
</code></pre></div>
</div>
<p>The code to create a stack,
extract docstrings,
and save them in a dictionary should look familiar by now:</p>
<div class="code-sample lang-py" title="doc_extract.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seen</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">visit_ClassDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get docstring from class.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;class&quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">extract_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Start extraction for a module.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;module&quot;</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save information about a docstring.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">docstring</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">get_docstring</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seen</span><span class="p">[</span><span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">docstring</span><span class="p">)</span>
</code></pre></div>
</div>
<p>To format the docstrings,
we create a Markdown page with module, class, and function names as headers:</p>
<div class="code-sample lang-py" title="doc_format.py">
<div class="highlight"><pre><span></span><code><span class="n">HEADING</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;module&quot;</span><span class="p">:</span> <span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="s2">&quot;class&quot;</span><span class="p">:</span> <span class="s2">&quot;##&quot;</span><span class="p">,</span> <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="s2">&quot;##&quot;</span><span class="p">}</span>

<span class="n">MISSING</span> <span class="o">=</span> <span class="s2">&quot;**No documentation.**&quot;</span>


<span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="n">docstrings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert dictionary of docstrings to HTML page.&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">docstring</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">docstrings</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">make_heading</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">docstring</span> <span class="k">if</span> <span class="n">docstring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">MISSING</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">markdown</span><span class="o">.</span><span class="n">markdown</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">extensions</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;markdown.extensions.extra&quot;</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">format_key</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\_&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">make_heading</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">HEADING</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span><span class="si">}</span><span class="s2"> `</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">` </span><span class="se">{{</span><span class="s2">: #</span><span class="si">{</span><span class="n">format_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>
</code></pre></div>
</div>
<p>If our input file looks like this:</p>
<div class="code-sample lang-py" title="doc_sample.py">
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;Docstring for module.&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Docstring for function.&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">undocumented</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Sample</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Docstring for class.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Docstring for constructor.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Docstring for method.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span>
</code></pre></div>
</div>
<p class="continue">then our output is:</p>
<div class="code-sample lang-out" title="doc_sample.out">
<div class="highlight"><pre><span></span><code>&lt;h1 id=&quot;doc_sample&quot;&gt;&lt;code&gt;doc_sample&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;Docstring for module.&lt;/p&gt;
&lt;h2 id=&quot;doc_sample-Sample&quot;&gt;&lt;code&gt;doc_sample.Sample&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Docstring for class.&lt;/p&gt;
&lt;h2 id=&quot;doc_sample-Sample-__init__&quot;&gt;&lt;code&gt;doc_sample.Sample.__init__&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Docstring for constructor.&lt;/p&gt;
&lt;h2 id=&quot;doc_sample-Sample-rename&quot;&gt;&lt;code&gt;doc_sample.Sample.rename&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Docstring for method.&lt;/p&gt;
&lt;h2 id=&quot;doc_sample-function&quot;&gt;&lt;code&gt;doc_sample.function&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Docstring for function.&lt;/p&gt;
&lt;h2 id=&quot;doc_sample-undocumented&quot;&gt;&lt;code&gt;doc_sample.undocumented&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;No documentation.&lt;/strong&gt;&lt;/p&gt;
</code></pre></div>
</div>
<h2 id="codegen-modify">Section 14.5: Modifying Code</h2>
<p>An AST is a data structure like any other,
which means we can modify it as well as inspecting it.
Let&rsquo;s start with this short program:</p>
<div class="code-sample lang-py" title="double_and_print.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>

<span class="nb">print</span><span class="p">(</span><span class="n">double</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</code></pre></div>
</div>
<p>Its AST has two top-level nodes:
one for the function definition and one for the <code>print</code> statement.
We can duplicate the second of these and then <a class="gl-ref" href="../glossary/#unparsing" markdown="1">unparse</a> the AST
to produce a new program:</p>
<div class="code-sample lang-py" title="unparse.py">
<div class="highlight"><pre><span></span><code><span class="n">code</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>
<span class="n">print_stmt</span> <span class="o">=</span> <span class="n">code</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">code</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">print_stmt</span><span class="p">)</span>
<span class="n">modified</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="unparse_modified.out">
<div class="highlight"><pre><span></span><code>def double(x):
    return 2 * x
print(double(3))
print(double(3))
</code></pre></div>
</div>
<p>To run our machine-generated program,
we have to compile the AST to <a class="gl-ref" href="../glossary/#bytecode" markdown="1">bytecode</a>
and tell Python to evaluate the result:</p>
<div class="code-sample lang-py" title="unparse.py">
<div class="highlight"><pre><span></span><code><span class="n">bytecode</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;example&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;exec&quot;</span><span class="p">)</span>
<span class="n">exec</span><span class="p">(</span><span class="n">bytecode</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="unparse_exec.out">
<div class="highlight"><pre><span></span><code>6
6
</code></pre></div>
</div>
<p>Duplicating a <code>print</code> statement isn&rsquo;t particularly useful,
but other applications of this technique let us do some powerful things.
Let&rsquo;s have another look at how Python represents a function call.
Our example is:</p>
<div class="code-sample lang-py" title="call.py">
<div class="highlight"><pre><span></span><code><span class="n">count</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">We parse it like this:</p>
<div class="code-sample lang-py" title="inject.py">
<div class="highlight"><pre><span></span><code><span class="n">call_code</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">call</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">and get this AST:</p>
<div class="code-sample lang-out" title="inject_parse.out">
<div class="highlight"><pre><span></span><code>Module(
  body=[
    Expr(
      value=Call(
        func=Name(id=&#39;count&#39;, ctx=Load()),
        args=[
          Constant(value=&#39;name&#39;)],
        keywords=[]))],
  type_ignores=[])
</code></pre></div>
</div>
<p>But we don&rsquo;t have to parse text to create an AST:
it&rsquo;s just a bunch of objects,
so we can construct one by hand
that mirrors the structure shown above:</p>
<div class="code-sample lang-py" title="inject.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">make_count</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">Expr</span><span class="p">(</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">Call</span><span class="p">(</span>
            <span class="n">func</span><span class="o">=</span><span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ast</span><span class="o">.</span><span class="n">Load</span><span class="p">()),</span>
            <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">ast</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">name</span><span class="p">)],</span>
            <span class="n">keywords</span><span class="o">=</span><span class="p">[]</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="n">constructed</span> <span class="o">=</span> <span class="n">make_count</span><span class="p">(</span><span class="s2">&quot;test&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="inject_make.out">
<div class="highlight"><pre><span></span><code>Expr(
  value=Call(
    func=Name(id=&#39;count&#39;, ctx=Load()),
    args=[
      Constant(value=&#39;test&#39;)],
    keywords=[]))
</code></pre></div>
</div>
<p>Alternatively,
we can find existing function definitions
and modify them programmatically:</p>
<div class="code-sample lang-py" title="inject.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">modify</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="n">code</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ast</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">code</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">FunctionDef</span><span class="p">):</span>
            <span class="n">node</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="p">[</span><span class="n">make_count</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="o">*</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
</code></pre></div>
</div>
<p>To try this out,
here&rsquo;s a program that adds and doubles numbers:</p>
<div class="code-sample lang-py" title="add_double.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">double</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">The modified version is:</p>
<div class="code-sample lang-out" title="inject_modified.out">
<div class="highlight"><pre><span></span><code>def add(left, right):
    count(&#39;add&#39;)
    return left + right

def double(x):
    count(&#39;double&#39;)
    return add(x, x)
add(1, 2)
double(3)
</code></pre></div>
</div>
<p>So what exactly is <code>call</code>?
We want a &ldquo;function&rdquo; that keeps track of
how many times it has been passed different strings,
so we define a class with a <code>__call__</code> method
so that its instances can be used like functions:</p>
<div class="code-sample lang-py" title="inject.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">CountCalls</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>
</div>
<p>Finally,
when we&rsquo;re evaluating the bytecode generated from our modified AST,
we pass in a dictionary of variable names and values
that we want to have in scope.
The result is exactly what we would get if we had defined all of this in the usual way:</p>
<div class="code-sample lang-py" title="inject.py">
<div class="highlight"><pre><span></span><code><span class="n">call_counter</span> <span class="o">=</span> <span class="n">CountCalls</span><span class="p">()</span>
<span class="n">bytecode</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">modified</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;example&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;exec&quot;</span><span class="p">)</span>
<span class="n">exec</span><span class="p">(</span><span class="n">bytecode</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="n">call_counter</span><span class="p">})</span>
<span class="nb">print</span><span class="p">(</span><span class="n">call_counter</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="inject_exec.out">
<div class="highlight"><pre><span></span><code>Counter({&#39;add&#39;: 2, &#39;double&#39;: 1})
</code></pre></div>
</div>
<div class="callout">
<h3>There&rsquo;s Such a Thing as &ldquo;Too Clever&rdquo;</h3>
<p>Modifying code dynamically is the most powerful technique shown in this book.
It is also the least comprehensible:
as soon as the code you read and the code that&rsquo;s run can differ in arbitrary ways,
you have a maintenance headache and a security nightmare.
Limited forms of program modification,
such as Python&rsquo;s <a href="https://docs.python.org/3/reference/datamodel.html#metaclasses">metaclasses</a> or <a class="gl-ref" href="../glossary/#decorator" markdown="1">decorators</a>
give most of the power with only some of the headaches;
please use those rather than the magic shown above.</p>
</div>
<h2 id="linter-summary">Section 14.6: Summary</h2>
<figure id="linter-concept-map">
  <img src="./linter_concept_map.svg" alt="Concept map for code manipulation"/>
  <figcaption markdown="1">Figure 14.2: Concepts for code manipulation.</figcaption>
</figure>

<h2 id="linter-exercises">Section 14.7: Exercises</h2>
<h3 class="exercise">Finding unused parameters</h3>
<p>Modify the code that finds unused variables
to report unused function parameters as well.</p>
<h3 class="exercise">Finding redundant assignments</h3>
<p>Write a linter that looks for redundant assignments to variables,
i.e.,
assignments that are immediately overwritten:</p>
<div class="highlight"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># redundant</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
<p class="continue">(Redundant assignments are a common result of copying and pasting.)</p>
<h3 class="exercise">Checking names</h3>
<p>Write a linter that checks that
class names are written in CamelCase
but function and variable names are pothole_case.</p>
<h3 class="exercise">Missing documentation</h3>
<p>Write a linter that complains about modules, classes, methods, and functions
that don&rsquo;t have docstrings.</p>
<h3 class="exercise">Missing tests</h3>
<p>Write a linter that takes two files as input:
one that defines one or more functions
and another that defines one or more tests of those functions.
The linter looks through the tests to see what functions are being called,
then reports any functions from the first file that it hasn&rsquo;t seen.</p>
<h3 class="exercise">Nested functions</h3>
<p>Modify the inheritance table code
so that class names are shown in parent-to-child order
and methods are shown in the order in which they are first defined.
(You may find the discussion of
<span class="ix-entry" ix-key="topological order" markdown="1"><a class="gl-ref" href="../glossary/#topological_order" markdown="1">topological ordering</a></span>
in <a class="x-ref" href="../builder/">Chapter 8</a> useful.)</p>
<h3 class="exercise">Chaining methods</h3>
<ol>
<li>
<p>Modify the code that injects methods into <code>NodeVisitor</code>
    so that any previously-injected methods are also called.</p>
</li>
<li>
<p>Modify the methods again so that each one signals
    whether or not it has handled recursion
    (either directly or indirectly).</p>
</li>
</ol>
<h3 class="exercise">Decorating</h3>
<p>Create a <code>@count</code> decorator that causes a function to count
how many times it has been called.</p>
<h3 class="exercise">Name conversion</h3>
<p>Write a tool that find functions with pothole_case names
and replaces them with CamelCase names,
then saves the resulting program as a legal Python file.</p>
<h3 class="exercise">Sorting imports</h3>
<p><a href="https://pycqa.github.io/isort/">isort</a> checks that the imports in a file are sorted correctly:
modules from Python&rsquo;s standard library come first (in alphabetical order),
then installed modules (also in alphabetical order)
and finally local imports (ditto).
Write a linter that reports violations of these rules.
How did you distinguish between the three cases?</p>
          
        </main>
      </div>
    </div>
  </body>
</html>
