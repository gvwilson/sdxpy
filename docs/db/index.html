<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="repo" content="https://github.com/gvwilson/sdxpy">
  <meta name="build_date" content="2023-07-31">
  <meta name="template" content="default">
  <meta name="major" content="db">
  <meta name="has_slides" content="true">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design by Example: A Database</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <img src="../logo.svg" alt="site logo" class="logo" />
  <a href="../">Software Design by Example</a>
  
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../intro/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../oop/">
      Objects and Classes
    </a>
  </li>
  
  <li>
    <a href="../dup/">
      Finding Duplicate Files
    </a>
  </li>
  
  <li>
    <a href="../glob/">
      Matching Patterns
    </a>
  </li>
  
  <li>
    <a href="../parse/">
      Parsing Text
    </a>
  </li>
  
  <li>
    <a href="../test/">
      Running Tests
    </a>
  </li>
  
  <li>
    <a href="../interp/">
      An Interpreter
    </a>
  </li>
  
  <li>
    <a href="../func/">
      Functions and Closures
    </a>
  </li>
  
  <li>
    <a href="../reflect/">
      Reflection
    </a>
  </li>
  
  <li>
    <a href="../archive/">
      A File Archiver
    </a>
  </li>
  
  <li>
    <a href="../check/">
      An HTML Validator
    </a>
  </li>
  
  <li>
    <a href="../template/">
      A Template Expander
    </a>
  </li>
  
  <li>
    <a href="../lint/">
      A Code Linter
    </a>
  </li>
  
  <li>
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li>
    <a href="../perf/">
      Performance Profiling
    </a>
  </li>
  
  <li>
    <a href="../persist/">
      Object Persistence
    </a>
  </li>
  
  <li>
    <a href="../binary/">
      Binary Data
    </a>
  </li>
  
  <li>
    <a href="../db/">
      <strong>A Database</strong>
    </a>
  </li>
  
  <li>
    <a href="../build/">
      A Build Manager
    </a>
  </li>
  
  <li>
    <a href="../pack/">
      A Package Manager
    </a>
  </li>
  
  <li>
    <a href="../ftp/">
      Transferring Files
    </a>
  </li>
  
  <li>
    <a href="../http/">
      Serving Web Pages
    </a>
  </li>
  
  <li>
    <a href="../viewer/">
      A File Viewer
    </a>
  </li>
  
  <li>
    <a href="../undo/">
      Undo and Redo
    </a>
  </li>
  
  <li>
    <a href="../vm/">
      A Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      A Debugger
    </a>
  </li>
  
  <li>
    <a href="../finale/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../bib/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../bonus/">
      Bonus Material
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contrib/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../credits/">
      Credits
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 18: A Database</h1>


          
<div class="draft notex">
  <p class="draft">
    DRAFT 2023-07-31
  </p>
  <p>
    awaiting revision<br>
    Please use section heading links to submit feedback.
  </p>
</div>


	  
<div class="chapterinfo">

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
  <ul class="syllabus">
  
  <li markdown="1">Database stores records so that they can be accessed by key.</li>
  
  <li markdown="1">Log-structured database appends new records to database and invalidates older versions of records.</li>
  
  <li markdown="1">Classes are data structures that can be saved like any other data.</li>
  
  <li markdown="1">The filesystem saves data in fixed-size pages.</li>
  
  <li markdown="1">We can improve the efficiency of a database by saving records in blocks.</li>
  
  </ul>
  

  

  

  

  

  

  

  

  



<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#gl:block_memory" markdown="1">block (of memory)</a>, <a class="gl-ref" href="../glossary/#gl:compact" markdown="1">compact (data or files)</a>, <a class="gl-ref" href="../glossary/#gl:garbage_collection" markdown="1">garbage collection</a>, <a class="gl-ref" href="../glossary/#gl:key_value_store" markdown="1">key-value store</a>, <a class="gl-ref" href="../glossary/#gl:log_structured_db" markdown="1">log-structured database</a>, <a class="gl-ref" href="../glossary/#gl:null_byte" markdown="1">null byte</a>, <a class="gl-ref" href="../glossary/#gl:page" markdown="1">page</a>
</p>


</div>


          <div class="page-toc"></div>
          <p>Persisting objects (<a class="x-ref" href="../persist/">Chapter 16</a>) lets us save and restore program state,
but we often want to be able to look things up quickly
without reloading all of our data.
We would also like applications written in different languages
to be able to get at our data,
which might be easier if we choose a different storage format.</p>
<p>This chapter therefore builds a very simple
<a class="gl-ref" href="../glossary/#gl:log_structured_db" title="A database to which data can only be appended, i.e., existing records cannot be overwritten." markdown="1">log-structured database</a>.
The phrase &ldquo;log-structured&rdquo; means that records a log of operations,
i.e.,
every new <span class="ix-entry" ix-key="record" markdown="1">record</span> is appended to the end of the database.
Programmers have invented many other ways to store large amounts of data,
but this is one of the easiest to understand.</p>
<h2 id="db-start">Section 18.1: Starting Point</h2>
<p>Our starting point is
a simple <a class="gl-ref" href="../glossary/#gl:key_value_store" title="A simple form of database in which each record can only be accessed by a single key." markdown="1">key-value store</a>
that lets us save records and look them up later.
The user must provide a function that takes a record
and returns its key:</p>
<div class="code-sample lang-py" title="interface_original.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Database</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize with function to get key.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key_func</span> <span class="o">=</span> <span class="n">key_func</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store the given record.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return record associated with key or None.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;get&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p>If we just want to store things in memory,
we can derive a class that uses
a dictionary with the values returned by
the user&rsquo;s key function for lookup
(<a class="fig-ref" href="../db/#db-memory">Figure 18.1</a>):</p>
<div class="code-sample lang-py" title="just_dict_original.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">interface_original</span> <span class="kn">import</span> <span class="n">Database</span>

<span class="k">class</span> <span class="nc">JustDict</span><span class="p">(</span><span class="n">Database</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_func</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">key_func</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_func</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</code></pre></div>
</div>
<figure id="db-memory">
<img src="./memory.svg" alt="In-memory database"/>
<figcaption markdown="1">Figure 18.1: Storing a database as a single dictionary in memory.</figcaption>
</figure>

<p>This simple class is enough to let us start writing some tests.
Let&rsquo;s create a class to store experimental records:</p>
<div class="code-sample lang-py" title="record_original.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">BasicRec</span><span class="p">:</span>
    <span class="n">MAX_NAME_LEN</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">TIMESTAMP_LEN</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">MAX_READING</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">MAX_READING_LEN</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">MAX_READINGS_NUM</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">BasicRec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">record</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">readings</span><span class="p">):</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAX_NAME_LEN</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">readings</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAX_READINGS_NUM</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">((</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAX_READING</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">readings</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timestamp</span> <span class="o">=</span> <span class="n">timestamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_readings</span> <span class="o">=</span> <span class="n">readings</span>
</code></pre></div>
</div>
<p class="continue">and use the <code>pytest.fixture</code> <span class="ix-entry" ix-key="decorator" markdown="1">decorator</span> from <a class="x-ref" href="../reflect/">Chapter 9</a>
to create a database and two records:</p>
<div class="code-sample lang-py" title="test_db_original.py">
<div class="highlight"><pre><span></span><code><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">db</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">JustDict</span><span class="p">(</span><span class="n">BasicExperiment</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">ex01</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">BasicExperiment</span><span class="p">(</span><span class="s2">&quot;ex01&quot;</span><span class="p">,</span> <span class="mi">12345</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">ex02</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">BasicExperiment</span><span class="p">(</span><span class="s2">&quot;ex02&quot;</span><span class="p">,</span> <span class="mi">67890</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</code></pre></div>
</div>
<p class="continue">Our first few tests are then:</p>
<div class="code-sample lang-py" title="test_db_original.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_construct</span><span class="p">(</span><span class="n">db</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">db</span>

<span class="k">def</span> <span class="nf">test_get_nothing_from_empty_db</span><span class="p">(</span><span class="n">db</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">db</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;something&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">test_add_then_get</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">ex01</span><span class="p">):</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ex01</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">db</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ex01&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ex01</span>

<span class="k">def</span> <span class="nf">test_add_two_then_get_both</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">ex01</span><span class="p">,</span> <span class="n">ex02</span><span class="p">):</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ex01</span><span class="p">)</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ex02</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">db</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ex01&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ex01</span>
    <span class="k">assert</span> <span class="n">db</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ex02&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ex02</span>

<span class="k">def</span> <span class="nf">test_add_then_overwrite</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">ex01</span><span class="p">):</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ex01</span><span class="p">)</span>
    <span class="n">ex01</span><span class="o">.</span><span class="n">_timestamp</span> <span class="o">=</span> <span class="mi">67890</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ex01</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">db</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ex01&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ex01</span>
</code></pre></div>
</div>
<p>Our next step is to save the user&rsquo;s records in the database
without tying the database to a particular type of record.
The cleanest way to solve this problem is
to have the records convert themselves into something storable,
but if we do that,
we will be asking records to do two things
(the other being to generate a key).
Rather than passing a second function to the database&rsquo;s constructor
we will <span class="ix-entry" ix-key="refactor" markdown="1">refactor</span> the database to work with any record class:</p>
<div class="code-sample lang-py" title="interface.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Database</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize with data manipulation functions.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span> <span class="o">=</span> <span class="n">record_cls</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store the given record.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return record associated with key or None.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;get&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Once again we are making use of the fact that
code is just another kind of data.
Saving a class is no different from saving a function,
which in turn is no different from saving a string or a list.
The proof is that we can refactor
the dictionary-based implementation of our database
to use a <span class="ix-entry" ix-key="static method" markdown="1">static method</span> of the record class
when it needs a key:</p>
<div class="code-sample lang-py" title="just_dict_refactored.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">interface</span> <span class="kn">import</span> <span class="n">Database</span>

<span class="k">class</span> <span class="nc">JustDictRefactored</span><span class="p">(</span><span class="n">Database</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_cls</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">record_cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">and our tests (after a corresponding bit of refactoring)
work as before.</p>
<h2 id="db-save">Section 18.2: Saving Records</h2>
<p>The next step in building our database is to save records.
As mentioned above,
we don&rsquo;t want the database tied to any particular kind of record,
so we need our records to know how to pack and unpack themselves
(<a class="x-ref" href="../binary/">Chapter 17</a>).
We start by giving our experiment record class a static method
that calculates the size of a single record:</p>
<div class="code-sample lang-py" title="record.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Experiment</span><span class="p">(</span><span class="n">BasicRec</span><span class="p">):</span>
    <span class="n">RECORD_LEN</span> <span class="o">=</span> <span class="n">BasicRec</span><span class="o">.</span><span class="n">MAX_NAME_LEN</span> <span class="o">+</span> <span class="mi">1</span> \
        <span class="o">+</span> <span class="n">BasicRec</span><span class="o">.</span><span class="n">TIMESTAMP_LEN</span> <span class="o">+</span> <span class="mi">1</span> \
        <span class="o">+</span> <span class="p">(</span><span class="n">BasicRec</span><span class="o">.</span><span class="n">MAX_READING_LEN</span> <span class="o">*</span> <span class="n">BasicRec</span><span class="o">.</span><span class="n">MAX_READINGS_NUM</span><span class="p">)</span> \
        <span class="o">+</span> <span class="p">(</span><span class="n">BasicRec</span><span class="o">.</span><span class="n">MAX_READINGS_NUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">Experiment</span><span class="o">.</span><span class="n">RECORD_LEN</span>
</code></pre></div>
</div>
<div class="callout">
<h3>Tradeoffs</h3>
<p>We&rsquo;re assuming that every record is the same size.
If we want to save records with variable-length fields such as strings,
we can either set a maximum size and always save that much data
or make our implementation more complicated (and probably slower)
by saving each record&rsquo;s size
and then scanning records in the same way that
we scanned the bytes making up <span class="ix-entry" ix-key="Unicode" markdown="1">Unicode</span> characters in <a class="x-ref" href="../binary/">Chapter 17</a>.
The first choice spends space (i.e., memory and disk) to save time;
the second spends time to save space.
As <span class="bib-ref">[<a class="bib-ref" href="../bib/#Bentley1982">Bentley1982</a>]</span> pointed out over forty years ago,
a lot of performance optimizations in programming
come down to trading space for time or vice versa.</p>
</div>
<p>We could have records pack themselves as binary data
using the techniques of <a class="x-ref" href="../binary/">Chapter 17</a>,
but to make our test and sample output a little more readable,
we will pack numbers as strings
with a <a class="gl-ref" href="../glossary/#gl:null_byte" title="A byte with the value zero. Null bytes are used to mark the ends of strings in C and C++, and are sometimes used to fill unused space in fixed-size binary records." markdown="1">null byte</a> <code>\0</code> between each string:</p>
<div class="code-sample lang-py" title="record.py">
<div class="highlight"><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">pack</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">Experiment</span><span class="p">)</span>
    <span class="n">readings</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\0</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">record</span><span class="o">.</span><span class="n">_readings</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">record</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="se">\0</span><span class="si">{</span><span class="n">record</span><span class="o">.</span><span class="n">_timestamp</span><span class="si">}</span><span class="se">\0</span><span class="si">{</span><span class="n">readings</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Experiment</span><span class="o">.</span><span class="n">RECORD_LEN</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\0</span><span class="s2">&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">Experiment</span><span class="o">.</span><span class="n">RECORD_LEN</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
</div>
<p class="continue">The corresponding method to unpack a stored record is:</p>
<div class="code-sample lang-py" title="record.py">
<div class="highlight"><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">unpack</span><span class="p">(</span><span class="n">raw</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\0</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">readings</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">Experiment</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">readings</span><span class="p">)</span>
</code></pre></div>
</div>
<p>These records look like the example below
(which uses <code>.</code> to show null bytes):</p>
<div class="code-sample lang-py" title="show_packed_records.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">record</span> <span class="kn">import</span> <span class="n">Experiment</span>

<span class="n">ex</span> <span class="o">=</span> <span class="n">Experiment</span><span class="p">(</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="mi">12345</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Experiment</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">))</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="show_packed_records.out">
<div class="highlight"><pre><span></span><code>abcdef.12345.6.7.....
</code></pre></div>
</div>
<p class="continue">Notice that our packing and unpacking methods are static,
i.e.,
they&rsquo;re part of the class
but don&rsquo;t require an object to work.
More importantly,
they don&rsquo;t handle strings that contain null bytes.
This limitation wasn&rsquo;t part of our original design,
but is instead an accident of implementation.
We will look at ways around it in the exercises.</p>
<p>Finally,
we can write methods to pack and unpack multiple records at once
by joining and splitting single-record data:</p>
<div class="code-sample lang-py" title="record.py">
<div class="highlight"><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">pack_multi</span><span class="p">(</span><span class="n">records</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">Experiment</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">records</span><span class="p">])</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">unpack_multi</span><span class="p">(</span><span class="n">raw</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">Experiment</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="n">split</span> <span class="o">=</span> <span class="p">[</span><span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">size</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="n">size</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Experiment</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">split</span><span class="p">]</span>
</code></pre></div>
</div>
<h2 id="db-file">Section 18.3: A File-Backed Database</h2>
<p>We are now ready to extend our dictionary-based implementation
to write records to a file and load them as needed:</p>
<div class="code-sample lang-py" title="file_backed.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">FileBacked</span><span class="p">(</span><span class="n">Database</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">record_cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">touch</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</code></pre></div>
</div>
<p>This implementation stores everything in a single file,
whose name must be provided to the constructor
(<a class="fig-ref" href="../db/#db-single-file">Figure 18.2</a>).
If that file doesn&rsquo;t exist when the database object is created,
we use <code>Path.touch</code> to create an empty file;
either way,
we then load the entire database into memory.
When we add a record,
we save it in the dictionary
and call a <span class="ix-entry" ix-key="helper method" markdown="1">helper method</span> <code>_save</code>
to write the entire database back to the file.
When we get a record,
we simply get it from the in-memory dictionary.</p>
<figure id="db-single-file">
<img src="./single_file.svg" alt="Using a single file"/>
<figcaption markdown="1">Figure 18.2: Saving the entire database in a single file.</figcaption>
</figure>

<p>The two helper methods we need to make this work are:</p>
<div class="code-sample lang-py" title="file_backed.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">packed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">pack_multi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">writer</span><span class="p">:</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">packed</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">unpack_multi</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">r</span><span class="p">):</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">records</span><span class="p">}</span>
</code></pre></div>
</div>
<p>It isn&rsquo;t very efficient—we are
loading the entire database the first time we want a single record,
and saving the entire database every time we add a record—but
we are getting closer to our ultimate goal.</p>
<h2 id="db-block">Section 18.4: Playing With Blocks</h2>
<p>How can we make our file-backed implementation more efficient?
One option would be to save each record in a file of its own,
in the same way that we saved each version of a file in <a class="x-ref" href="../archive/">Chapter 10</a>.
However,
this strategy won&rsquo;t give us as much of a performance boost as we&rsquo;d like.
The reason is that computers do file I/O in <a class="gl-ref" href="../glossary/#gl:page" title="A fixed-size block of storage space. Most modern filesystems manage disks using 4K pages, and many other applications such as databases use the same page size to maximize efficiency." markdown="1">pages</a>
that are typically two or four kilobytes in size.
If we want to read a single byte,
the operating system actually reads a full page
and then gives us just the byte we asked for.</p>
<p>A more efficient strategy is therefore
to group records together in <a class="gl-ref" href="../glossary/#gl:block_memory" title="A region of memory of a fixed, constant size. Data is often divided into blocks to optimize input and output at the hardware level; software is then used to convert between blocks and streams." markdown="1">blocks of memory</a>,
each of which is the same size as a page,
and an <span class="ix-entry" ix-key="index (a database)" markdown="1">index</span> in memory
to tell us which records are in which blocks.
When we add a record,
we only write its block to disk;
similarly,
when we need a record whose block isn&rsquo;t already in memory,
we only need to read that block.</p>
<p>At this point we need to address an issue we should have tackled earlier.
How do we handle updates to records?
I.e.,
suppose we already have a record with the ID 12345;
what do we do when we get another record with the same ID?
If we are storing the entire database in a single dictionary,
the dictionary takes care of that for us,
but if we are storing things in blocks,
we will have multiple dictionaries.</p>
<p>This is where the &ldquo;log-structured&rdquo; part of our design comes in.
Whenever we add a record to the database,
we append it to the current block
or start another block if the current one is full
(<a class="fig-ref" href="../db/#db-alloc">Figure 18.3</a>).
We give each record a sequence number as we add it,
and our overall index keeps track of
the mapping from record IDs to sequence IDs.
Since we know how many records there are in a block,
we can quickly calculate which block contains
the record with a particular sequence ID.</p>
<figure id="db-alloc">
<img src="./alloc.svg" alt="Mapping records to blocks"/>
<figcaption markdown="1">Figure 18.3: Mapping records to blocks.</figcaption>
</figure>

<p>Let&rsquo;s create a new in-memory database
using one dictionary for each block.
The constructor creates <code>self._next</code>
to store the sequence ID of the next record,
<code>self._index</code> to map record IDs to sequence IDs,
and a list <code>self._blocks</code> to store blocks:</p>
<div class="code-sample lang-py" title="blocked.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Blocked</span><span class="p">(</span><span class="n">Database</span><span class="p">):</span>
    <span class="n">RECORDS_PER_BLOCK</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">Blocked</span><span class="o">.</span><span class="n">RECORDS_PER_BLOCK</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_cls</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">record_cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">num_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">num_records</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
</code></pre></div>
</div>
<p>To add a record, we:</p>
<ol>
<li>
<p>get the sequence ID for the record;</p>
</li>
<li>
<p>store the key-to-sequence mapping in the index;</p>
</li>
<li>
<p>find or create the right block; and</p>
</li>
<li>
<p>add the record.</p>
</li>
</ol>
<div class="code-sample lang-py" title="blocked.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
    <span class="n">seq_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_seq_id</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq_id</span>
    <span class="n">block_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_id</span><span class="p">(</span><span class="n">seq_id</span><span class="p">)</span>
    <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
    <span class="n">block</span><span class="p">[</span><span class="n">seq_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span>
</code></pre></div>
</div>
<p>To get a record given a record ID,
we first ask if we even have that record.
If we do,
we:</p>
<ol>
<li>
<p>find its current sequence ID;</p>
</li>
<li>
<p>find the corresponding block; and</p>
</li>
<li>
<p>get the record.</p>
</li>
</ol>
<div class="code-sample lang-py" title="blocked.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">seq_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="n">block_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_id</span><span class="p">(</span><span class="n">seq_id</span><span class="p">)</span>
    <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">block</span><span class="p">[</span><span class="n">seq_id</span><span class="p">]</span>
</code></pre></div>
</div>
<p>The three helper methods that <code>add</code> and <code>get</code> rely on are:</p>
<div class="code-sample lang-py" title="blocked.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_next_seq_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">seq_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">seq_id</span>

<span class="k">def</span> <span class="nf">_get_block_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_id</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">seq_id</span> <span class="o">//</span> <span class="n">Blocked</span><span class="o">.</span><span class="n">RECORDS_PER_BLOCK</span>

<span class="k">def</span> <span class="nf">_get_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">block_id</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="n">block_id</span><span class="p">]</span>
</code></pre></div>
</div>
<h2 id="db-persist">Section 18.5: Persisting Blocks</h2>
<p>We now have working prototypes of the two parts of our design:
saving data to file
and dividing records into blocks.
In order to combine them,
we will inherit from our block-based implementation
and extend the <code>add</code> and <code>get</code> methods to save and load data:</p>
<div class="code-sample lang-py" title="blocked_file.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">BlockedFile</span><span class="p">(</span><span class="n">Blocked</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_cls</span><span class="p">,</span> <span class="n">db_dir</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">record_cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_db_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">db_dir</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_index</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</code></pre></div>
</div>
<p>We will explain the call to <code>self._build_index()</code> in a few paragraphs.</p>
<div class="callout">
<h3>One at a Time</h3>
<p>Exploring ideas one at a time and then combining them
is a common tactic among experienced designers <span class="bib-ref">[<a class="bib-ref" href="../bib/#Petre2016">Petre2016</a>]</span>.
Creating classes like the all-in-one-file database
that we don&rsquo;t put into production
may feel like a waste of time,
but it usually saves us effort in the long run
by reducing <span class="ix-entry" ix-key="cognitive load" markdown="1">cognitive load</span>.</p>
</div>
<p>Saving a block is mostly a matter of bookkeeping at this point.
Given the record,
we figure out which block it does in,
save it,
pack the block,
and write the result to a file:</p>
<div class="code-sample lang-py" title="blocked_file.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
    <span class="n">seq_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="n">block_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_id</span><span class="p">(</span><span class="n">seq_id</span><span class="p">)</span>

    <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
    <span class="n">packed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">pack_multi</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_filename</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">writer</span><span class="p">:</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">packed</span><span class="p">))</span>
</code></pre></div>
</div>
<p>Loading involves almost the same steps,
but our implementation splits it into two pieces:</p>
<div class="code-sample lang-py" title="blocked_file.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="n">seq_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="n">block_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_id</span><span class="p">(</span><span class="n">seq_id</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_filename</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_load_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_load_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="n">records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">unpack_multi</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
    <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="n">block_id</span>
    <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">records</span><span class="p">):</span>
        <span class="n">block</span><span class="p">[</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
</code></pre></div>
</div>
<p>We put the code to load a single block in a method of its own
because we need to initialize the in-memory index when restarting the database:</p>
<div class="code-sample lang-py" title="blocked_file.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_build_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">seq_id</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">block_id</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_db_dir</span><span class="o">.</span><span class="n">iterdir</span><span class="p">())</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq_id</span>
            <span class="n">seq_id</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>
</div>
<p>An obvious extension to our design is to save the index
in a separate file
each time we add or modify a record.
However,
we should <span class="ix-entry" ix-key="profiler" markdown="1">profile</span> this change before putting it into production
to see if it actually improves performance (<a class="x-ref" href="../perf/">Chapter 15</a>),
since many small writes might cost more than one large multi-file read.
We would also have to do something
to avoid creating a <span class="ix-entry" ix-key="race condition" markdown="1">race condition</span>;
as in <a class="x-ref" href="../archive/">Chapter 10</a>,
operating on two files (one for the index and one for the block)
could lead to harmful inconsistencies.</p>
<h2 id="db-cleanup">Section 18.6: Cleaning Up</h2>
<p>The final step in our implementation is
to clean up blocks that are no longer needed
because we have a more recent version of every record they contain.
Reclaiming unused space this way is another form of
<a class="gl-ref" href="../glossary/#gl:garbage_collection" title="An automatic process in a program that finds and recycles memory that is no longer being used." markdown="1">garbage collection</a>.
Python and most other modern languages do it automatically
to recycle unused memory,
but it&rsquo;s our responsibility to do it for the files our database creates.</p>
<p>The implementation of cleanup is mostly a matter of bookkeeping:</p>
<div class="code-sample lang-py" title="cleanup.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">new_seq</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">o</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="p">}</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_block_id</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">new_seq</span><span class="p">}</span>

    <span class="n">renaming</span> <span class="o">=</span> <span class="p">{</span><span class="n">o</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">keep</span><span class="p">)))}</span>
    <span class="n">garbage_ids</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">renaming</span>
    <span class="p">}</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_delete_blocks</span><span class="p">(</span><span class="n">garbage_ids</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_rename_blocks</span><span class="p">(</span><span class="n">renaming</span><span class="p">)</span>

    <span class="n">new_index</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">new_seq</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>
    <span class="p">}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">new_index</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">The steps are:</p>
<ol>
<li>
<p>Calculate a new sequence ID for each record.</p>
</li>
<li>
<p>Figure out which blocks contain records that we need to retain.</p>
</li>
<li>
<p>Generate new block IDs for those blocks
    while also creating a set of IDs
    of blocks we can delete because all of their records are out of date.</p>
</li>
<li>
<p>Delete and rename blocks.</p>
</li>
<li>
<p>Generate a new in-memory index.</p>
</li>
</ol>
<p>This method doesn&rsquo;t <a class="gl-ref" href="../glossary/#gl:compact" title="To pack data so as to remove wasted or unused space." markdown="1">compact</a> storage,
i.e.,
it doesn&rsquo;t move records around
to get rid of stale blocks within records.
Production-quality databases do this periodically
in order to use the disk more efficiently;
we will explore this idea in the exercises.</p>
<h2 id="db-summary">Section 18.7: Summary</h2>
<figure id="db-concept-map" class="here">
<img src="./concept_map.svg" alt="Concept map for database"/>
<figcaption markdown="1">Figure 18.4: Concept map for a log-structured database.</figcaption>
</figure>

<h2 id="db-exercises">Section 18.8: Exercises</h2>
<h3 class="exercise">Packing Null Bytes</h3>
<p>Modify the experimental record class so that records are packed as strings
but can safely contain null bytes.</p>
<h3 class="exercise">Packing in Binary</h3>
<ol>
<li>
<p>Modify the experimental record class so that it packs itself in
a fixed-size binary record.</p>
</li>
<li>
<p>How does this change the file I/O operations in the database class?</p>
</li>
<li>
<p>Should those operations be moved into the record class or not?</p>
</li>
</ol>
<h3 class="exercise">Implement Compaction</h3>
<p>Add a static method to the database that compacts blocks,
i.e.,
rewrites all of the blocks so that only live records are stored.</p>
<h3 class="exercise">Save the Index Separately</h3>
<ol>
<li>
<p>Modify the database so that it saves the entire index in single file.</p>
</li>
<li>
<p>Design and run an experiment to determine
    if this change improves performance or not.</p>
</li>
</ol>
        </main>
      </div>
    </div>
  </body>
</html>
