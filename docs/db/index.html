<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="../logo.svg">
<link rel="stylesheet" href="../tango.css" type="text/css">
<link rel="stylesheet" href="../mccole.css" type="text/css">
<title>Software Design by Example &middot; A Database</title>
<script>
  MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)']]
    }
  };
</script>
<script
  type="text/javascript"
  id="MathJax-script"
  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>


  </head>
  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <a href="https://www.routledge.com/Software-Design-by-Example-A-Tool-Based-Introduction-with-Python/Wilson/p/book/9781032725215"><img src="../sdxpy-cover.png" alt="Book cover" class="bookcover" /></a>
  
</p>

<div class="screen-reader-only">
  <a href="#printable">Skip to content</a>
</div>

<ol class="toc-chapters"><li><a href="../intro/">Introduction</a></li><li><a href="../oop/">Objects and Classes</a></li><li><a href="../dup/">Finding Duplicate Files</a></li><li><a href="../glob/">Matching Patterns</a></li><li><a href="../parse/">Parsing Text</a></li><li><a href="../test/">Running Tests</a></li><li><a href="../interp/">An Interpreter</a></li><li><a href="../func/">Functions and Closures</a></li><li><a href="../protocols/">Protocols</a></li><li><a href="../archive/">A File Archiver</a></li><li><a href="../check/">An HTML Validator</a></li><li><a href="../template/">A Template Expander</a></li><li><a href="../lint/">A Code Linter</a></li><li><a href="../layout/">Page Layout</a></li><li><a href="../perf/">Performance Profiling</a></li><li><a href="../persist/">Object Persistence</a></li><li><a href="../binary/">Binary Data</a></li><li><a href="../db/">A Database</a></li><li><a href="../build/">A Build Manager</a></li><li><a href="../pack/">A Package Manager</a></li><li><a href="../ftp/">Transferring Files</a></li><li><a href="../http/">Serving Web Pages</a></li><li><a href="../viewer/">A File Viewer</a></li><li><a href="../undo/">Undo and Redo</a></li><li><a href="../vm/">A Virtual Machine</a></li><li><a href="../debugger/">A Debugger</a></li><li><a href="../eventsim/">Discrete Event Simulator</a></li><li><a href="../finale/">Conclusion</a></li></ol>
<ol class="toc-appendices"><li><a href="../bib/">Bibliography</a></li><li><a href="../bonus/">Bonus Material</a></li><li><a href="../syllabus/">Syllabus</a></li><li><a href="../license/">License</a></li><li><a href="../conduct/">Code of Conduct</a></li><li><a href="../contrib/">Contributing</a></li><li><a href="../glossary/">Glossary</a></li><li><a href="../colophon/">Colophon</a></li><li><a href="../contents/">Index</a></li></ol>


<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


<p><a href="https://github.com/gvwilson/sdxpy">GitHub repository</a></p>

      </div>
      <div id="printable" class="contents bordered">
	<main>
	  <div class="row notex">
  <div class="col-12 center">
    
      <h1>A Database</h1>
    
  </div>
</div>

	  
<nav class="row-always notex">
  <div class="col-1 left">
    <a href="../binary/" title="previous" class="undecorated">&#8678;</a>
  </div>
  <div class="col-10 center">
    <a href="../" title="home" class="undecorated">&#9737;</a>
  </div>
  <div class="col-1 right">
    <a href="../build/" title="next" class="undecorated">&#8680;</a>
  </div>
</nav>


	  <ul class="keypoints">
<li>Database stores records so that they can be accessed by key.</li>
<li>Log-structured database appends new records to database and invalidates older versions of records.</li>
<li>Classes are data structures that can be saved like any other data.</li>
<li>The filesystem saves data in fixed-size pages.</li>
<li>We can improve the efficiency of a database by saving records in blocks.</li>
</ul>
	  <p class="terms">Terms defined: 
<a class="gl-ref" href="../glossary/#block_memory" markdown="1">block (of memory)</a>, <a class="gl-ref" href="../glossary/#compact" markdown="1">compact (data or files)</a>, <a class="gl-ref" href="../glossary/#garbage_collection" markdown="1">garbage collection</a>, <a class="gl-ref" href="../glossary/#key_value_store" markdown="1">key-value store</a>, <a class="gl-ref" href="../glossary/#log_structured_db" markdown="1">log-structured database</a>, <a class="gl-ref" href="../glossary/#null_byte" markdown="1">null byte</a>, <a class="gl-ref" href="../glossary/#page" markdown="1">page</a>
</p>
	  <p>Persisting objects (<a href="../persist/">Chapter&nbsp;16</a>) lets us save and restore program state,
but we often want to be able to look things up quickly
without reloading all of our data.
We would also like applications written in different languages
to be able to get at our data,
which might be easier if we choose a different storage format.</p>
<p>This chapter therefore builds a very simple
<a class="gl-ref" href="../glossary/#log_structured_db" markdown="1">log-structured database</a>.
The phrase &ldquo;log-structured&rdquo; means that records a log of operations,
i.e.,
every new <span class="ix-entry" ix-key="record" markdown="1">record</span> is appended to the end of the database.
Programmers have invented many other ways to store large amounts of data,
but this is one of the easiest to understand.</p>
<h2 id="db-start">Starting Point</h2>
<p>Our starting point is
a simple <a class="gl-ref" href="../glossary/#key_value_store" markdown="1">key-value store</a>
that lets us save records and look them up later.
To use it,
we have to provide a function that takes a record
and returns its key.
We store that function in the <code>Database</code> object for later use:</p>
<div class="language-py" title="interface_original.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Database</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize with function to get key.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key_func</span> <span class="o">=</span> <span class="n">key_func</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store the given record.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return record associated with key or None.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;get&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p>If we want a dictionary that only stores things in memory,
we can derive a class from <code>Database</code>
that uses a dictionary with the values returned by
the user&rsquo;s key function for lookup
(<a class="fig-ref" href="../db/#db-memory">Figure&nbsp;18.1</a>):</p>
<div class="language-py" title="just_dict_original.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">interface_original</span> <span class="kn">import</span> <span class="n">Database</span>

<span class="k">class</span> <span class="nc">JustDict</span><span class="p">(</span><span class="n">Database</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_func</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">key_func</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_func</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</code></pre></div>
</div>
<figure id="db-memory">
<img src="./memory.svg" alt="In-memory database"/>
<figcaption>Figure&nbsp;18.1: Storing a database as a single dictionary in memory.</figcaption>
</figure>

<p>This simple class is enough to let us start writing some tests.
Let&rsquo;s create a class to store experimental records:</p>
<div class="language-py" title="record_original.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">BasicRec</span><span class="p">:</span>
    <span class="n">MAX_NAME_LEN</span> <span class="o">=</span> <span class="mi">6</span>     <span class="c1"># length of name in chars</span>
    <span class="n">TIMESTAMP_LEN</span> <span class="o">=</span> <span class="mi">8</span>    <span class="c1"># length of timestamp in chars</span>
    <span class="n">MAX_READING</span> <span class="o">=</span> <span class="mi">10</span>     <span class="c1"># maximum reading value</span>
    <span class="n">MAX_READING_LEN</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># length of reading in chars</span>
    <span class="n">MAX_READINGS_NUM</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># maximum number of readings</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">BasicRec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">record</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">readings</span><span class="p">):</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAX_NAME_LEN</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">readings</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAX_READINGS_NUM</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">((</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAX_READING</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">readings</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_timestamp</span> <span class="o">=</span> <span class="n">timestamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_readings</span> <span class="o">=</span> <span class="n">readings</span>

    <span class="c1"># [omit]</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">joined</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_readings</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_timestamp</span><span class="si">}</span><span class="s2">)[</span><span class="si">{</span><span class="n">joined</span><span class="si">}</span><span class="s2">]&quot;</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_timestamp</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_timestamp</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_readings</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_readings</span><span class="p">)</span>
    <span class="c1"># [/omit]</span>
</code></pre></div>
</div>
<p class="continue">and use the <code>pytest.fixture</code> <span class="ix-entry" ix-key="decorator" markdown="1">decorator</span> (<a href="../protocols/">Chapter&nbsp;9</a>)
to create a database and two records:</p>
<div class="pagebreak"></div>

<div class="language-py" title="test_db_original.py">
<div class="highlight"><pre><span></span><code><span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">db</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">JustDict</span><span class="p">(</span><span class="n">BasicExperiment</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">ex01</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">BasicExperiment</span><span class="p">(</span><span class="s2">&quot;ex01&quot;</span><span class="p">,</span> <span class="mi">12345</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="nd">@pytest</span><span class="o">.</span><span class="n">fixture</span>
<span class="k">def</span> <span class="nf">ex02</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">BasicExperiment</span><span class="p">(</span><span class="s2">&quot;ex02&quot;</span><span class="p">,</span> <span class="mi">67890</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</code></pre></div>
</div>
<p class="continue">Our first few tests are then:</p>
<div class="language-py" title="test_db_original.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_construct</span><span class="p">(</span><span class="n">db</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">db</span>

<span class="k">def</span> <span class="nf">test_get_nothing_from_empty_db</span><span class="p">(</span><span class="n">db</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">db</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;something&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">test_add_then_get</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">ex01</span><span class="p">):</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ex01</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">db</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ex01&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ex01</span>

<span class="k">def</span> <span class="nf">test_add_two_then_get_both</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">ex01</span><span class="p">,</span> <span class="n">ex02</span><span class="p">):</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ex01</span><span class="p">)</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ex02</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">db</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ex01&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ex01</span>
    <span class="k">assert</span> <span class="n">db</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ex02&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ex02</span>

<span class="k">def</span> <span class="nf">test_add_then_overwrite</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">ex01</span><span class="p">):</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ex01</span><span class="p">)</span>
    <span class="n">ex01</span><span class="o">.</span><span class="n">_timestamp</span> <span class="o">=</span> <span class="mi">67890</span>
    <span class="n">db</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ex01</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">db</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ex01&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ex01</span>
</code></pre></div>
</div>
<p>Our next step is to save the user&rsquo;s records in the database
without tying the database to a particular type of record.
The cleanest way to solve this problem is
to require records to know how to convert themselves into something storable.
Rather than passing a second function to the database&rsquo;s constructor,
we will <span class="ix-entry" ix-key="refactor" markdown="1">refactor</span> the database
so that we pass in the object that represents the record class:</p>
<div class="language-py" title="interface.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Database</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize with data manipulation functions.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span> <span class="o">=</span> <span class="n">record_cls</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store the given record.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return record associated with key or None.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;get&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p>We can now refactor our database
to use a <span class="ix-entry" ix-key="static method" markdown="1">static method</span> of the record class provided to its constructor
when it needs a key:</p>
<div class="pagebreak"></div>

<div class="language-py" title="just_dict_refactored.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">interface</span> <span class="kn">import</span> <span class="n">Database</span>

<span class="k">class</span> <span class="nc">JustDictRefactored</span><span class="p">(</span><span class="n">Database</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_cls</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">record_cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</code></pre></div>
</div>
<h2 id="db-save">Saving Records</h2>
<p>The next step in building a usable database is to have it store records
rather than just refer to the user&rsquo;s objects.
Since we don&rsquo;t want the database tied to any particular kind of record,
records must know how to pack and unpack themselves.
We could have used the techniques of <a href="../binary/">Chapter&nbsp;17</a>,
but to make our test and sample output a little more readable,
we will pack numbers as strings
with a <a class="gl-ref" href="../glossary/#null_byte" markdown="1">null byte</a> <code>\0</code> between each string:</p>
<div class="language-py" title="record.py">
<div class="highlight"><pre><span></span><code>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">pack</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">Experiment</span><span class="p">)</span>
        <span class="n">readings</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\0</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">record</span><span class="o">.</span><span class="n">_readings</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">record</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="se">\0</span><span class="si">{</span><span class="n">record</span><span class="o">.</span><span class="n">_timestamp</span><span class="si">}</span><span class="se">\0</span><span class="si">{</span><span class="n">readings</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Experiment</span><span class="o">.</span><span class="n">RECORD_LEN</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\0</span><span class="s2">&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">Experiment</span><span class="o">.</span><span class="n">RECORD_LEN</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
</div>
<p class="continue">The corresponding method to unpack a stored record is:</p>
<div class="language-py" title="record.py">
<div class="highlight"><pre><span></span><code>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">unpack</span><span class="p">(</span><span class="n">raw</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\0</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">readings</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">Experiment</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">readings</span><span class="p">)</span>
</code></pre></div>
</div>
<p>These records look like the example below
(which uses <code>.</code> to show null bytes):</p>
<div class="language-py" title="show_packed_records.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">record</span> <span class="kn">import</span> <span class="n">Experiment</span>

<span class="n">ex</span> <span class="o">=</span> <span class="n">Experiment</span><span class="p">(</span><span class="s2">&quot;abcdef&quot;</span><span class="p">,</span> <span class="mi">12345</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Experiment</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">))</span>
</code></pre></div>
</div>
<div class="language-out" title="show_packed_records.out">
<div class="highlight"><pre><span></span><code>abcdef.12345.6.7.....
</code></pre></div>
</div>
<p class="continue">Notice that our packing and unpacking methods are static,
i.e.,
they&rsquo;re part of the class
but don&rsquo;t require an object to work.
More importantly,
they don&rsquo;t handle strings that contain null bytes.
This limitation wasn&rsquo;t part of our original design,
but is instead an accident of implementation.
We will look at ways around it in the exercises.</p>
<p>To finish off,
we write methods to pack and unpack multiple records at once
by joining and splitting single-record data:</p>
<div class="language-py" title="record.py">
<div class="highlight"><pre><span></span><code>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">pack_multi</span><span class="p">(</span><span class="n">records</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">Experiment</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">records</span><span class="p">])</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">unpack_multi</span><span class="p">(</span><span class="n">raw</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">Experiment</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">split</span> <span class="o">=</span> <span class="p">[</span><span class="n">raw</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">size</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="n">size</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Experiment</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">split</span><span class="p">]</span>
</code></pre></div>
</div>
<p class="continue">and give our record class a static method
that calculates the size of a single record:</p>
<div class="language-py" title="record.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Experiment</span><span class="p">(</span><span class="n">BasicRec</span><span class="p">):</span>
    <span class="n">RECORD_LEN</span> <span class="o">=</span> <span class="n">BasicRec</span><span class="o">.</span><span class="n">MAX_NAME_LEN</span> <span class="o">+</span> <span class="mi">1</span> \
        <span class="o">+</span> <span class="n">BasicRec</span><span class="o">.</span><span class="n">TIMESTAMP_LEN</span> <span class="o">+</span> <span class="mi">1</span> \
        <span class="o">+</span> <span class="p">(</span><span class="n">BasicRec</span><span class="o">.</span><span class="n">MAX_READING_LEN</span> <span class="o">*</span> <span class="n">BasicRec</span><span class="o">.</span><span class="n">MAX_READINGS_NUM</span><span class="p">)</span> \
        <span class="o">+</span> <span class="p">(</span><span class="n">BasicRec</span><span class="o">.</span><span class="n">MAX_READINGS_NUM</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">Experiment</span><span class="o">.</span><span class="n">RECORD_LEN</span>
</code></pre></div>
</div>
<div class="callout">
<h3>Tradeoffs</h3>
<p>We&rsquo;re assuming that every record is the same size.
If we want to save records with variable-length fields such as strings,
we can either set a maximum size and always save that much data
or make our implementation more complicated (and probably slower)
by saving each record&rsquo;s size
and then scanning records in the same way that
we scanned the bytes making up <span class="ix-entry" ix-key="Unicode" markdown="1">Unicode</span> characters in <a href="../binary/">Chapter&nbsp;17</a>.
The first choice spends space (i.e., memory and disk) to save time;
the second spends time to save space.
As <span class="bib-ref">[<a class="bib-ref" href="../bib/#Bentley1982">Bentley1982</a>]</span> pointed out over 40 years ago,
a lot of performance optimizations in programming
come down to trading space for time or vice versa.</p>
</div>
<h2 id="db-file">A File-Backed Database</h2>
<p>We now have what we need to extend our dictionary-based implementation
to write records to a file and load them as needed:</p>
<div class="language-py" title="file_backed.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">FileBacked</span><span class="p">(</span><span class="n">Database</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">record_cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">touch</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</code></pre></div>
</div>
<p>This implementation stores everything in a single file,
whose name must be provided to the database&rsquo;s constructor
(<a class="fig-ref" href="../db/#db-single-file">Figure&nbsp;18.2</a>).
If that file doesn&rsquo;t exist when the database object is created,
we use <code>Path.touch</code> to create an empty file;
either way,
we then load the entire database into memory.
When we add a record,
we save it in the dictionary
and call a <span class="ix-entry" ix-key="helper method" markdown="1">helper method</span> <code>_save</code>
to write the entire database back to the file.
When we get a record,
we simply get it from the in-memory dictionary.</p>
<figure id="db-single-file" class="here">
<img src="./single_file.svg" alt="Using a single file"/>
<figcaption>Figure&nbsp;18.2: Saving the entire database in a single file.</figcaption>
</figure>

<p>The two helper methods we need to make this work are:</p>
<div class="language-py" title="file_backed.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">_save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">packed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">pack_multi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">writer</span><span class="p">:</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">packed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
            <span class="n">raw</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">unpack_multi</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">r</span><span class="p">):</span> <span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">records</span><span class="p">}</span>
</code></pre></div>
</div>
<p>It isn&rsquo;t very efficient—we are
loading the entire database the first time we want a single record,
and saving the entire database every time we add a record—but
we are getting closer to something we might actually use.</p>
<h2 id="db-block">Playing with Blocks</h2>
<p>How can we make our file-backed implementation more efficient?
One option would be to save each record in a file of its own,
in the same way that we saved each version of a file in <a href="../archive/">Chapter&nbsp;10</a>.
However,
this strategy won&rsquo;t give us as much of a performance boost as we&rsquo;d like.
The reason is that computers do file I/O in <a class="gl-ref" href="../glossary/#page" markdown="1">pages</a>
that are typically 2 or 4 kilobytes in size.
Even when we want to read a single byte,
the operating system always reads a full page
and then gives us just the byte we asked for.</p>
<p>A more efficient strategy is
to group records together in <a class="gl-ref" href="../glossary/#block_memory" markdown="1">blocks of memory</a>,
each of which is the same size as a page,
and to create an <span class="ix-entry" ix-key="index (a database)" markdown="1">index</span> in memory
to tell us which records are in which blocks.
When we add a record,
we only write its block to disk;
similarly,
when we need a record whose block isn&rsquo;t already in memory,
we only read that block.</p>
<p>At this point we need to address an issue we should have tackled earlier.
How do we handle updates to records?
For example,
suppose we already have a record with the ID 12345;
what do we do when we get another record with the same ID?
If we are storing the entire database in a single dictionary,
the dictionary takes care of that for us,
but if we are storing things in blocks,
we will have multiple dictionaries.</p>
<p>This is where the &ldquo;log-structured&rdquo; part of our design comes in.
Whenever we add a record to the database,
we append it to the current block
or start another block if the current one is full
(<a class="fig-ref" href="../db/#db-alloc">Figure&nbsp;18.3</a>).
We give each record a sequence number as we add it,
and our overall index keeps track of
the mapping from record IDs to sequence IDs.
Since we know how many records there are in a block,
we can quickly calculate which block contains
the record with a particular sequence ID.</p>
<figure id="db-alloc" class="here">
<img src="./alloc.svg" alt="Mapping records to blocks"/>
<figcaption>Figure&nbsp;18.3: Mapping records to blocks.</figcaption>
</figure>

<p>Let&rsquo;s create a new in-memory database
using one dictionary for each block.
The constructor creates <code>self._next</code>
to store the sequence ID of the next record,
<code>self._index</code> to map record IDs to sequence IDs,
and a list <code>self._blocks</code> to store blocks:</p>
<div class="language-py" title="blocked.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Blocked</span><span class="p">(</span><span class="n">Database</span><span class="p">):</span>
    <span class="n">RECORDS_PER_BLOCK</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">Blocked</span><span class="o">.</span><span class="n">RECORDS_PER_BLOCK</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_cls</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">record_cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">num_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">num_records</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
</code></pre></div>
</div>
<p>To add a record, we:</p>
<ol>
<li>
<p>get the sequence ID for the record;</p>
</li>
<li>
<p>store the key-to-sequence mapping in the index;</p>
</li>
<li>
<p>find or create the right block; and</p>
</li>
<li>
<p>add the record.</p>
</li>
</ol>
<div class="language-py" title="blocked.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="n">seq_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_seq_id</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq_id</span>
        <span class="n">block_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_id</span><span class="p">(</span><span class="n">seq_id</span><span class="p">)</span>
        <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
        <span class="n">block</span><span class="p">[</span><span class="n">seq_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span>
</code></pre></div>
</div>
<p>To get a record given a record ID,
we first ask if we even have that record.
If we do,
we:</p>
<ol>
<li>
<p>find its current sequence ID;</p>
</li>
<li>
<p>find the corresponding block; and</p>
</li>
<li>
<p>get the record.</p>
</li>
</ol>
<div class="language-py" title="blocked.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">seq_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">block_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_id</span><span class="p">(</span><span class="n">seq_id</span><span class="p">)</span>
        <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">block</span><span class="p">[</span><span class="n">seq_id</span><span class="p">]</span>
</code></pre></div>
</div>
<p>The three helper methods that <code>add</code> and <code>get</code> rely on are:</p>
<div class="language-py" title="blocked.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">_next_seq_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">seq_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">seq_id</span>

    <span class="k">def</span> <span class="nf">_get_block_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">seq_id</span> <span class="o">//</span> <span class="n">Blocked</span><span class="o">.</span><span class="n">RECORDS_PER_BLOCK</span>

    <span class="k">def</span> <span class="nf">_get_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">block_id</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">[</span><span class="n">block_id</span><span class="p">]</span>
</code></pre></div>
</div>
<h2 id="db-persist">Persisting Blocks</h2>
<p>We now have working prototypes of the two parts of our design:
saving data to file
and dividing records into blocks.
In order to combine them,
we will inherit from our block-based implementation
and extend the <code>add</code> and <code>get</code> methods to save and load data:</p>
<div class="language-py" title="blocked_file.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">BlockedFile</span><span class="p">(</span><span class="n">Blocked</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_cls</span><span class="p">,</span> <span class="n">db_dir</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">record_cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_db_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">db_dir</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_index</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</code></pre></div>
</div>
<p>We will explain the call to <code>self._build_index()</code> in a few paragraphs.</p>
<div class="callout">
<h3>One at a Time</h3>
<p>Exploring ideas one at a time and then combining them
is a common tactic among experienced designers <span class="bib-ref">[<a class="bib-ref" href="../bib/#Petre2016">Petre2016</a>]</span>.
Creating classes like the all-in-one-file database
that we don&rsquo;t put into production
may feel like a waste of time,
but it usually saves us effort in the long run
by reducing <span class="ix-entry" ix-key="cognitive load" markdown="1">cognitive load</span>.</p>
</div>
<p>Saving a block is mostly a matter of bookkeeping at this point.
Given the record,
we figure out which block it belongs in,
save it,
pack the block,
and write the result to a file:</p>
<div class="language-py" title="blocked_file.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">_save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
        <span class="n">seq_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">block_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_id</span><span class="p">(</span><span class="n">seq_id</span><span class="p">)</span>

        <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
        <span class="n">packed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">pack_multi</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_filename</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">writer</span><span class="p">:</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">packed</span><span class="p">))</span>
</code></pre></div>
</div>
<p>Loading involves almost the same steps,
but our implementation splits it into two pieces:</p>
<div class="language-py" title="blocked_file.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">seq_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">block_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_id</span><span class="p">(</span><span class="n">seq_id</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_filename</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_load_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_id</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
            <span class="n">raw</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="n">records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">unpack_multi</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="n">block_id</span>
        <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">records</span><span class="p">):</span>
            <span class="n">block</span><span class="p">[</span><span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
</code></pre></div>
</div>
<p>We put the code to load a single block in a method of its own
because we need to initialize the in-memory index when restarting the database:</p>
<div class="language-py" title="blocked_file.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">_build_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">seq_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">block_id</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_db_dir</span><span class="o">.</span><span class="n">iterdir</span><span class="p">())</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block</span><span class="p">(</span><span class="n">block_id</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_cls</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq_id</span>
                <span class="n">seq_id</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>
</div>
<p>An obvious extension to our design is to save the index
in a separate file
each time we add or modify a record.
However,
we should <span class="ix-entry" ix-key="profiler" markdown="1">profile</span> this change before putting it into production
to see if it actually improves performance (<a href="../perf/">Chapter&nbsp;15</a>),
since many small writes might cost more than one large multi-file read.
We would also have to do something
to avoid creating a <span class="ix-entry" ix-key="race condition" markdown="1">race condition</span>;
as in <a href="../archive/">Chapter&nbsp;10</a>,
operating on two files (one for the index and one for the block)
could lead to harmful inconsistencies.</p>
<h2 id="db-cleanup">Cleaning Up</h2>
<p>The final step in our implementation is
to clean up blocks that are no longer needed
because we have a more recent version of every record they contain.
Reclaiming unused space this way is another form of
<a class="gl-ref" href="../glossary/#garbage_collection" markdown="1">garbage collection</a>.
Python and most other modern languages do it automatically
to recycle unused memory,
but it&rsquo;s our responsibility to do it for the files our database creates.</p>
<p>The steps in cleanup are:</p>
<ol>
<li>
<p>Calculate a new sequence ID for each record.</p>
</li>
<li>
<p>Figure out which blocks contain records that we need to retain.</p>
</li>
<li>
<p>Generate new block IDs for those blocks
    while also creating a set of IDs
    of blocks we can delete because all of their records are out of date.</p>
</li>
<li>
<p>Delete and rename blocks.</p>
</li>
<li>
<p>Generate a new in-memory index.</p>
</li>
</ol>
<p class="continue">The implementation of these steps is mostly a matter of bookkeeping:</p>
<div class="language-py" title="cleanup.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">new_seq</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">o</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="p">}</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_block_id</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">new_seq</span><span class="p">}</span>

        <span class="n">renaming</span> <span class="o">=</span> <span class="p">{</span><span class="n">o</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">keep</span><span class="p">)))}</span>
        <span class="n">garbage_ids</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_blocks</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">renaming</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_delete_blocks</span><span class="p">(</span><span class="n">garbage_ids</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rename_blocks</span><span class="p">(</span><span class="n">renaming</span><span class="p">)</span>

        <span class="n">new_index</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">new_seq</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">new_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_next</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">)</span>
</code></pre></div>
</div>
<p>This method doesn&rsquo;t <a class="gl-ref" href="../glossary/#compact" markdown="1">compact</a> storage,
i.e.,
it doesn&rsquo;t move records around
to get rid of stale blocks within records.
Production-quality databases do this periodically
in order to use the disk more efficiently;
we will explore this idea in the exercises.</p>
<h2 id="db-summary">Summary</h2>
<p><a class="fig-ref" href="../db/#db-concept-map">Figure&nbsp;18.4</a> summarizes the key ideas introduced in this chapter.
Most real databases use different data structures than ours,
but must deal with the same challenges:
making data access fast without ever losing data or allowing it to become inconsistent.</p>
<figure id="db-concept-map" class="here">
<img src="./concept_map.svg" alt="Concept map for database"/>
<figcaption>Figure&nbsp;18.4: Concept map for a log-structured database.</figcaption>
</figure>

<h2 id="db-exercises">Exercises</h2>
<h3 class="exercise">Packing Null Bytes</h3>
<p>Modify the experimental record class so that records are packed as strings
but can safely contain null bytes.</p>
<h3 class="exercise">Packing in Binary</h3>
<ol>
<li>
<p>Modify the experimental record class so that it packs itself in
a fixed-size binary record.</p>
</li>
<li>
<p>How does this change the file I/O operations in the database class?</p>
</li>
<li>
<p>Should those operations be moved into the record class or not?</p>
</li>
</ol>
<h3 class="exercise">Implement Compaction</h3>
<p>Add a static method to the database that compacts blocks,
i.e.,
rewrites all of the blocks so that only live records are stored.</p>
<h3 class="exercise">Save the Index Separately</h3>
<ol>
<li>
<p>Modify the database so that it saves the entire index
    in a single file.</p>
</li>
<li>
<p>Design and run an experiment to determine
    if this change improves performance or not.</p>
</li>
</ol>
	</main>
	<footer>
  © 2024 <a href="https://third-bit.com/">Greg Wilson</a>
  &middot;
  <a href="../">home</a>
  &middot;
  <a href="https://github.com/gvwilson/sdxpy">repository</a>
  &middot;
  <a href="../license/">license</a>
</footer>

      </div>
    </div>
  </body>
</html>
