<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="../logo.svg">
<link rel="stylesheet" href="../tango.css" type="text/css">
<link rel="stylesheet" href="../mccole.css" type="text/css">
<title>Software Design by Example &middot; Matching Patterns</title>
<script>
  MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)']]
    }
  };
</script>
<script
  type="text/javascript"
  id="MathJax-script"
  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>


  </head>
  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <a href="https://www.routledge.com/Software-Design-by-Example-A-Tool-Based-Introduction-with-Python/Wilson/p/book/9781032725215"><img src="../sdxpy-cover.png" alt="Book cover" class="bookcover" /></a>
  
</p>

<div class="screen-reader-only">
  <a href="#printable">Skip to content</a>
</div>

<ol class="toc-chapters"><li><a href="../intro/">Introduction</a></li><li><a href="../oop/">Objects and Classes</a></li><li><a href="../dup/">Finding Duplicate Files</a></li><li><a href="../glob/">Matching Patterns</a></li><li><a href="../parse/">Parsing Text</a></li><li><a href="../test/">Running Tests</a></li><li><a href="../interp/">An Interpreter</a></li><li><a href="../func/">Functions and Closures</a></li><li><a href="../protocols/">Protocols</a></li><li><a href="../archive/">A File Archiver</a></li><li><a href="../check/">An HTML Validator</a></li><li><a href="../template/">A Template Expander</a></li><li><a href="../lint/">A Code Linter</a></li><li><a href="../layout/">Page Layout</a></li><li><a href="../perf/">Performance Profiling</a></li><li><a href="../persist/">Object Persistence</a></li><li><a href="../binary/">Binary Data</a></li><li><a href="../db/">A Database</a></li><li><a href="../build/">A Build Manager</a></li><li><a href="../pack/">A Package Manager</a></li><li><a href="../ftp/">Transferring Files</a></li><li><a href="../http/">Serving Web Pages</a></li><li><a href="../viewer/">A File Viewer</a></li><li><a href="../undo/">Undo and Redo</a></li><li><a href="../vm/">A Virtual Machine</a></li><li><a href="../debugger/">A Debugger</a></li><li><a href="../orm/">Object-Relational Mapper</a></li><li><a href="../finale/">Conclusion</a></li></ol>
<ol class="toc-appendices"><li><a href="../bib/">Bibliography</a></li><li><a href="../bonus/">Bonus Material</a></li><li><a href="../syllabus/">Syllabus</a></li><li><a href="../license/">License</a></li><li><a href="../conduct/">Code of Conduct</a></li><li><a href="../contrib/">Contributing</a></li><li><a href="../glossary/">Glossary</a></li><li><a href="../colophon/">Colophon</a></li><li><a href="../contents/">Index</a></li></ol>


<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


<p><a href="https://github.com/gvwilson/sdxpy">GitHub repository</a></p>

      </div>
      <div id="printable" class="contents bordered">
	<main>
	  <div class="row notex">
  <div class="col-12 center">
    
      <h1>Matching Patterns</h1>
    
  </div>
</div>

	  
<nav class="row-always notex">
  <div class="col-1 left">
    <a href="../dup/" title="previous" class="undecorated">&#8678;</a>
  </div>
  <div class="col-10 center">
    <a href="../" title="home" class="undecorated">&#9737;</a>
  </div>
  <div class="col-1 right">
    <a href="../parse/" title="next" class="undecorated">&#8680;</a>
  </div>
</nav>


	  <ul class="keypoints">
<li>Use globs and regular expressions to match patterns in text.</li>
<li>Use inheritance to make matchers composable and extensible.</li>
<li>Simplify code by having objects delegate work to other objects.</li>
<li>Use the Null Object pattern to eliminate special cases in code.</li>
<li>Use standard refactorings to move code from one working state to another.</li>
<li>Build and check the parts of your code you are least sure of first to find out if your design will work.</li>
</ul>
	  <p class="terms">Terms defined: 
<a class="gl-ref" href="../glossary/#chain_of_responsibility_pattern" markdown="1">Chain of Responsibility pattern</a>, <a class="gl-ref" href="../glossary/#child_class" markdown="1">child class</a>, <a class="gl-ref" href="../glossary/#extract_parent_class_refactoring" markdown="1">Extract Parent Class refactoring</a>, <a class="gl-ref" href="../glossary/#globbing" markdown="1">globbing</a>, <a class="gl-ref" href="../glossary/#greedy_matching" markdown="1">greedy matching</a>, <a class="gl-ref" href="../glossary/#helper_method" markdown="1">helper method</a>, <a class="gl-ref" href="../glossary/#inheritance" markdown="1">inheritance</a>, <a class="gl-ref" href="../glossary/#lazy_matching" markdown="1">lazy matching</a>, <a class="gl-ref" href="../glossary/#literal" markdown="1">literal (in parsing)</a>, <a class="gl-ref" href="../glossary/#null_object_pattern" markdown="1">Null Object pattern</a>, <a class="gl-ref" href="../glossary/#refactor" markdown="1">refactor</a>, <a class="gl-ref" href="../glossary/#regular_expression" markdown="1">regular expression</a>, <a class="gl-ref" href="../glossary/#signature" markdown="1">signature</a>, <a class="gl-ref" href="../glossary/#tdd" markdown="1">test-driven development</a>, <a class="gl-ref" href="../glossary/#technical_debt" markdown="1">technical debt</a>
</p>
	  <p>We used <code>*.txt</code> to tell the duplicate file finder of <a href="../dup/">Chapter&nbsp;3</a> which files to compare.
Older programmers (like this author) refer to this kind of pattern-matching as <a class="gl-ref" href="../glossary/#globbing" markdown="1">globbing</a>
because early versions of Unix had a tool called <a href="https://en.wikipedia.org/wiki/Glob_(programming)"><code>glob</code></a> to do it.
Globbing was so useful that it was quickly added to the shell,
and the <span class="ix-entry" ix-key="Python standard library" markdown="1">Python standard library</span> includes a module called <a href="https://docs.python.org/3/library/glob.html"><code>glob</code></a>
to match filenames in the same way.
For example,
<code>2023-*.{pdf,txt}</code> matches <code>2023-01.txt</code> and <code>2023-final.pdf</code> but not <code>draft-2023.docx</code>
(<a class="fig-ref" href="../glob/#glob-examples">Figure&nbsp;4.1</a>).</p>
<figure id="glob-examples">
<img src="./examples.svg" alt="Matching examples"/>
<figcaption>Figure&nbsp;4.1: Examples of glob matching.</figcaption>
</figure>

<p>Globbing patterns are simpler than
the <a class="gl-ref" href="../glossary/#regular_expression" markdown="1">regular expressions</a>
used to scrape data from text files,
but the principles are the same.
This chapter therefore implements a simple version of globbing
to show how pattern-matching works in general.
This matcher will only handle the cases in <a class="tbl-ref" href="../glob/#pattern-glob-cases">Table&nbsp;4.1</a>,
but as the exercises will show,
our design makes it easy to add new kinds of patterns.</p>
<table id="pattern-glob-cases"><caption>Table&nbsp;4.1: Pattern-matching cases.</caption>
<thead>
<tr>
<th>Pattern</th>
<th>Text</th>
<th>Match?</th>
<th>Pattern</th>
<th>Text</th>
<th>Match?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>abc</code></td>
<td>&ldquo;abc&rdquo;</td>
<td>true</td>
<td><code>a*c</code></td>
<td>&ldquo;abc&rdquo;</td>
<td>true</td>
</tr>
<tr>
<td><code>ab</code></td>
<td>&ldquo;abc&rdquo;</td>
<td>false</td>
<td><code>{a,b}</code></td>
<td>&ldquo;a&rdquo;</td>
<td>true</td>
</tr>
<tr>
<td><code>abc</code></td>
<td>&ldquo;ab&rdquo;</td>
<td>false</td>
<td><code>{a,b}</code></td>
<td>&ldquo;c&rdquo;</td>
<td>false</td>
</tr>
<tr>
<td><code>*</code></td>
<td>&rdquo;&ldquo;</td>
<td>true</td>
<td><code>{a,b}</code></td>
<td>&ldquo;ab&rdquo;</td>
<td>false</td>
</tr>
<tr>
<td><code>*</code></td>
<td>&ldquo;abc&rdquo;</td>
<td>true</td>
<td><code>*{x,y}</code></td>
<td>&ldquo;abcx&rdquo;</td>
<td>true</td>
</tr>
</tbody>
</table>

<h2 id="glob-simple">Simple Patterns</h2>
<p>Matching is conceptually simple.
If the first element of the pattern
matches the target string at the current location,
we check if the rest of the pattern matches what&rsquo;s left of the string.
If the element doesn&rsquo;t match the front of the string,
or if the rest of the pattern can&rsquo;t match the rest of the string,
matching fails.
(This behavior makes globbing different from regular expressions,
which can match parts of strings.)</p>
<p>This design makes use of
the <a class="gl-ref" href="../glossary/#chain_of_responsibility_pattern" markdown="1">Chain of Responsibility</a>
<span class="ix-entry" ix-key="design pattern" markdown="1">design pattern</span>.
Each matcher matches if it can
then asks the next matcher in the chain to try to match the remaining text
(<a class="fig-ref" href="../glob/#glob-chain">Figure&nbsp;4.2</a>).
Crucially,
objects don&rsquo;t know how long the chain after them is:
they just know whom to ask next.</p>
<figure id="glob-chain">
<img src="./chain.svg" alt="Chain of Responsibility"/>
<figcaption>Figure&nbsp;4.2: Matching with Chain of Responsibility.</figcaption>
</figure>

<p>In some cases we only need to know what kind of matching we&rsquo;re doing:
for example, the <code>*</code> pattern matches any characters.
In other cases, though,
we need some extra information,
such as the literal text <code>"abc"</code> or the two alternatives <code>"pdf"</code> and <code>"txt"</code>.
We therefore decide to create matching objects that can hold this extra information
rather than just writing functions.</p>
<p>Our first matcher checks whether a piece of text like <code>"abc"</code>
matches a string.
We call this class <code>Lit</code> because a fixed string of characters
is sometimes called a <a class="gl-ref" href="../glossary/#literal" markdown="1">literal</a>,
and it has a constructor and a <code>match</code> method:</p>
<div class="language-py" title="glob_lit.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Lit</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chars</span> <span class="o">=</span> <span class="n">chars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="o">=</span> <span class="n">rest</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chars</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">end</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue"><code>chars</code> is the characters to be matched,
while <code>rest</code> is responsible for matching the rest of the text.
If <code>rest</code> is <code>None</code>,
this matcher is the last one in the chain,
so it must match to the end of the target string.</p>
<p>The <code>match</code> method takes the text to be matched as an input
along with an optional <code>start</code> parameter
that indicates where matching is to start.
This parameter has a default value of 0
(meaning &ldquo;start at the beginning&rdquo;),
but if this <code>Lit</code> follows other matchers,
they need to tell it where to start looking.
To see if this works,
let&rsquo;s write and run a few tests:</p>
<div class="language-py" title="test_glob_lit.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_literal_match_entire_string</span><span class="p">():</span>
    <span class="c1"># /abc/ matches &quot;abc&quot;</span>
    <span class="k">assert</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_literal_substring_alone_no_match</span><span class="p">():</span>
    <span class="c1"># /ab/ doesn&#39;t match &quot;abc&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_literal_superstring_no_match</span><span class="p">():</span>
    <span class="c1"># /abc/ doesn&#39;t match &quot;ab&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">Notice that we give tests long, meaningful names
to make failure reports from the test runner easier to read.</p>
<p>We could go ahead and build some more matchers right away,
but as <span class="bib-ref">[<a class="bib-ref" href="../bib/#Petre2016">Petre2016</a>]</span> explains,
good programmers build and check
the parts of their code that they are <em>least</em> sure of
as early as possible
to find out if their entire design is going to work or not.
We therefore write a test to make sure that chaining works
when one literal matcher is followed by another:</p>
<div class="language-py" title="test_glob_lit.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_literal_followed_by_literal_match</span><span class="p">():</span>
    <span class="c1"># /a/+/b/ matches &quot;ab&quot;</span>
    <span class="k">assert</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_literal_followed_by_literal_no_match</span><span class="p">():</span>
    <span class="c1"># /a/+/b/ doesn&#39;t match &quot;ac&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;ac&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Chaining two literal matchers together is unnecessary:
we could (and probably should) write <code>Lit("ab")</code> instead of <code>Lit("a", Lit("b"))</code>.
However,
the fact that these two tests pass reassures us that our design is working.</p>
<div class="callout">
<h3>Test-Driven Development</h3>
<p>Some programmers write the tests for a piece of code before writing the code itself.
This practice is called <a class="gl-ref" href="../glossary/#tdd" markdown="1">test-driven development</a>,
and its advocates claim that it yields better code in less time
because (a) writing tests helps people think about what the code should do
before they&rsquo;re committed to a particular implementation
and (b) if people write tests first,
they&rsquo;ll actually write tests.
However,
research shows that the order in which the tests are written doesn&rsquo;t actually make a difference <span class="bib-ref">[<a class="bib-ref" href="../bib/#Fucci2016">Fucci2016</a>]</span>;
what actually matters is alternating short bursts of testing and coding.</p>
</div>
<p>These tests for <code>Lit</code> pass,
so we&rsquo;re ready to move on to wildcards.
A <code>*</code> character in our pattern matches zero or more characters,
so if there are no more matchers in the chain,
then this <code>*</code> matches to the end of the target string
and <code>match</code> returns <code>True</code> right away.
If there <em>are</em> other matchers,
on the other hand,
we try matching no characters, one character, two characters, and so on
and see if those other matchers can get us to the end of the string if we do so.
If none of these possibilities succeeds,
the overall match fails
(<a class="fig-ref" href="../glob/#glob-any">Figure&nbsp;4.3</a>).</p>
<div class="pagebreak"></div>
<figure id="glob-any">
<img src="./any.svg" alt="Wildcard matching"/>
<figcaption>Figure&nbsp;4.3: How wildcard matching works.</figcaption>
</figure>

<div class="language-py" title="glob_any.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Any</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="o">=</span> <span class="n">rest</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
</div>
<p class="continue">Once again we write a few tests before moving on:</p>
<div class="language-py" title="test_glob_any.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_any_matches_empty</span><span class="p">():</span>
    <span class="c1"># /*/ matches &quot;&quot;</span>
    <span class="k">assert</span> <span class="n">Any</span><span class="p">()</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_any_matches_entire_string</span><span class="p">():</span>
    <span class="c1"># /*/ matches &quot;abc&quot;</span>
    <span class="k">assert</span> <span class="n">Any</span><span class="p">()</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_any_matches_as_prefix</span><span class="p">():</span>
    <span class="c1"># /*def/ matches &quot;abcdef&quot;</span>
    <span class="k">assert</span> <span class="n">Any</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;def&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_any_matches_as_suffix</span><span class="p">():</span>
    <span class="c1"># /abc*/ matches &quot;abcdef&quot;</span>
    <span class="k">assert</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">,</span> <span class="n">Any</span><span class="p">())</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_any_matches_interior</span><span class="p">():</span>
    <span class="c1"># /a*c/ matches &quot;abc&quot;</span>
    <span class="k">assert</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Any</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Either/or matching works much the same way.
If the first alternative matches,
we try the rest of the chain.
If not,
we try the second alternative,
and if that doesn&rsquo;t work either,
we fail:</p>
<div class="language-py" title="glob_either.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Either</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="o">=</span> <span class="n">rest</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="pagebreak"></div>

<p>Our first few tests pass:</p>
<div class="language-py" title="test_glob_either.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_either_two_literals_first</span><span class="p">():</span>
    <span class="c1"># /{a,b}/ matches &quot;a&quot;</span>
    <span class="k">assert</span> <span class="n">Either</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_either_two_literals_not_both</span><span class="p">():</span>
    <span class="c1"># /{a,b}/ doesn&#39;t match &quot;ab&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">Either</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">but further testing uncovers a bug:</p>
<div class="language-py" title="test_glob_problem.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_either_followed_by_literal_match</span><span class="p">():</span>
    <span class="c1"># /{a,b}c/ matches &quot;ac&quot;</span>
    <span class="k">assert</span> <span class="n">Either</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;ac&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_either_followed_by_literal_no_match</span><span class="p">():</span>
    <span class="c1"># /{a,b}c/ doesn&#39;t match &quot;ax&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">Either</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;ax&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="language-out" title="test_glob_problem.out">
<div class="highlight"><pre><span></span><code>======================= test session starts ========================

test_glob_problem.py F.                                      [100%]

===================== short test summary info ======================
FAILED test_glob_problem.py::test_either_followed_by_literal_match
=================== 1 failed, 1 passed in 0.00s ====================
</code></pre></div>
</div>
<p>The problem is that <code>Either.match</code> isn&rsquo;t using <code>rest</code> properly—in fact,
it&rsquo;s not using <code>rest</code> at all
because it doesn&rsquo;t know what to pass it as a starting point.
Instead of having <code>match</code> methods return <code>True</code> or <code>False</code>,
we need them to return an indication of where the next match should start
so that <code>Either</code> can pass that information along to <code>rest</code>.
Before making this change,
we will clear up a bit of <a class="gl-ref" href="../glossary/#technical_debt" markdown="1">technical debt</a> in our code.</p>
<h2 id="glob-rethink">Rethinking</h2>
<p>We now have three matchers with the same interfaces.
Before we do any further work,
we will <a class="gl-ref" href="../glossary/#refactor" markdown="1">refactor</a>
using a pattern called <a class="gl-ref" href="../glossary/#extract_parent_class_refactoring" markdown="1">Extract Parent Class</a>
to make the relationship between the matchers clear (<a class="fig-ref" href="../glob/#glob-refactoring">Figure&nbsp;4.4</a>).
At the same time,
each matcher is checking to see if its <code>rest</code> is <code>None</code>.
We can simplify this by creating a class to represent &ldquo;nothing here&rdquo;,
which is known as the <a class="gl-ref" href="../glossary/#null_object_pattern" markdown="1">Null Object</a> pattern.</p>
<figure id="glob-refactoring">
<img src="./refactoring.svg" alt="Refactoring matchers"/>
<figcaption>Figure&nbsp;4.4: Using the Extract Parent Class refactoring.</figcaption>
</figure>

<div class="callout">
<h3>We Didn&rsquo;t Invent This</h3>
<p>We didn&rsquo;t invent any of the patterns or refactorings used in this chapter.
Instead, we learned them from books like <span class="bib-ref">[<a class="bib-ref" href="../bib/#Gamma1994">Gamma1994</a>, <a class="bib-ref" href="../bib/#Fowler2018">Fowler2018</a>, <a class="bib-ref" href="../bib/#Kerievsky2004">Kerievsky2004</a>]</span>.
And as <span class="bib-ref">[<a class="bib-ref" href="../bib/#Tichy2010">Tichy2010</a>]</span> showed,
learning these patterns makes people better programmers.</p>
</div>
<div class="pagebreak"></div>

<p>Our new parent class <code>Match</code> looks like this:</p>
<div class="language-py" title="glob_null.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Match</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="o">=</span> <span class="n">rest</span> <span class="k">if</span> <span class="n">rest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">Null</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue"><code>Match.rest</code> requires every <a class="gl-ref" href="../glossary/#child_class" markdown="1">child class</a> to have
a <a class="gl-ref" href="../glossary/#helper_method" markdown="1">helper method</a> called <code>_match</code>
that returns the location from which searching is to continue.
<code>Match.match</code> checks whether the entire match reaches the end of the target string
and returns <code>True</code> or <code>False</code> as appropriate.</p>
<p>Our new Null Object class looks like this:</p>
<div class="language-py" title="glob_null.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Null</span><span class="p">(</span><span class="n">Match</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">start</span>
</code></pre></div>
</div>
<p class="continue"><code>Null</code> objects must be at the end of the matching chain,
i.e.,
their <code>rest</code> <em>must</em> be <code>None</code>,
so we remove the <code>rest</code> parameter from the class&rsquo;s constructor
and pass <code>None</code> up to the parent constructor every time.
Since <code>Null</code> objects don&rsquo;t match anything,
<code>Null._match</code> immediately returns whatever starting point it was given.
Every other matcher can now pass responsibility down the chain
without having to test whether it&rsquo;s the last matcher in line or not.</p>
<p>With these changes in place,
our literal matcher becomes:</p>
<div class="language-py" title="glob_null.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Lit</span><span class="p">(</span><span class="n">Match</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chars</span> <span class="o">=</span> <span class="n">chars</span>

    <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chars</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue"><code>Lit</code>&rsquo;s constructor calls the constructor of its parent class
to initialize the things that all classes share,
then adds the data specific to this class.
It returns <code>None</code> for &ldquo;no match&rdquo; or whatever <code>self.rest</code> returns
If this object&rsquo;s <code>rest</code> is an instance of <code>Null</code>,
this result will be the index after the overall match.</p>
<p>As before,
the matcher for <code>*</code> checks what happens
if it matches an ever-larger part of the target string:</p>
<div class="language-py" title="glob_null.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Any</span><span class="p">(</span><span class="n">Match</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">end</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
</div>
<p class="continue">(The exercises will ask why loop has to run to <code>len(text) + 1</code>.)
Finally,
the either/or matcher that prompted this refactoring becomes:</p>
<div class="language-py" title="glob_null.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Either</span><span class="p">(</span><span class="n">Match</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">pat</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">]:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">end</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
</div>
<p class="continue">Looping over the left and right alternative
saves us from repeating code or introducing a helper method.
It also simplifies the handling of more than two options,
which we explore in the exercises.</p>
<p>Crucially,
none of the existing tests change
because none of the matching classes&rsquo; constructors changed
and the <a class="gl-ref" href="../glossary/#signature" markdown="1">signature</a> of the <code>match</code> method
(which they now <a class="gl-ref" href="../glossary/#inheritance" markdown="1">inherit</a> from the generic <code>Match</code> class)
stayed the same as well.
We should add some tests for <code>Null</code>,
but we have now met our original goal,
and as the exercises will show we can easily add matchers for other kinds of patterns.</p>
<h2 id="glob-summary">Summary</h2>
<p><a class="fig-ref" href="../glob/#glob-concept-map">Figure&nbsp;4.5</a> summarizes the key ideas in this chapter;
we will see the Null Object and Chain of Responsibility design patterns again.</p>
<figure id="glob-concept-map" class="here">
<img src="./concept_map.svg" alt="Concept map for regular expression matching"/>
<figcaption>Figure&nbsp;4.5: Regular expression matching concept map.</figcaption>
</figure>

<h2 id="glob-exercises">Exercises</h2>
<h3 class="exercise">Looping</h3>
<p>Rewrite the matchers so that a top-level object manages a list of matchers,
none of which know about any of the others.
Is this design simpler or more complicated than the Chain of Responsibility design?</p>
<h3 class="exercise">Length Plus One</h3>
<p>Why does the upper bound of the loop in the final version of <code>Any</code>
run to <code>len(text) + 1</code>?</p>
<h3 class="exercise">Find One or More</h3>
<p>Extend the regular expression matcher to support <code>+</code>,
meaning &ldquo;match one or more characters&rdquo;.</p>
<h3 class="exercise">Match Sets of Characters</h3>
<ol>
<li>
<p>Add a new matching class that matches any character from a set,
    so that <code>Charset('aeiou')</code> matches any lower-case vowel.</p>
</li>
<li>
<p>Create a matcher that matches a range of characters.
    For example,
    <code>Range("a", "z")</code> matches any single lower-case Latin alphabetic character.
    (This is just a convenience matcher: ranges can always be spelled out in full.)</p>
</li>
<li>
<p>Write some tests for your matchers.</p>
</li>
</ol>
<h3 class="exercise">Exclusion</h3>
<ol>
<li>
<p>Create a matcher that <em>doesn&rsquo;t</em> match a specified pattern.
    For example, <code>Not(Lit("abc"))</code> only succeeds if the text isn&rsquo;t &ldquo;abc&rdquo;.</p>
</li>
<li>
<p>Write some tests for it.</p>
</li>
</ol>
<h3 class="exercise">Make Repetition More Efficient</h3>
<p>Rewrite <code>Any</code> so that it does not repeatedly re-match text.</p>
<h3 class="exercise">Multiple Alternatives</h3>
<ol>
<li>
<p>Modify <code>Either</code> so that it can match any number of sub-patterns, not just two.</p>
</li>
<li>
<p>Write some tests for it.</p>
</li>
<li>
<p>What does your implementation do when no sub-patterns are specified?</p>
</li>
</ol>
<h3 class="exercise">Returning Matches</h3>
<p>Modify the matcher so that it returns the substrings that matched
each part of the expression.
For example,
when <code>*.txt</code> matches <code>name.txt</code>,
the library should return some indication that <code>*</code> matched the string <code>"name"</code>.</p>
<h3 class="exercise">Alternative Matching</h3>
<p>The tool we have built implements <a class="gl-ref" href="../glossary/#lazy_matching" markdown="1">lazy matching</a>,
i.e.,
the <code>*</code> character matches the shortest string it can
that results in the overall pattern matching.
Modify the code to do <a class="gl-ref" href="../glossary/#greedy_matching" markdown="1">greedy matching</a> instead,
and combine it with the solution to the previous exercise
for testing.</p>
	</main>
	<footer>
  © 2024 <a href="https://third-bit.com/">Greg Wilson</a>
  &middot;
  <a href="../">home</a>
  &middot;
  <a href="https://github.com/gvwilson/sdxpy">repository</a>
  &middot;
  <a href="../license/">license</a>
</footer>

      </div>
    </div>
  </body>
</html>
