<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="repo" content="https://github.com/gvwilson/sd4ds">
  <meta name="build_date" content="2023-06-21">
  <meta name="template" content="default">
  <meta name="major" content="Chapter 3">
  <meta name="has_slides" content="true">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design for Data Scientists: Matching Patterns</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <img src="../logo.svg" alt="site logo" class="logo" />
  <a href="../">Software Design for Data Scientists</a>
  
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../intro/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../dup/">
      Finding Duplicate Files
    </a>
  </li>
  
  <li>
    <a href="../glob/">
      <strong>Matching Patterns</strong>
    </a>
  </li>
  
  <li>
    <a href="../parse/">
      Parsing Text
    </a>
  </li>
  
  <li>
    <a href="../test/">
      A Test Runner
    </a>
  </li>
  
  <li>
    <a href="../interp/">
      An Interpreter
    </a>
  </li>
  
  <li>
    <a href="../func/">
      Functions and Closures
    </a>
  </li>
  
  <li>
    <a href="../mock/">
      Mocks, Protocols, and Decorators
    </a>
  </li>
  
  <li>
    <a href="../archive/">
      A File Archiver
    </a>
  </li>
  
  <li>
    <a href="../oop/">
      Objects and Classes
    </a>
  </li>
  
  <li>
    <a href="../check/">
      An HTML Validator
    </a>
  </li>
  
  <li>
    <a href="../template/">
      A Template Expander
    </a>
  </li>
  
  <li>
    <a href="../lint/">
      A Code Linter
    </a>
  </li>
  
  <li>
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li>
    <a href="../perf/">
      Performance Profiling
    </a>
  </li>
  
  <li>
    <a href="../persist/">
      Object Persistence
    </a>
  </li>
  
  <li>
    <a href="../binary/">
      Binary Data
    </a>
  </li>
  
  <li>
    <a href="../db/">
      A Database
    </a>
  </li>
  
  <li>
    <a href="../build/">
      A Build Manager
    </a>
  </li>
  
  <li>
    <a href="../pack/">
      A Package Manager
    </a>
  </li>
  
  <li>
    <a href="../ftp/">
      Transferring Files
    </a>
  </li>
  
  <li>
    <a href="../http/">
      Serving Web Pages
    </a>
  </li>
  
  <li>
    <a href="../viewer/">
      A File Viewer
    </a>
  </li>
  
  <li>
    <a href="../undo/">
      Undo and Redo
    </a>
  </li>
  
  <li>
    <a href="../vm/">
      A Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      A Debugger
    </a>
  </li>
  
  <li>
    <a href="../finale/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../bib/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../bonus/">
      Bonus Material
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../slides/">
      Slides
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contrib/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../credits/">
      Credits
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

<p><a href="../sd4ds-examples.zip" type="application/zip">download examples</a></p>


      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 3: Matching Patterns</h1>


          
<div class="draft notex">
  <p>DRAFT</p>
  <p>
    <em>Please use section heading links to submit feedback.</em>
  </p>
</div>


          
  

  
  <ul class="syllabus">
  
  <li markdown="1">Use globs and regular expressions to match patterns in text.</li>
  
  <li markdown="1">Use inheritance to make matchers composable and extensible.</li>
  
  <li markdown="1">Simplify code by having objects delegate work to other objects.</li>
  
  </ul>
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  


          
<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#chain_of_responsibility_pattern" markdown="1">Chain of Responsibility pattern</a>, <a class="gl-ref" href="../glossary/#extract_parent_class_refactoring" markdown="1">Extract Parent Class refactoring</a>, <a class="gl-ref" href="../glossary/#globbing" markdown="1">globbing</a>, <a class="gl-ref" href="../glossary/#greedy_matching" markdown="1">greedy matching</a>, <a class="gl-ref" href="../glossary/#helper_method" markdown="1">helper method</a>, <a class="gl-ref" href="../glossary/#inheritance" markdown="1">inheritance</a>, <a class="gl-ref" href="../glossary/#lazy_matching" markdown="1">lazy matching</a>, <a class="gl-ref" href="../glossary/#null_object_pattern" markdown="1">Null Object pattern</a>, <a class="gl-ref" href="../glossary/#refactor" markdown="1">refactor</a>, <a class="gl-ref" href="../glossary/#regular_expression" markdown="1">regular expression</a>, <a class="gl-ref" href="../glossary/#signature" markdown="1">signature</a>, <a class="gl-ref" href="../glossary/#technical_debt" markdown="1">technical debt</a>, <a class="gl-ref" href="../glossary/#tdd" markdown="1">test-driven development</a>
</p>


          <div class="page-toc"></div>
          <p>We had to tell the duplicate file finder of <a class="x-ref" href="../dup/">Chapter 2</a> which files to compare.
It would be more useful if it could find files itself,
and more useful still if we could tell it to check
files whose names matched patterns like <code>*.png</code>.</p>
<p>Early versions of Unix had a tool called <a href="https://en.wikipedia.org/wiki/Glob_(programming)"><code>glob</code></a> to do this.
The name was short for &ldquo;global&rdquo;,
and older programmers (like this author)
still use the word <a class="gl-ref" href="../glossary/#globbing" markdown="1">globbing</a>
to mean &ldquo;matching filenames against a pattern&rdquo;.
The Python standard library includes a module called <a href="https://docs.python.org/3/library/glob.html"><code>glob</code></a>
to match filenames in the same way.
For example,
<code>2023-*.{pdf,txt}</code> matches <code>2023-01.txt</code> and <code>2023-final.pdf</code> but not <code>draft-2023.docx</code>
(<a class="fig-ref" href="../glob/#glob-examples">Figure 3.1</a>).
In this chapter,
we will implement a simple version of globbing
to show how pattern matching works in general.</p>
<figure id="glob-examples">
<img src="./examples.svg" alt="Matching examples"/>
<figcaption markdown="1">Figure 3.1: Examples of glob matching.</figcaption>
</figure>

<h2 id="glob-simple">Section 3.1: Simple Patterns</h2>
<p>Globbing patterns are simpler than
the <a class="gl-ref" href="../glossary/#regular_expression" markdown="1">regular expressions</a>
used to scrape data from text files.
Our matcher will handle only the cases shown in
<a class="tbl-ref" href="../glob/#pattern-glob-cases">Table 3.1</a>.</p>
<div class="table"><table id="pattern-glob-cases"><caption>Table 3.1: Pattern matching cases</caption>
<thead>
<tr>
<th>Pattern</th>
<th>Text</th>
<th>Match?</th>
<th></th>
<th>Pattern</th>
<th>Text</th>
<th>Match?</th>
</tr>
</thead>
<tbody>
<tr>
<td>abc</td>
<td>&ldquo;abc&rdquo;</td>
<td>True</td>
<td></td>
<td>a*c</td>
<td>&ldquo;abc&rdquo;</td>
<td>True</td>
</tr>
<tr>
<td>ab</td>
<td>&ldquo;abc&rdquo;</td>
<td>False</td>
<td></td>
<td>{a,b}</td>
<td>&ldquo;a&rdquo;</td>
<td>True</td>
</tr>
<tr>
<td>abc</td>
<td>&ldquo;ab&rdquo;</td>
<td>False</td>
<td></td>
<td>{a,b}</td>
<td>&ldquo;c&rdquo;</td>
<td>False</td>
</tr>
<tr>
<td>*</td>
<td>&rdquo;&ldquo;</td>
<td>True</td>
<td></td>
<td>{a,b}</td>
<td>&ldquo;ab&rdquo;</td>
<td>False</td>
</tr>
<tr>
<td>*</td>
<td>&ldquo;abc&rdquo;</td>
<td>True</td>
<td></td>
<td>*{x,y}</td>
<td>&ldquo;abcx&rdquo;</td>
<td>True</td>
</tr>
</tbody>
</table>
</div>
<p>Matching is conceptually simple.
If the first element of the pattern
matches the target string at the current location,
we check if the rest of the pattern matches what&rsquo;s left of the string.
If it doesn&rsquo;t,
or if we don&rsquo;t get to the end of the string,
matching fails.
(This behavior makes globbing different from regular expressions,
which can match parts of strings.)</p>
<p>In some cases all we need is the type of match:
for example, the <code>*</code> pattern matches any characters.
In other cases, though,
we need some extra information,
such as the literal text <code>"abc"</code> or the two alternatives <code>"x"</code> and <code>"y"</code>.
We will therefore create objects to do matching
rather than using bare functions.</p>
<p>Our design uses
the <a class="gl-ref" href="../glossary/#chain_of_responsibility_pattern" markdown="1">Chain of Responsibility</a> pattern.
Each object matches if it can,
then delegates the rest of the match to the next object in the chain
(<a class="fig-ref" href="../glob/#glob-chain">Figure 3.2</a>).</p>
<figure id="glob-chain">
<img src="./chain.svg" alt="Chain of Responsibility"/>
<figcaption markdown="1">Figure 3.2: Matching with Chain of Responsibility.</figcaption>
</figure>

<p>Our first matcher checks whether a fixed piece of text like <code>"abc"</code>
matches a string:</p>
<div class="code-sample lang-py" title="glob_lit.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Lit</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chars</span> <span class="o">=</span> <span class="n">chars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="o">=</span> <span class="n">rest</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chars</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">end</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</code></pre></div>
</div>
<p><code>chars</code> is the characters to be matched,
while <code>rest</code> is the chain responsible for matching the rest of the text.
If <code>rest</code> is <code>None</code>,
this matcher is the last one in the chain,
so it must match to the end of the target string.
Finally,
<code>start</code> is needed when this matcher isn&rsquo;t the first one in the chain.</p>
<p>Before building our second matcher,
let&rsquo;s write and run a few tests for this one:</p>
<div class="code-sample lang-py" title="test_glob_lit.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_literal_match_entire_string</span><span class="p">():</span>
    <span class="c1"># /abc/ matches &quot;abc&quot;</span>
    <span class="k">assert</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_literal_substring_alone_no_match</span><span class="p">():</span>
    <span class="c1"># /ab/ doesn&#39;t match &quot;abc&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_literal_superstring_no_match</span><span class="p">():</span>
    <span class="c1"># /abc/ doesn&#39;t match &quot;ab&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">Notice that we give tests long names
so that failure reports from the test runner are easier to read.</p>
<p>We could go ahead and build some more matchers right away,
but as <span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Petre2016">Petre2016</a>]</span> explains,
good programmers build and check
the parts of their code that they are <em>least</em> sure of
as early as possible
to find out if their entire design is going to work or not.
We therefore write a test to make sure that chaining works
when one literal matcher is followed by another:</p>
<div class="code-sample lang-py" title="test_glob_lit.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_literal_followed_by_literal_match</span><span class="p">():</span>
    <span class="c1"># /a/+/b/ matches &quot;ab&quot;</span>
    <span class="k">assert</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_literal_followed_by_literal_no_match</span><span class="p">():</span>
    <span class="c1"># /a/+/b/ doesn&#39;t match &quot;ac&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;ac&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="callout">
<h2>Test-Driven Development</h2>
<p>Some programmers write the tests for a piece of code before writing the code itself.
This practice is called <a class="gl-ref" href="../glossary/#tdd" markdown="1">test-driven development</a>,
and its advocates claim that it produces better code in less time
because (a) writing tests helps people think about what the code should do
before they&rsquo;re committed to a particular implementation
and (b) if people write tests first,
they&rsquo;ll actually write tests.
Research shows that the order doesn&rsquo;t actually make a difference <span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Fucci2016">Fucci2016</a>]</span>;
what does is alternating in short bursts between testing and coding.</p>
</div>
<p>These tests pass,
so we&rsquo;re ready to move on to wildcards.
A <code>*</code> character in our pattern matches zero or more characters,
so if there are no more matchers in the chain,
then this <code>*</code> matches to the end of the target string
and <code>match</code> returns <code>True</code> right away.
If there <em>are</em> other matchers,
on the other hand,
we try matching no characters, one character, two characters, and so on
and see if those other matchers can get us to the end of the string if we do so.
If nothing works,
the match fails:</p>
<div class="code-sample lang-py" title="glob_any.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Any</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="o">=</span> <span class="n">rest</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
</div>
<div class="code-sample lang-py" title="test_glob_any.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_any_matches_empty</span><span class="p">():</span>
    <span class="c1"># /*/ matches &quot;&quot;</span>
    <span class="k">assert</span> <span class="n">Any</span><span class="p">()</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_any_matches_entire_string</span><span class="p">():</span>
    <span class="c1"># /*/ matches &quot;abc&quot;</span>
    <span class="k">assert</span> <span class="n">Any</span><span class="p">()</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_any_matches_as_prefix</span><span class="p">():</span>
    <span class="c1"># /*def/ matches &quot;abcdef&quot;</span>
    <span class="k">assert</span> <span class="n">Any</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;def&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_any_matches_as_suffix</span><span class="p">():</span>
    <span class="c1"># /abc*/ matches &quot;abcdef&quot;</span>
    <span class="k">assert</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">,</span> <span class="n">Any</span><span class="p">())</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;abcdef&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_any_matches_interior</span><span class="p">():</span>
    <span class="c1"># /a*c/ matches &quot;abc&quot;</span>
    <span class="k">assert</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">Any</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Either/or matching works much the same way.
If the first alternative matches we try the rest of the chain.
If not,
we try the second alternative,
and if neither gives us a match,
we fail:</p>
<div class="code-sample lang-py" title="glob_either.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Either</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="o">=</span> <span class="n">rest</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-py" title="test_glob_either.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_either_two_literals_first</span><span class="p">():</span>
    <span class="c1"># /{a,b}/ matches &quot;a&quot;</span>
    <span class="k">assert</span> <span class="n">Either</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_either_two_literals_second</span><span class="p">():</span>
    <span class="c1"># /{a,b}/ matches &quot;b&quot;</span>
    <span class="k">assert</span> <span class="n">Either</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_either_two_literals_neither</span><span class="p">():</span>
    <span class="c1"># /{a,b}/ doesn&#39;t match &quot;c&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">Either</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_either_two_literals_not_both</span><span class="p">():</span>
    <span class="c1"># /{a,b}/ doesn&#39;t match &quot;ab&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">Either</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;ab&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_either_after_any</span><span class="p">():</span>
    <span class="c1"># /*{x,y}/ matches &quot;abcx&quot;</span>
    <span class="k">assert</span> <span class="n">Any</span><span class="p">(</span><span class="n">Either</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)))</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;abcx&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p>But further testing uncovers a bug:</p>
<div class="code-sample lang-py" title="test_glob_problem.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_either_followed_by_literal_match</span><span class="p">():</span>
    <span class="c1"># /{a,b}c/ matches &quot;ac&quot;</span>
    <span class="k">assert</span> <span class="n">Either</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">test_either_followed_by_literal_no_match</span><span class="p">():</span>
    <span class="c1"># /{a,b}c/ doesn&#39;t match &quot;ax&quot;</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">Either</span><span class="p">(</span><span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="n">Lit</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="test_glob_problem.out">
<div class="highlight"><pre><span></span><code>======================= test session starts ========================

test_glob_problem.py .F                                      [100%]

===================== short test summary info ======================
FAILED test_glob_problem.py::test_either_followed_by_literal_no_match
=================== 1 failed, 1 passed in 0.01s ====================
</code></pre></div>
</div>
<p>Our <code>Either</code> matcher doesn&rsquo;t handle <code>rest</code> properly.
We can try to patch it using our current design,
but we&rsquo;ve accumulated a bit of <a class="gl-ref" href="../glossary/#technical_debt" markdown="1">technical debt</a>
that we should clear up.</p>
<h2 id="glob-rethink">Section 3.3: Rethinking</h2>
<p>We now have three matchers with the same interfaces.
Before we do any further work,
we will <a class="gl-ref" href="../glossary/#refactor" markdown="1">refactor</a>
using <a class="gl-ref" href="../glossary/#extract_parent_class_refactoring" markdown="1">Extract Parent Class</a>
to eliminate duplicated code (<a class="fig-ref" href="../glob/#glob-refactoring">Figure 3.3</a>).
Similarly,
the test <code>if self.rest is None</code> appears several times.
We can simplify this by creating a class to represent &ldquo;nothing here&rdquo;,
which is known as the <a class="gl-ref" href="../glossary/#null_object_pattern" markdown="1">Null Object</a> pattern.</p>
<figure id="glob-refactoring">
<img src="./refactoring.svg" alt="Refactoring matchers"/>
<figcaption markdown="1">Figure 3.3: Using the Extract Parent Class refactoring.</figcaption>
</figure>

<div class="callout">
<h2>We Didn&rsquo;t Invent This</h2>
<p>We didn&rsquo;t invent any of the patterns or refactorings used in this chapter.
Instead, we learned them from books like <span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Gamma1994,Fowler2018,Kerievsky2004">Gamma1994,Fowler2018,Kerievsky2004</a>]</span>.
And as <span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Tichy2010">Tichy2010</a>]</span> showed,
learning these patterns makes people better programmers.</p>
</div>
<p>Our new parent class <code>Match</code> looks like this:</p>
<div class="code-sample lang-py" title="glob_null.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Match</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="o">=</span> <span class="n">rest</span> <span class="k">if</span> <span class="n">rest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">Null</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</code></pre></div>
</div>
<p>It assumes every child class has a <code>_match</code> method
that returns the location from which searching is to continue
rather than just <code>True</code> or <code>False</code>.
<code>Match.match</code> therefore checks that we&rsquo;ve reached the end of the text.</p>
<p>The Null Object class is:</p>
<div class="code-sample lang-py" title="glob_null.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Null</span><span class="p">(</span><span class="n">Match</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rest</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">start</span>
</code></pre></div>
</div>
<p class="continue">The null object must be the last one in the chain,
and as advertised,
it doesn&rsquo;t advance the match (i.e., it does nothing).
Every other matcher can now pass responsibility down the chain
without having to test whether it&rsquo;s at the end or not.</p>
<p>With these changes in place,
our literal matcher becomes:</p>
<div class="code-sample lang-py" title="glob_null.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Lit</span><span class="p">(</span><span class="n">Match</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chars</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chars</span> <span class="o">=</span> <span class="n">chars</span>

    <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chars</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue"><code>Lit</code>&lsquo;s constructor calls the constructor of its parent class
to initialize the things that all classes share,
then adds the data specific to this class.
It returns <code>None</code> for &ldquo;no match&rdquo; or whatever <code>self.rest</code> returns
If this object&rsquo;s <code>rest</code> is an instance of <code>Null</code>,
this result will be the index after our match.</p>
<p>As before,
the matcher for <code>*</code> checks what happens
if it matches an ever-larger part of the target string:</p>
<div class="code-sample lang-py" title="glob_null.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Any</span><span class="p">(</span><span class="n">Match</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">end</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
</div>
<p class="continue">(The exercises will ask why loop has to run to <code>len(text) + 1</code>.)
Finally,
the matcher for either/or alternatives that initially prompted this refactoring
becomes:</p>
<div class="code-sample lang-py" title="glob_null.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Either</span><span class="p">(</span><span class="n">Match</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">rest</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">pat</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">]:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">pat</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rest</span><span class="o">.</span><span class="n">_match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">end</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
</div>
<p class="continue">Looping over the left and right alternative
saves us from repeating code or introducing a <a class="gl-ref" href="../glossary/#helper_method" markdown="1">helper method</a>.
It also simplifies the handling of more than two options,
which we explore in the exercises.</p>
<p>Crucially,
none of the existing tests change
because none of the matching classes&rsquo; constructors changed
and the <a class="gl-ref" href="../glossary/#signature" markdown="1">signature</a> of the <code>match</code> method
(which they now <a class="gl-ref" href="../glossary/#inheritance" markdown="1">inherit</a> from the generic <code>Match</code> class)
stayed the same as well.
We should (should) add a couple of tests for <code>Null</code>,
but basically we have now met our original goal,
and as the exercises will show,
we can easily add matchers for other kinds of patterns.</p>
<h2 id="glob-summary">Section 3.5: Summary</h2>
<figure id="glob-concept-map">
<img src="./concept_map.svg" alt="Concept map for regular expression matching"/>
<figcaption markdown="1">Figure 3.4: Regular expression matching concept map.</figcaption>
</figure>

<h2 id="glob-exercises">Section 3.6: Exercises</h2>
<h3 class="exercise">Length Plus One</h3>
<p>Why does the upper bound of the loop in the final version of <code>Any</code>
run to <code>len(text) + 1</code>?</p>
<h3 class="exercise">Find One or More</h3>
<p>Extend the regular expression matcher to support <code>+</code>,
meaning &ldquo;match one or more characters&rdquo;.</p>
<h3 class="exercise">Match Sets of Characters</h3>
<ol>
<li>
<p>Add a new matching class that matches any character from a set,
    so that <code>Charset('aeiou')</code> matches any lower-case vowel.</p>
</li>
<li>
<p>Create a matcher that matches a range of characters.
    For example,
    <code>Range("a", "z")</code> matches any single lower-case Latin alphabetic character.
    (This is just a convenience matcher: ranges can always be spelled out in full.)</p>
</li>
<li>
<p>Write some tests for your matchers.</p>
</li>
</ol>
<h3 class="exercise">Make Repetition More Efficient</h3>
<p>Rewrite <code>Any</code> so that it does not repeatedly re-match text.</p>
<h3 class="exercise">Exclusion</h3>
<ol>
<li>
<p>Create a matcher that <em>doesn&rsquo;t</em> match a specified pattern.
    For example, <code>Not(Lit("abc"))</code> only succeeds if the text isn&rsquo;t &ldquo;abc&rdquo;.</p>
</li>
<li>
<p>Write some tests for it.</p>
</li>
</ol>
<h3 class="exercise">Multiple Alternatives</h3>
<ol>
<li>
<p>Modify <code>Either</code> so that it can match any number of sub-patterns, not just two.</p>
</li>
<li>
<p>Write some tests for it.</p>
</li>
<li>
<p>What does your implementation do when no sub-patterns are specified?</p>
</li>
</ol>
<h3 class="exercise">Returning Matches</h3>
<p>Modify the matcher so that it returns the substrings that matched
each part of the expression.
For example,
when <code>*.txt</code> matches <code>name.txt</code>,
the library should return some indication that <code>*</code> matched the string <code>"name"</code>.</p>
<h3 class="exercise">Alternative Matching</h3>
<p>The tool we have built implements <a class="gl-ref" href="../glossary/#lazy_matching" markdown="1">lazy matching</a>,
i.e.,
the <code>*</code> character matches the shortest string it can
that results in the overall pattern matching.
Modify the code to do <a class="gl-ref" href="../glossary/#greedy_matching" markdown="1">greedy matching</a> instead,
and combine it with the solution to the previous exercise
for testing.</p>
        </main>
      </div>
    </div>
  </body>
</html>
