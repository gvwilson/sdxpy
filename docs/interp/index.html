<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="../logo.svg">
<link rel="stylesheet" href="../tango.css" type="text/css">
<link rel="stylesheet" href="../mccole.css" type="text/css">
<title>Software Design by Example &middot; An Interpreter</title>
<script>
  MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)']]
    }
  };
</script>
<script
  type="text/javascript"
  id="MathJax-script"
  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


  </head>
  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <a href="https://www.routledge.com/Software-Design-by-Example-A-Tool-Based-Introduction-with-Python/Wilson/p/book/9781032725215"><img src="../sdxpy-cover.png" alt="Book cover" class="bookcover" /></a>
  
</p>

<div class="screen-reader-only">
  <a href="#printable">Skip to content</a>
</div>

<ol class="toc-chapters"><li><a href="../intro/">Introduction</a></li><li><a href="../oop/">Objects and Classes</a></li><li><a href="../dup/">Finding Duplicate Files</a></li><li><a href="../glob/">Matching Patterns</a></li><li><a href="../parse/">Parsing Text</a></li><li><a href="../test/">Running Tests</a></li><li><a href="../interp/">An Interpreter</a></li><li><a href="../func/">Functions and Closures</a></li><li><a href="../protocols/">Protocols</a></li><li><a href="../archive/">A File Archiver</a></li><li><a href="../check/">An HTML Validator</a></li><li><a href="../template/">A Template Expander</a></li><li><a href="../lint/">A Code Linter</a></li><li><a href="../layout/">Page Layout</a></li><li><a href="../perf/">Performance Profiling</a></li><li><a href="../persist/">Object Persistence</a></li><li><a href="../binary/">Binary Data</a></li><li><a href="../db/">A Database</a></li><li><a href="../build/">A Build Manager</a></li><li><a href="../pack/">A Package Manager</a></li><li><a href="../ftp/">Transferring Files</a></li><li><a href="../http/">Serving Web Pages</a></li><li><a href="../viewer/">A File Viewer</a></li><li><a href="../undo/">Undo and Redo</a></li><li><a href="../vm/">A Virtual Machine</a></li><li><a href="../debugger/">A Debugger</a></li><li><a href="../observe/">Observers</a></li><li><a href="../docgen/">Generating Documentation</a></li><li><a href="../search/">Search</a></li><li><a href="../compress/">File Compression</a></li><li><a href="../cache/">A File Cache</a></li><li><a href="../query/">A Query Builder</a></li><li><a href="../concur/">Concurrency</a></li><li><a href="../finale/">Conclusion</a></li></ol>
<ol class="toc-appendices"><li><a href="../bib/">Bibliography</a></li><li><a href="../bonus/">Bonus Material</a></li><li><a href="../syllabus/">Syllabus</a></li><li><a href="../license/">License</a></li><li><a href="../conduct/">Code of Conduct</a></li><li><a href="../contrib/">Contributing</a></li><li><a href="../glossary/">Glossary</a></li><li><a href="../colophon/">Colophon</a></li><li><a href="../contents/">Index</a></li></ol>


<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


<p><a href="https://github.com/gvwilson/sdxpy">GitHub repository</a></p>

      </div>
      <div id="printable" class="contents bordered">
	<main>
	  <div class="row notex">
  <div class="col-12 center">
    
      <h1>An Interpreter</h1>
    
  </div>
</div>

	  
<nav class="row-always notex">
  <div class="col-1 left">
    <a href="../test/" title="previous" class="undecorated">&#8678;</a>
  </div>
  <div class="col-10 center">
    <a href="../" title="home" class="undecorated">&#9737;</a>
  </div>
  <div class="col-1 right">
    <a href="../func/" title="next" class="undecorated">&#8680;</a>
  </div>
</nav>


	  <ul class="keypoints">
<li>Compilers and interpreters are just programs.</li>
<li>Basic arithmetic operations are just functions that have special notation.</li>
<li>Programs can be represented as trees, which can be stored as nested lists.</li>
<li>Interpreters recursively dispatch operations to functions that implement low-level steps.</li>
<li>Programs store variables in stacked dictionaries called environments.</li>
<li>One way to evaluate a program&rsquo;s design is to ask how extensible it is.</li>
</ul>
	  <p class="terms">Terms defined: 
<a class="gl-ref" href="../glossary/#compiler" markdown="1">compiler</a>, <a class="gl-ref" href="../glossary/#control_flow" markdown="1">control flow</a>, <a class="gl-ref" href="../glossary/#defensive_programming" markdown="1">defensive programming</a>, <a class="gl-ref" href="../glossary/#dictionary_comprehension" markdown="1">dictionary comprehension</a>, <a class="gl-ref" href="../glossary/#dynamic_dispatch" markdown="1">dynamic dispatch</a>, <a class="gl-ref" href="../glossary/#environment" markdown="1">environment</a>, <a class="gl-ref" href="../glossary/#expression" markdown="1">expression</a>, <a class="gl-ref" href="../glossary/#infix_notation" markdown="1">infix notation</a>, <a class="gl-ref" href="../glossary/#interpreter" markdown="1">interpreter</a>, <a class="gl-ref" href="../glossary/#introspection" markdown="1">introspection</a>, <a class="gl-ref" href="../glossary/#prefix_notation" markdown="1">prefix notation</a>, <a class="gl-ref" href="../glossary/#runtime" markdown="1">runtime</a>, <a class="gl-ref" href="../glossary/#statement" markdown="1">statement</a>, <a class="gl-ref" href="../glossary/#type_hint" markdown="1">type hint</a>
</p>
	  <p><a href="../oop/">Chapter&nbsp;2</a> and <a href="../test/">Chapter&nbsp;6</a> introduced the idea that programs are just data.
<a class="gl-ref" href="../glossary/#compiler" markdown="1">Compilers</a> and <a class="gl-ref" href="../glossary/#interpreter" markdown="1">interpreters</a>
are just programs too.
Instead of calculating sums or drawing characters on a screen,
compilers turn text into instructions for interpreters or hardware to run.</p>
<p>Most real programming languages have two parts:
a <span class="ix-entry" ix-key="parser" markdown="1">parser</span> that translates the source code into a data structure,
and a <a class="gl-ref" href="../glossary/#runtime" markdown="1">runtime</a> that executes
the instructions in that data structure.
<a href="../parse/">Chapter&nbsp;5</a> explored parsing;
this chapter will build a runtime for a very simple interpreter,
while <a href="../vm/">Chapter&nbsp;25</a> will look at how we can compile code
so that it runs more efficiently.</p>
<div class="callout">
<h3>Two Ways to Run Code</h3>
<p>A compiler translates a program into runnable instructions
before the program runs,
while an interpreter generates instructions on the fly
as the program is running.
The differences between the two are blurry in practice:
for example,
Python translates the instructions in a program into instructions as it loads files,
but saves those instructions in <code>.pyc</code> files to save itself work
the next time it runs the program.</p>
</div>
<h2 id="interp-expressions">Expressions</h2>
<p>Let&rsquo;s start by building something that can evaluate
simple <a class="gl-ref" href="../glossary/#expression" markdown="1">expressions</a>
such as <code>1+2</code> or <code>abs(-3.5)</code>.
We represent each expression as a list
with the name of the operation as the first item
and the values to be operated on as the other items.
If we have multiple operations,
we use nested lists:</p>
<div class="language-py" title="add_example.py">
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>            <span class="c1"># 1 + 2</span>
<span class="p">[</span><span class="s2">&quot;abs&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.5</span><span class="p">]</span>            <span class="c1"># abs(-3.5)</span>
<span class="p">[</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;abs&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="mi">9</span><span class="p">]</span>  <span class="c1"># abs(-5) + 9</span>
</code></pre></div>
</div>
<div class="callout">
<h3>Notation</h3>
<p>We use <a class="gl-ref" href="../glossary/#infix_notation" markdown="1">infix notation</a> like <code>1+2</code> for historical reasons
in everyday life,
but our interpreter uses <a class="gl-ref" href="../glossary/#prefix_notation" markdown="1">prefix notation</a>—i.e.,
always puts the operations&rsquo; names first—to make the operations easier to find.
Similarly,
we have special symbols for addition, subtraction, and so on for historical reasons,
but our list representation doesn&rsquo;t distinguish between things like <code>+</code> and <code>abs</code>
because it doesn&rsquo;t need to.
If our program is being compiled into low-level instructions for a particular CPU,
it&rsquo;s the compiler&rsquo;s job to decide what can be done directly
and what needs multiple instructions.
For example,
early CPUs didn&rsquo;t have instructions to do division,
while modern CPUs may have instructions to do addition or multiplication
on multiple values at once.</p>
</div>
<p>The function to add two expressions looks like this:</p>
<div class="language-py" title="expr.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">do_add</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span>
</code></pre></div>
</div>
<p class="continue">Its single parameter is a list containing
the two sub-expressions to be evaluated and added.
After checking that this list contains the required number of values,
it calls an as-yet-unwritten function <code>do</code>
to evaluate those sub-expressions.
(We&rsquo;ve called the function <code>do</code> instead of <code>eval</code>
because Python already has a function called <code>eval</code>.)
Once <code>do_add</code> has two actual values,
it adds them and returns the result.</p>
<p><code>do_abs</code> implements absolute values the same way.
The only differences are that it expects one value instead of two
and calculates a different return value:</p>
<div class="language-py" title="expr.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">do_abs</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">Notice that <code>do_abs</code> and <code>do_add</code> have the same <span class="ix-entry" ix-key="signature" markdown="1">signature</span>.
As with the <span class="ix-entry" ix-key="unit test" markdown="1">unit testing</span> functions in <a href="../test/">Chapter&nbsp;6</a>,
this allows us to call them interchangeably.</p>
<p>So how does <code>do</code> work?
It starts by checking if its input is an integer.
If so,
it returns that value right away
because integers &ldquo;evaluate&rdquo; to themselves.
Otherwise,
<code>do</code> checks that its parameter is a list
and then uses the first value in the list
to decide what other function to call.</p>
<div class="language-py" title="expr.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">do</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="c1"># Integers evaluate to themselves.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c1"># Lists trigger function calls.</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;abs&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_abs</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;add&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_add</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unknown operation </span><span class="si">{</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div>
</div>
<div class="pagebreak"></div>

<p>This lookup-and-call process is called <a class="gl-ref" href="../glossary/#dynamic_dispatch" markdown="1">dynamic dispatch</a>,
since the program decides who to give work to on the fly.
It leads to a situation where <code>do</code> calls a function like <code>do_add</code>,
which in turn calls <code>do</code>,
which may then call <code>do_add</code> (or something other function)
and so on (<a class="fig-ref" href="../interp/#interp-recursive-evaluation">Figure&nbsp;7.1</a>).
Having a function call itself either directly or indirectly is called <span class="ix-entry" ix-key="recursion" markdown="1">recursion</span>,
which has a reputation for being hard to understand.
As our interpreter shows,
though,
it&rsquo;s a natural way to solve a wide range of problems:
each recursive step handles a smaller part of the overall problem
until we reach an integer or some other value that doesn&rsquo;t require any further work.</p>
<figure id="interp-recursive-evaluation">
<img src="./recursive_evaluation.svg" alt="Recursive evaluation of an expression tree"/>
<figcaption>Figure&nbsp;7.1: Recursively evaluating the expression <code>['abs',['add',1,2]]</code>.</figcaption>
</figure>

<p>With all of this code in place,
the main body of the program can read
the file containing the instructions to execute,
call <code>do</code>,
and print the result:</p>
<div class="language-py" title="expr.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Usage: expr.py filename&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
        <span class="n">program</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;=&gt; </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div>
</div>
<p>The program we want to interpret is a list of lists of lists,
so we can read it as <span class="ix-entry" ix-key="JSON" markdown="1">JSON</span> using <code>json.load</code>
rather than writing our own parser.
For example,
if our program file contains:</p>
<div class="language-tll" title="expr.tll">
<div class="highlight"><pre><span></span><code>[&quot;add&quot;, [&quot;abs&quot;, -3], 2]
</code></pre></div>
</div>
<p class="continue">then our little interpreter prints:</p>
<div class="language-out" title="expr.out">
<div class="highlight"><pre><span></span><code>=&gt; 5
</code></pre></div>
</div>
<p>This is a lot of code to do something that Python already does,
but it shows what Python (and other languages) do themselves.
When we run:</p>
<div class="language-sh" title="expr.sh">
<div class="highlight"><pre><span></span><code>python<span class="w"> </span>expr.py<span class="w"> </span>expr.tll
</code></pre></div>
</div>
<p>Python reads <code>expr.py</code>,
turns it into a data structure with operation identifiers and constants,
and uses those operation identifiers to decide what functions to call.
The functions inside Python are written in C
and have been compiled to machine instructions,
but the cycle of lookup and call is exactly the same as it is
in our little interpreter.</p>
<h2 id="interp-variables">Variables</h2>
<p>Doing arithmetic on constants is a start,
but our programs will be easier to read
if we can define variables that give names to values.
We can add variables to our interpreter
by passing around a <span class="ix-entry" ix-key="dictionary" markdown="1">dictionary</span>
containing all the variables seen so far.
Such a dictionary is sometimes called an <a class="gl-ref" href="../glossary/#environment" markdown="1">environment</a>
because it is the setting in which expressions are evaluated;
the dictionaries returned by the <code>globals</code> and <code>locals</code> functions
introduced in <a href="../test/">Chapter&nbsp;6</a> are both environments.</p>
<p>Let&rsquo;s modify <code>do_add</code>, <code>do_abs</code>, <code>do</code>, and <code>main</code>
to take an environment as an extra parameter and pass it on as needed:</p>
<div class="language-py" title="vars.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">do_abs</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Looking up variables when we need their values is straightforward.
We check that we have a variable name and that the name is in the environment,
then return the stored value:</p>
<div class="language-py" title="vars.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">do_get</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">env</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unknown variable </span><span class="si">{</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">env</span><span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
</code></pre></div>
</div>
<p>To define a new variable or change an existing one,
we evaluate an expression and store its value in the environment:</p>
<div class="language-py" title="vars.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">do_set</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">env</span><span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">value</span>
</code></pre></div>
</div>
<p>We need to add one more function to make this all work.
Our programs no longer consist of a single expression;
instead,
we may have several expressions that set variables&rsquo; values
and then use them in calculations.
To handle this,
we add a function <code>do_seq</code> that runs a sequence of expressions one by one.
This function is our first piece of <a class="gl-ref" href="../glossary/#control_flow" markdown="1">control flow</a>:
rather than calculating a value itself,
it controls when and how other expressions are evaluated.
Its implementation is:</p>
<div class="language-py" title="vars.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">do_seq</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
</div>
<p>Let&rsquo;s try it out.
Our test program is:</p>
<div class="language-tll" title="vars.tll">
<div class="highlight"><pre><span></span><code>[
    &quot;seq&quot;,
    [&quot;set&quot;, &quot;alpha&quot;, 1],
    [&quot;set&quot;, &quot;beta&quot;, 2],
    [&quot;add&quot;, [&quot;get&quot;, &quot;alpha&quot;], [&quot;get&quot;, &quot;beta&quot;]]
]
</code></pre></div>
</div>
<div class="language-out" title="vars.out">
<div class="highlight"><pre><span></span><code>=&gt; 3
</code></pre></div>
</div>
<div class="callout">
<h3>Everything Is An Expression</h3>
<p>As we said above,
Python distinguishes expressions that produce values
from <a class="gl-ref" href="../glossary/#statement" markdown="1">statements</a> that don&rsquo;t.
But it doesn&rsquo;t have to, and many languages don&rsquo;t.
For example,
Python could have been designed to allow this:</p>
<div class="language-py" title="ex_assign_expr.py">
<div class="highlight"><pre><span></span><code><span class="c1"># not actually legal Python</span>
<span class="n">result</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
</div>
</div>
<h2 id="interp-introspection">Introspection</h2>
<p>Now that we have evaluation, function lookup, and environments,
we can write small programs.
However,
our <code>do</code> function now looks like this:</p>
<div class="language-py" title="vars.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">do</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;abs&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_abs</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;add&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_add</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;get&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_get</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;seq&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_seq</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;set&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_set</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unknown operation </span><span class="si">{</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div>
</div>
<p>The sequence of <code>if</code> statements that decide what function to call
is becoming unwieldy.
(Quick:
can you see if any of the instruction names are accidentally duplicated?)
We can replace this by using <a class="gl-ref" href="../glossary/#introspection" markdown="1">introspection</a>
to create a lookup table
that stores every function whose name starts with <code>do_</code>
(<a class="fig-ref" href="../interp/#interp-lookup">Figure&nbsp;7.2</a>):</p>
<div class="language-py" title="vars_reflect.py">
<div class="highlight"><pre><span></span><code><span class="n">OPS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;do_&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">):</span> <span class="n">func</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;do_&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
</div>
<figure id="interp-lookup">
<img src="./lookup.svg" alt="Function lookup table"/>
<figcaption>Figure&nbsp;7.2: Dynamically-generated function lookup table.</figcaption>
</figure>

<div class="pagebreak"></div>

<p>Line by line:</p>
<ol>
<li>
<p>We use a <a class="gl-ref" href="../glossary/#dictionary_comprehension" markdown="1">dictionary comprehension</a>
    to create a dictionary in a single statement.</p>
</li>
<li>
<p>We only add functions whose names start with <code>do_</code>.</p>
</li>
<li>
<p>Each key-value pair in the dictionary is the name of an operation
    and the function that implements the operation.
    The operation&rsquo;s name is what comes after <code>do_</code> in the function&rsquo;s name.</p>
</li>
</ol>
<p>With this lookup table in hand,
the code to select and run an operation is:</p>
<div class="language-py" title="vars_reflect.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">do</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
    <span class="c1"># Integers evaluate to themselves.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c1"># Lists trigger function calls.</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">OPS</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unknown operation </span><span class="si">{</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">OPS</span><span class="p">[</span><span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</code></pre></div>
</div>
<p>As with unit test functions in <a href="../test/">Chapter&nbsp;6</a>,
the <code>do_*</code> functions must have exactly the same <span class="ix-entry" ix-key="signature" markdown="1">signature</span>
so that we can call any of them with an environment and a list of arguments
without knowing exactly which function we&rsquo;re calling.
And as with finding tests,
introspection is more reliable than a hand-written lookup table
but is harder to understand.
If we write out the lookup table explicitly like this:</p>
<div class="language-py" title="vars_table.py">
<div class="highlight"><pre><span></span><code><span class="n">OPS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;abs&quot;</span><span class="p">:</span> <span class="n">do_abs</span><span class="p">,</span>
    <span class="s2">&quot;add&quot;</span><span class="p">:</span> <span class="n">do_add</span><span class="p">,</span>
    <span class="s2">&quot;get&quot;</span><span class="p">:</span> <span class="n">do_get</span><span class="p">,</span>
    <span class="s2">&quot;seq&quot;</span><span class="p">:</span> <span class="n">do_seq</span><span class="p">,</span>
    <span class="s2">&quot;set&quot;</span><span class="p">:</span> <span class="n">do_set</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p class="continue">then we can see exactly what operations are available
and what their names are.
If we use introspection,
we have to search through the source file (or possibly several files)
to find all the available operations,
but we can write <code>do</code> once and never worry about it again.</p>
<h2 id="interp-summary">Summary</h2>
<p><a class="fig-ref" href="../interp/#interp-concept-map">Figure&nbsp;7.3</a> summarizes the ideas introduced in this chapter.
A lot is going on here,
but the central idea is that a program is just another kind of data.
Please see <a href="../bonus/">Appendix&nbsp;B</a> for extra material related to these ideas.</p>
<figure id="interp-concept-map" class="here">
<img src="./concept_map.svg" alt="Concept map of interpreter"/>
<figcaption>Figure&nbsp;7.3: Interpreter concept map.</figcaption>
</figure>

<h2 id="interp-exercises">Exercises</h2>
<h3 class="exercise">Arrays</h3>
<p>Implement fixed-size, one-dimensional arrays:
<code>["array", 10]</code> creates an array of 10 elements,
while other instructions that you design
get and set particular array elements by index.</p>
<h3 class="exercise">Better Error Handling</h3>
<p>Several of the instruction functions started with <code>assert</code> statements,
which means that users get a stack trace of TLL itself
when there&rsquo;s a bug in their program.</p>
<ol>
<li>
<p>Define a new exception class called <code>TLLException</code>.</p>
</li>
<li>
<p>Write a utility function called <code>check</code>
    that raises a <code>TLLException</code> with a useful error message
    when there&rsquo;s a problem.</p>
</li>
<li>
<p>Add a <code>catch</code> statement to handle these errors.</p>
</li>
</ol>
<h3 class="exercise">More Statements</h3>
<p>Add <code>print</code> and <code>repeat</code> commands to the interpreter
so that the following program produces the output shown:</p>
<div class="language-tll" title="doubling.tll">
<div class="highlight"><pre><span></span><code>[
    &quot;seq&quot;,
    [&quot;set&quot;, &quot;a&quot;, 1],
    [&quot;print&quot;, &quot;initial&quot;, [&quot;get&quot;, &quot;a&quot;]],
    [
        &quot;repeat&quot;, 4,
        [
            &quot;seq&quot;,
            [&quot;set&quot;, &quot;a&quot;, [&quot;add&quot;, [&quot;get&quot;, &quot;a&quot;], [&quot;get&quot;, &quot;a&quot;]]],
        [&quot;if&quot;,
        [&quot;leq&quot;, [&quot;get&quot;, &quot;a&quot;], 10],
        [&quot;print&quot;, &quot;small&quot;, [&quot;get&quot;, &quot;a&quot;]],
        [&quot;print&quot;, &quot;large&quot;, [&quot;get&quot;, &quot;a&quot;]]
        ]
        ]
    ]
]
</code></pre></div>
</div>
<div class="language-out" title="doubling.out">
<div class="highlight"><pre><span></span><code>initial 1
small 2
small 4
small 8
large 16
=&gt; None
</code></pre></div>
</div>
<p>Does your <code>repeat</code> command handle &ldquo;repeat zero times&rdquo; correctly,
i.e., does it handle the program below?
If so,
what does your <code>do_repeat</code> function return as a result in this case?</p>
<div class="language-tll" title="repeat_zero.tll">
<div class="highlight"><pre><span></span><code>[&quot;repeat&quot;, 0, [&quot;print&quot;, &quot;zero&quot;]]
</code></pre></div>
</div>
<h3 class="exercise">Tracing</h3>
<p>Add a <code>--trace</code> command-line flag to the interpreter.
When enabled, it makes TLL print a message showing each function call and its result.</p>
<h3 class="exercise">While Loops</h3>
<p>Implement a <code>while</code> loop instruction.
Your implementation can use either a Python <code>while</code> loop or recursion.</p>
<h3 class="exercise">Internal Checks</h3>
<p><a class="gl-ref" href="../glossary/#defensive_programming" markdown="1">Defensive programming</a> is an approach to software development
that starts from the assumption that people make mistakes
and should therefore put checks in their code to catch &ldquo;impossible&rdquo; situations.
These checks are typically implemented as <code>assert</code> statements
that check the state of the program as it executes,
like those in our interpreter that checks the lengths of lists.</p>
<ol>
<li>
<p>What other assertions could we add to this code?</p>
</li>
<li>
<p>How many of these checks can be implemented as <a class="gl-ref" href="../glossary/#type_hint" markdown="1">type hints</a> instead?</p>
</li>
</ol>
	</main>
	<footer>
  © 2025 <a href="https://third-bit.com/">Greg Wilson</a>
  &middot;
  <a href="../">home</a>
  &middot;
  <a href="https://github.com/gvwilson/sdxpy">repository</a>
  &middot;
  <a href="../license/">license</a>
  &middot;
  <a href="mailto:gvwilson@third-bit.com">contact</a>
</footer>

      </div>
    </div>
  </body>
</html>
