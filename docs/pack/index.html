<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="repo" content="https://github.com/gvwilson/sdxpy">
  <meta name="build_date" content="2023-12-04">
  <meta name="template" content="default">
  <meta name="major" content="pack">
  <meta name="has_slides" content="true">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design by Example: A Package Manager</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <img src="../logo.svg" alt="site logo" class="logo" />
  <a href="../">Software Design by Example</a>
  
</p>

<div class="screen-reader-only">
  <a href="#printable">Skip to content</a>
</div>

<ol class="toc-chapter">
  
  <li>
    <a href="../intro/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../oop/">
      Objects and Classes
    </a>
  </li>
  
  <li>
    <a href="../dup/">
      Finding Duplicate Files
    </a>
  </li>
  
  <li>
    <a href="../glob/">
      Matching Patterns
    </a>
  </li>
  
  <li>
    <a href="../parse/">
      Parsing Text
    </a>
  </li>
  
  <li>
    <a href="../test/">
      Running Tests
    </a>
  </li>
  
  <li>
    <a href="../interp/">
      An Interpreter
    </a>
  </li>
  
  <li>
    <a href="../func/">
      Functions and Closures
    </a>
  </li>
  
  <li>
    <a href="../protocols/">
      Protocols
    </a>
  </li>
  
  <li>
    <a href="../archive/">
      A File Archiver
    </a>
  </li>
  
  <li>
    <a href="../check/">
      An HTML Validator
    </a>
  </li>
  
  <li>
    <a href="../template/">
      A Template Expander
    </a>
  </li>
  
  <li>
    <a href="../lint/">
      A Code Linter
    </a>
  </li>
  
  <li>
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li>
    <a href="../perf/">
      Performance Profiling
    </a>
  </li>
  
  <li>
    <a href="../persist/">
      Object Persistence
    </a>
  </li>
  
  <li>
    <a href="../binary/">
      Binary Data
    </a>
  </li>
  
  <li>
    <a href="../db/">
      A Database
    </a>
  </li>
  
  <li>
    <a href="../build/">
      A Build Manager
    </a>
  </li>
  
  <li>
    <a href="../pack/">
      <strong>A Package Manager</strong>
    </a>
  </li>
  
  <li>
    <a href="../ftp/">
      Transferring Files
    </a>
  </li>
  
  <li>
    <a href="../http/">
      Serving Web Pages
    </a>
  </li>
  
  <li>
    <a href="../viewer/">
      A File Viewer
    </a>
  </li>
  
  <li>
    <a href="../undo/">
      Undo and Redo
    </a>
  </li>
  
  <li>
    <a href="../vm/">
      A Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      A Debugger
    </a>
  </li>
  
  <li>
    <a href="../finale/">
      Conclusion
    </a>
  </li>
  
</ol>

<ol class="toc-appendix">
  
  <li>
    <a href="../bib/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../bonus/">
      Bonus Material
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contrib/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../credits/">
      Credits
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>


<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


<p><a href="https://github.com/gvwilson/sdxpy">GitHub repository</a></p>

      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 20: A Package Manager</h1>


          

	  
<div class="chapterinfo">

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
  <ul class="syllabus">
  
  <li markdown="1">Software packages often have multiple versions, which are usually identified by multi-part semantic version numbers.</li>
  
  <li markdown="1">A package manager must find a mutually-compatible set of dependencies in order to install a package.</li>
  
  <li markdown="1">Finding a compatible set of packages is equivalent to searching a multi-dimensional space.</li>
  
  <li markdown="1">The work required to find a compatible set of packages can grow exponentially with the number of packages.</li>
  
  <li markdown="1">Eliminating partially-formed combinations of packages can reduce the work required to find a compatible set.</li>
  
  <li markdown="1">An automated theorem prover can determine if a set of logical propositions can be made consistent with each other.</li>
  
  <li markdown="1">Most package managers use some kind of theorem prover to find compatible sets of packages to install.</li>
  
  </ul>
  

  

  

  

  

  

  



<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#gl:accumulator" markdown="1">accumulator</a>, <a class="gl-ref" href="../glossary/#gl:backward_compatible" markdown="1">backward-compatible</a>, <a class="gl-ref" href="../glossary/#gl:boolean_value" markdown="1">Boolean value</a>, <a class="gl-ref" href="../glossary/#gl:combinatorial_explosion" markdown="1">combinatorial explosion</a>, <a class="gl-ref" href="../glossary/#gl:cross_product" markdown="1">cross product</a>, <a class="gl-ref" href="../glossary/#gl:model" markdown="1">model</a>, <a class="gl-ref" href="../glossary/#gl:patch" markdown="1">patch</a>, <a class="gl-ref" href="../glossary/#gl:recursive_enumeration_pattern" markdown="1">Recursive Enumeration pattern</a>, <a class="gl-ref" href="../glossary/#gl:scoring_function" markdown="1">scoring function</a>, <a class="gl-ref" href="../glossary/#gl:search_space" markdown="1">search space</a>, <a class="gl-ref" href="../glossary/#gl:semantic_versioning" markdown="1">semantic versioning</a>
</p>


</div>


          <div class="page-toc"></div>
          <p>Inspired by the <span class="ix-entry" ix-key="Comprehensive TeX Archive Network" markdown="1">Comprehensive TeX Archive Network</span> (<a href="https://www.ctan.org/">CTAN</a>),
most languages have an online archive from which people can download packages,
such as Python&rsquo;s <a href="https://pypi.org/">PyPI</a>.
Each <span class="ix-entry" ix-key="package" markdown="1">package</span> typically has a name,
one or more versions,
and a list of <span class="ix-entry" ix-key="dependency" markdown="1">dependencies</span> (which are also versioned).
In order to install a package,
we need to figure out exactly what versions of its dependencies to install:
if A and B require different versions of C,
we might not be able to use A and B together.</p>
<p>This chapter explores how to find a workable installation or prove that there isn&rsquo;t one.
It is based in part on <a href="https://classic.yarnpkg.com/blog/2017/07/11/lets-dev-a-package-manager/">this tutorial</a>
by <span class="ix-entry" ix-key="Nison, Maël" markdown="1"><a href="https://arcanis.github.io/">Maël Nison</a></span>
and on <a href="https://andreas-zeller.info/">Andreas Zeller&rsquo;s</a>
lecture on <a href="https://www.fuzzingbook.org/html/AcademicPrototyping.html">academic prototyping</a>;
interested readers might also enjoy
<a href="https://elderlinux.org/">Michael Reim&rsquo;s</a> <a href="https://eerielinux.wordpress.com/2017/08/15/the-history-of-nix-package-management/">history of Unix packaging</a>.</p>
<h2 id="pack-semver">Section 20.1: Semantic Versioning</h2>
<p>Most software projects use
<a class="gl-ref" href="../glossary/#gl:semantic_versioning" title="A standard for identifying software releases. In the version identifier <code>major.minor.patch</code>, <code>major</code> changes when a new version of software is incompatible with old versions, <code>minor</code> changes when new features are added to an existing version, and <code>patch</code> changes when small bugs are fixed." markdown="1">semantic versioning</a>
for software releases.
Each version is three integers X.Y.Z,
where X is the major version,
Y is the minor version,
and Z is the <a class="gl-ref" href="../glossary/#gl:patch" title="A single file containing a set of changes to a set of files, separated by markers that indicate where each individual change should be applied, or the semantic versioning identifier for such a file." markdown="1">patch</a>.</p>
<p>A package&rsquo;s authors increment its major version number
when a change to the package breaks
<a class="gl-ref" href="../glossary/#gl:backward_compatible" title="A property of a system that enables interoperability with an older legacy system, or with input designed for such a system." markdown="1">backward compatibility</a>,
i.e., if code built for the old version will fail or behave unpredictably with the new one.
The minor version number is incremented when changes won&rsquo;t break any existing code,
and the patch number is changed for bug fixes that don&rsquo;t add any new features.</p>
<p>The notation for specifying ranges of versions looks like arithmetic:
<code>&gt;=1.2.3</code> means &ldquo;any version from 1.2.3 onward&rdquo;,
<code>&lt;4</code> means &ldquo;any version before 4.anything&rdquo;,
and <code>1.0-3.1</code> means &ldquo;any version in the specified range (including patches)&rdquo;.
Note that version 2.1 is greater than version 1.99:
no matter how large a minor version number becomes,
it never spills over into the major version number.</p>
<p>It isn&rsquo;t hard to compare simple semantic version identifiers,
but handling <a href="https://semver.org/">the whole standard</a>
is almost as tricky as handling dates and times correctly.
Our examples therefore number versions with plain integers;
we recommend the <a href="https://pypi.org/project/semantic-version/"><code>semantic-version</code></a> package
for working with the real thing.</p>
<h2 id="pack-exhaustive">Section 20.2: Exhaustive Search</h2>
<p>To avoid messing around with parsers,
we store the <span class="ix-entry" ix-key="manifest" markdown="1">manifest</span>
of available packages as JSON:</p>
<div class="code-sample lang-json" title="triple.json">
<div class="highlight"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;A&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;3&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;B&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;3&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;2&quot;</span><span class="p">],</span><span class="w"> </span><span class="nt">&quot;C&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;2&quot;</span><span class="p">]},</span>
<span class="w">    </span><span class="nt">&quot;2&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;B&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;2&quot;</span><span class="p">],</span><span class="w">      </span><span class="nt">&quot;C&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;1&quot;</span><span class="p">]},</span>
<span class="w">    </span><span class="nt">&quot;1&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;B&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">]}</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;B&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;3&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;C&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;2&quot;</span><span class="p">]},</span>
<span class="w">    </span><span class="nt">&quot;2&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;C&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">]},</span>
<span class="w">    </span><span class="nt">&quot;1&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">&quot;C&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">]}</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;C&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;2&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span>
<span class="w">    </span><span class="nt">&quot;1&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[]</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p>The keys in the main dictionary identify packages
(which we&rsquo;ve called <code>A</code>, <code>B</code>, and <code>C</code> for simplicity).
Each package has a dictionary whose keys are version numbers,
and each version has a dictionary showing
which versions of which other packages are dependencies
(<a class="fig-ref" href="../pack/#pack-manifest">Figure 20.1</a>).
It&rsquo;s a complex data structure,
but all of the detail is necessary.</p>
<figure id="pack-manifest">
<img src="./manifest.svg" alt="Manifest structure"/>
<figcaption markdown="1">Figure 20.1: Structure of version dependency manifest.</figcaption>
</figure>

<div class="callout">
<h3>Comments</h3>
<p>We have been advising you since <a class="x-ref" href="../parse/">Chapter 5</a> not to design your own data format,
but if you do,
please include a single standard way for people to add comments.
<span class="ix-entry" ix-key="YAML" markdown="1">YAML</span> has this,
but <span class="ix-entry" ix-key="JSON" markdown="1">JSON</span>
and <span class="ix-entry" ix-key="CSV" markdown="1">CSV</span> don&rsquo;t.</p>
</div>
<p>Imagine that each package we need is an axis on a multi-dimensional grid
(<a class="fig-ref" href="../pack/#pack-allowable">Figure 20.2</a>),
so each point on the grid is a possible combination of package versions.
We can exclude regions of this grid using the constraints on the package versions;
the points that are left represent legal combinations.</p>
<figure id="pack-allowable">
<img src="./allowable.svg" alt="Allowable versions"/>
<figcaption markdown="1">Figure 20.2: Finding allowable combinations of package versions.</figcaption>
</figure>

<p>How much work is it to check all of these possibilities?
Our example has \( 3×3×2=18 \) combinations.
If we were to add another package to the mix with two versions,
the <a class="gl-ref" href="../glossary/#gl:search_space" title="The set of all possible solutions to a problem, i.e., the set of possibilities that an algorithm must search through to find an answer." markdown="1">search space</a> would double;
add another,
and it would double again,
which means that if each package has approximately \( c \) version
and there are \( N \) packages,
the <span class="ix-entry" ix-key="big-oh notation" markdown="1">work grows</span> as \( O(c^N) \).
This exponential behavior is called
<a class="gl-ref" href="../glossary/#gl:combinatorial_explosion" title="The exponential growth in the size of a problem or the time required to solve it that arises when all possible combinations of a set of items must be searched." markdown="1">combinatorial explosion</a>,
and it makes brute-force solutions impractical even for small problems.
We will implement it as a starting point
(and to give us something to test more complicated solutions against),
but then we will need to find a more efficient approach.</p>
<div class="callout">
<h3>Reproducibility</h3>
<p>There may not be a strong reason
to prefer one mutually-compatible set of packages over another,
but a package manager should resolve the ambiguity the same way every time.
It might not be what everyone wants,
but at least they will be unhappy for the same reasons everywhere.
This is why <code>pip list</code> (and similar commands for other package managers)
produce a listing of the exact versions of packages that have been installed:
a spec written by a developer that lists allowed ranges of versions specifies what we <em>want</em>,
while the listing created by the package manager specifies exactly what we <em>got</em>.
If we want to reproduce someone else&rsquo;s setup for debugging purposes,
we should install what is described in the latter file.</p>
</div>
<p>Our brute-force program generates all possible combinations of package versions,
then eliminates ones that aren&rsquo;t compatible with the manifest.
Its main body is just those steps in order
with a few <code>print</code> statements to show the results:</p>
<div class="code-sample lang-py" title="exhaustive.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">manifest</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="p">)</span>
    <span class="n">possible</span> <span class="o">=</span> <span class="n">make_possibilities</span><span class="p">(</span><span class="n">manifest</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">possible</span><span class="p">)</span><span class="si">}</span><span class="s2"> possibilities&quot;</span><span class="p">)</span>
    <span class="n">allowed</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">possible</span> <span class="k">if</span> <span class="n">compatible</span><span class="p">(</span><span class="n">manifest</span><span class="p">,</span> <span class="n">p</span><span class="p">)]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">allowed</span><span class="p">)</span><span class="si">}</span><span class="s2"> allowed&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">allowed</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div>
</div>
<p>To generate the possibilities,
we create a list of the available versions of each package,
then use Python&rsquo;s <a href="https://docs.python.org/3/library/itertools.html"><code>itertools</code></a> module
to generate the <a class="gl-ref" href="../glossary/#gl:cross_product" title="The set of all possible combinations of items from one or more sets." markdown="1">cross product</a>
that contains all possible combinations of items
(<a class="fig-ref" href="../pack/#pack-product">Figure 20.3</a>):</p>
<div class="code-sample lang-py" title="exhaustive.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">make_possibilities</span><span class="p">(</span><span class="n">manifest</span><span class="p">):</span>
    <span class="n">available</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">package</span><span class="p">,</span> <span class="n">versions</span> <span class="ow">in</span> <span class="n">manifest</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">available</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">package</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">versions</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">available</span><span class="p">))</span>
</code></pre></div>
</div>
<figure id="pack-product">
<img src="./product.svg" alt="Generating a cross-product"/>
<figcaption markdown="1">Figure 20.3: Generating all possible combinations of items.</figcaption>
</figure>

<p>To check a candidate against the manifest,
we compare every entry X against every other entry Y:</p>
<ol>
<li>
<p>If X and Y are the same package, we keep looking.
    We need this rule because we&rsquo;re comparing every entry against every entry,
    which means we&rsquo;re comparing package versions to themselves.
    We could avoid this redundant check by writing a slightly smarter loop,
    but there&rsquo;s no point optimizing a horribly inefficient algorithm.</p>
</li>
<li>
<p>If package X&rsquo;s requirements say nothing about package Y,
    we keep searching.
    This rule handles the case of X not caring about Y,
    but it&rsquo;s also the reason we need to compare all against all,
    since Y might care about X.</p>
</li>
<li>
<p>Finally, if X does depend on Y,
    but this particular version of X doesn&rsquo;t list this particular version of Y
    as a dependency,
    we can rule out this combination.</p>
</li>
<li>
<p>If we haven&rsquo;t ruled out a candidate after doing all these checks,
    we add it to the list of allowed configurations.</p>
</li>
</ol>
<p>Sure enough,
these rules find 3 valid combinations among our 18 possibilities:</p>
<div class="code-sample lang-py" title="exhaustive.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">compatible</span><span class="p">(</span><span class="n">manifest</span><span class="p">,</span> <span class="n">combination</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">package_i</span><span class="p">,</span> <span class="n">version_i</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">:</span>
        <span class="n">lookup_i</span> <span class="o">=</span> <span class="n">manifest</span><span class="p">[</span><span class="n">package_i</span><span class="p">][</span><span class="n">version_i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">package_j</span><span class="p">,</span> <span class="n">version_j</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">package_i</span> <span class="o">==</span> <span class="n">package_j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">package_j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lookup_i</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">version_j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lookup_i</span><span class="p">[</span><span class="n">package_j</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="exhaustive.out">
<div class="highlight"><pre><span></span><code>18 possibilities
3 allowed
((&#39;A&#39;, &#39;3&#39;), (&#39;B&#39;, &#39;3&#39;), (&#39;C&#39;, &#39;2&#39;))
((&#39;A&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;2&#39;), (&#39;C&#39;, &#39;1&#39;))
((&#39;A&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;1&#39;), (&#39;C&#39;, &#39;1&#39;))
</code></pre></div>
</div>
<h2 id="pack-manual">Section 20.3: Generating Possibilities Manually</h2>
<p>Our brute-force code uses <code>itertools.product</code>
to generate all possible combinations of several lists of items.
To see how it works,
let&rsquo;s rewrite <code>make_possibilities</code> to use a function of our own:</p>
<div class="code-sample lang-py" title="manual.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">make_possibilities</span><span class="p">(</span><span class="n">manifest</span><span class="p">):</span>
    <span class="n">available</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">package</span><span class="p">,</span> <span class="n">versions</span> <span class="ow">in</span> <span class="n">manifest</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">available</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">package</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">versions</span><span class="p">])</span>

    <span class="n">accum</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">_make_possible</span><span class="p">(</span><span class="n">available</span><span class="p">,</span> <span class="p">[],</span> <span class="n">accum</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">accum</span>
</code></pre></div>
</div>
<p class="continue">The first half creates the same list of lists as before,
where each sub-list is the available versions of a single package.
It then creates an empty <a class="gl-ref" href="../glossary/#gl:accumulator" title="A variable that collects and/or combines many values. For example, if a program sums the values in an array by adding them all to a variable called <code>result</code>, then <code>result</code> is the accumulator." markdown="1">accumulator</a>
to collect all the combinations
and calls a <span class="ix-entry" ix-key="recursion" markdown="1">recursive function</span>
called <code>_make_possible</code> to fill it in.</p>
<p>Each call to <code>_make_possible</code> handles one package&rsquo;s worth of work
(<a class="fig-ref" href="../pack/#pack-recursive">Figure 20.4</a>).
If the package is X,
the function loops over the available versions of X,
adds that version to the combination in progress,
and calls itself with the remaining lists of versions.
If there aren&rsquo;t any more lists to loop over,
the recursive calls must have included exactly one version of each package,
so the combination is appended to the accumulator.</p>
<div class="code-sample lang-py" title="manual.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_make_possible</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">accum</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">remaining</span><span class="p">:</span>
        <span class="n">accum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">remaining</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">head</span><span class="p">:</span>
            <span class="n">_make_possible</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="n">current</span> <span class="o">+</span> <span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">accum</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="manual.out">
<div class="highlight"><pre><span></span><code>18 possibilities
3 allowed
[(&#39;A&#39;, &#39;3&#39;), (&#39;B&#39;, &#39;3&#39;), (&#39;C&#39;, &#39;2&#39;)]
[(&#39;A&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;2&#39;), (&#39;C&#39;, &#39;1&#39;)]
[(&#39;A&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;1&#39;), (&#39;C&#39;, &#39;1&#39;)]
</code></pre></div>
</div>
<figure id="pack-recursive">
<img src="./recursive.svg" alt="Generating a cross-product recursively"/>
<figcaption markdown="1">Figure 20.4: Generating all possible combinations of items recursively.</figcaption>
</figure>

<p><code>_make_possible</code> uses recursion instead of nested loops
because we don&rsquo;t know how many loops to write.
If we knew the manifest only contained three packages,
we would write a triply-nested loop to generate combinations,
but if there were four,
we would need a quadruply-nested loop,
and so on.
This <a class="gl-ref" href="../glossary/#gl:recursive_enumeration_pattern" title="A design pattern that generates the cross product of a set of items using recursive function calls. Each level of recursion adds items from one more set of possibilities to an accumulator." markdown="1">Recursive Enumeration</a>
<span class="ix-entry" ix-key="design pattern" markdown="1">design pattern</span>
uses one recursive function call per loop
so that we automatically get exactly as many loops as we need.</p>
<h2 id="pack-incremental">Section 20.4: Incremental Search</h2>
<p>Generating an exponentiality of combinations
and then throwing most of them away
is inefficient.
Instead,
we can modify the recursive generator
to stop if a partially-generated combination of packages isn&rsquo;t legal.
Combining generation and checking made the code more complicated,
but as we&rsquo;ll see,
it leads to some significant improvements.</p>
<p>The main function for our modified program
is similar to its predecessor.
After loading the manifest,
we generate a list of all package names.
Unlike our earlier code,
the entries in this list don&rsquo;t include versions
because we&rsquo;re going to be checking those as we go:</p>
<div class="code-sample lang-py" title="incremental.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">manifest</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="p">)</span>
    <span class="n">packages</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">manifest</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">packages</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="n">accum</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">manifest</span><span class="p">,</span> <span class="n">packages</span><span class="p">,</span> <span class="n">accum</span><span class="p">,</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;count </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">accum</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">Notice that
we reverse the list of packages before starting our search
if the user provides an extra command-line argument.
We&rsquo;ll use this to see how ordering affects efficiency.</p>
<p>Our <code>find</code> function now has five parameters:</p>
<ol>
<li>
<p>The manifest that tells us what&rsquo;s compatible with what.</p>
</li>
<li>
<p>The names of the packages we haven&rsquo;t considered yet.</p>
</li>
<li>
<p>An accumulator to hold all the valid combinations we&rsquo;ve found so far.</p>
</li>
<li>
<p>The partially-completed combination we&rsquo;re going to extend next.</p>
</li>
<li>
<p>A count of the number of combinations we&rsquo;ve considered so far,
    which we will use as a measure of efficiency.</p>
</li>
</ol>
<div class="code-sample lang-py" title="incremental.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">manifest</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">accum</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">remaining</span><span class="p">:</span>
        <span class="n">accum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">remaining</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">for</span> <span class="n">version</span> <span class="ow">in</span> <span class="n">manifest</span><span class="p">[</span><span class="n">head</span><span class="p">]:</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="n">current</span> <span class="o">+</span> <span class="p">[(</span><span class="n">head</span><span class="p">,</span> <span class="n">version</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">compatible</span><span class="p">(</span><span class="n">manifest</span><span class="p">,</span> <span class="n">candidate</span><span class="p">):</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span>
                    <span class="n">manifest</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">accum</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">count</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">count</span>
</code></pre></div>
</div>
<p>The algorithm combines the generation and checking we&rsquo;ve already written:</p>
<ol>
<li>
<p>If there are no packages left to consider—i.e.,
    if <code>remaining</code> is an empty list—then
    what we&rsquo;ve built so far in <code>current</code> must be valid,
    so we append it to <code>accumulator</code>.</p>
</li>
<li>
<p>Otherwise,
    we put the next package to consider in <code>head</code>
    and all the remaining packages in <code>tail</code>.
    We then check each version of the <code>head</code> package in turn.
    If adding it to the current collection of packages
    wouldn&rsquo;t cause a problem,
    we continue searching with that version in place.</p>
</li>
</ol>
<p>How much work does incremental checking save us?
Using the same test case as before,
we only create 11 candidates instead of 18,
so we&rsquo;ve reduced our search by about a third:</p>
<div class="code-sample lang-sh" title="incremental.sh">
<div class="highlight"><pre><span></span><code>python<span class="w"> </span>incremental.py<span class="w"> </span>&lt;<span class="w"> </span>triple.json
</code></pre></div>
</div>
<div class="code-sample lang-out" title="incremental.out">
<div class="highlight"><pre><span></span><code>count 11
[(&#39;A&#39;, &#39;3&#39;), (&#39;B&#39;, &#39;3&#39;), (&#39;C&#39;, &#39;2&#39;)]
[(&#39;A&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;2&#39;), (&#39;C&#39;, &#39;1&#39;)]
[(&#39;A&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;1&#39;), (&#39;C&#39;, &#39;1&#39;)]
</code></pre></div>
</div>
<p class="continue">If we reverse the order in which we search,
though,
we only generate half as many candidates as before:</p>
<div class="code-sample lang-sh" title="incremental_reverse.sh">
<div class="highlight"><pre><span></span><code>python<span class="w"> </span>incremental.py<span class="w"> </span>reversed<span class="w"> </span>&lt;<span class="w"> </span>triple.json
</code></pre></div>
</div>
<div class="code-sample lang-out" title="incremental_reverse.out">
<div class="highlight"><pre><span></span><code>count 9
[(&#39;C&#39;, &#39;2&#39;), (&#39;B&#39;, &#39;3&#39;), (&#39;A&#39;, &#39;3&#39;)]
[(&#39;C&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;2&#39;), (&#39;A&#39;, &#39;2&#39;)]
[(&#39;C&#39;, &#39;1&#39;), (&#39;B&#39;, &#39;1&#39;), (&#39;A&#39;, &#39;1&#39;)]
</code></pre></div>
</div>
<h2 id="pack-smt">Section 20.5: Using a Theorem Prover</h2>
<p>Cutting the amount of work we have to do is good:
can we do better?
The answer is yes,
but the algorithms involved are complicated and the jargon almost impenetrable.
To give you a taste of how they work,
we will solve our example problem using the <a href="https://en.wikipedia.org/wiki/Z3_Theorem_Prover">Z3 theorem prover</a>.</p>
<p>Installing packages and proving theorems
may not seem to have a lot to do with each other,
but an automated theorem prover&rsquo;s purpose is
to determine how to make a set of logical propositions consistent with each other,
or to prove that doing so is impossible.
If we frame our problem as,
&ldquo;Is there a choice of package versions
that satisfies all the inter-package dependencies at once?&rdquo;,
then a theorem prover is exactly what we need.</p>
<p>To start,
let&rsquo;s import a few things from <code>z3</code>
and create three <a class="gl-ref" href="../glossary/#gl:boolean_value" title="One of the two values &quot;true&quot; or &quot;false&quot;. Named for George Boole, a 19th century mathematician." markdown="1">Boolean variables</a>:</p>
<div class="code-sample lang-py" title="z3_setup.py">
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="n">Bool</span><span class="p">,</span> <span class="n">Implies</span><span class="p">,</span> <span class="n">Not</span><span class="p">,</span> <span class="n">Solver</span><span class="p">,</span> <span class="n">sat</span><span class="p">,</span> <span class="n">unsat</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">Our three variables don&rsquo;t have values yet—they&rsquo;re not
either true or false.
Instead,
each one represents all the possible states a Boolean could be in.
If we had asked <code>z3</code> to create one of its special integers,
it would have given us something that initially encompassed
all possible integer values.</p>
<p>Instead of assigning values to <code>A</code>, <code>B</code>, and <code>C</code>,
we specify constraints on them,
then ask <code>z3</code> whether it&rsquo;s possible to find a set of values,
or <a class="gl-ref" href="../glossary/#gl:model" title="A set of values for variables that satisfies a specific set of constraints." markdown="1">model</a>,
that satisfies all those constraints at once.
For example,
we can ask whether it&rsquo;s possible for <code>A</code> to equal <code>B</code>
and <code>B</code> to equal <code>C</code> at the same time.
The answer is &ldquo;yes&rdquo;,
and the solution the solver finds is to make them all <code>False</code>:</p>
<div class="code-sample lang-py" title="z3_equal.py">
<div class="highlight"><pre><span></span><code><span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">B</span> <span class="o">==</span> <span class="n">C</span><span class="p">)</span>
<span class="n">report</span><span class="p">(</span><span class="s2">&quot;A == B &amp; B == C&quot;</span><span class="p">,</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">())</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="z3_equal.out">
<div class="highlight"><pre><span></span><code>A == B &amp; B == C: sat
A False
B False
C False
</code></pre></div>
</div>
<p>What if we say that <code>A</code> and <code>B</code> must be equal,
but <code>B</code> and <code>C</code> must be unequal?
In this case,
the solver finds a solution in which <code>A</code> and <code>B</code> are <code>True</code>
but <code>C</code> is <code>False</code>:</p>
<div class="code-sample lang-py" title="z3_part_equal.py">
<div class="highlight"><pre><span></span><code><span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">B</span> <span class="o">!=</span> <span class="n">C</span><span class="p">)</span>
<span class="n">report</span><span class="p">(</span><span class="s2">&quot;A == B &amp; B != C&quot;</span><span class="p">,</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">())</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="z3_part_equal.out">
<div class="highlight"><pre><span></span><code>A == B &amp; B != C: sat
A True
B True
C False
</code></pre></div>
</div>
<p>Finally,
what if we require <code>A</code> to equal <code>B</code> and <code>B</code> to equal <code>C</code>
but <code>A</code> and <code>C</code> to be unequal?
No assignment of values to the three variables
can satisfy all three constraints at once,
and the solver duly tells us that:</p>
<div class="code-sample lang-py" title="z3_unequal.py">
<div class="highlight"><pre><span></span><code><span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">B</span> <span class="o">==</span> <span class="n">C</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="n">C</span><span class="p">)</span>
<span class="n">report</span><span class="p">(</span><span class="s2">&quot;A == B &amp; B == C &amp; B != C&quot;</span><span class="p">,</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">())</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="z3_unequal.out">
<div class="highlight"><pre><span></span><code>A == B &amp; B == C &amp; B != C: unsat
</code></pre></div>
</div>
<p>Returning to package management,
we can represent the versions from our running example like this:</p>
<div class="code-sample lang-py" title="z3_triple.py">
<div class="highlight"><pre><span></span><code><span class="n">A1</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="s2">&quot;A.1&quot;</span><span class="p">)</span>
<span class="n">A2</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="s2">&quot;A.2&quot;</span><span class="p">)</span>
<span class="n">A3</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="s2">&quot;A.3&quot;</span><span class="p">)</span>

<span class="n">B1</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="s2">&quot;B.1&quot;</span><span class="p">)</span>
<span class="n">B2</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="s2">&quot;B.2&quot;</span><span class="p">)</span>
<span class="n">B3</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="s2">&quot;B.3&quot;</span><span class="p">)</span>

<span class="n">C1</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="s2">&quot;C.1&quot;</span><span class="p">)</span>
<span class="n">C2</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="s2">&quot;C.2&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">We then tell the solver that we want one of the available versions of package A:</p>
<div class="code-sample lang-py" title="z3_triple.py">
<div class="highlight"><pre><span></span><code><span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">A3</span><span class="p">))</span>
</code></pre></div>
</div>
<p class="continue">and that the three versions of package A are mutually exclusive:</p>
<div class="code-sample lang-py" title="z3_triple.py">
<div class="highlight"><pre><span></span><code><span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">Not</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">A2</span><span class="p">,</span> <span class="n">A3</span><span class="p">))))</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">A2</span><span class="p">,</span> <span class="n">Not</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A3</span><span class="p">))))</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">A3</span><span class="p">,</span> <span class="n">Not</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">))))</span>
</code></pre></div>
</div>
<p class="continue">We need equivalent statements for packages B and C;
we&rsquo;ll explore in the exercises
how to generate all of these from a package manifest.</p>
<p>Finally,
we add the inter-package dependencies
and search for a result:</p>
<div class="code-sample lang-py" title="z3_triple.py">
<div class="highlight"><pre><span></span><code><span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">A3</span><span class="p">,</span> <span class="n">And</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">B3</span><span class="p">,</span> <span class="n">B2</span><span class="p">),</span> <span class="n">C2</span><span class="p">)))</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">A2</span><span class="p">,</span> <span class="n">And</span><span class="p">(</span><span class="n">B2</span><span class="p">,</span> <span class="n">Or</span><span class="p">(</span><span class="n">C2</span><span class="p">,</span> <span class="n">C1</span><span class="p">))))</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">B1</span><span class="p">))</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">B3</span><span class="p">,</span> <span class="n">C2</span><span class="p">))</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">B2</span><span class="p">,</span> <span class="n">C1</span><span class="p">))</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">B1</span><span class="p">,</span> <span class="n">C1</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">(),</span> <span class="n">solver</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="z3_triple.out">
<div class="highlight"><pre><span></span><code>result sat [B.3 = True,
 A.1 = False,
 C.2 = True,
 C.1 = False,
 B.2 = False,
 A.3 = True,
 A.2 = False,
 B.1 = False]
</code></pre></div>
</div>
<p class="continue">The output tells us that the combination of A.3, B.3, and C.2
will satisfy our constraints.</p>
<p>We saw earlier,
though,
that there are three solutions to our constraints.
One way to find the others is to ask the solver
to solve the problem again
with the initial solution ruled out.
We can repeat the process many times,
adding &ldquo;not the latest solution&rdquo; to the constraints each time
until the problem becomes unsolvable:</p>
<div class="code-sample lang-py" title="z3_complete.py">
<div class="highlight"><pre><span></span><code><span class="n">everything</span> <span class="o">=</span> <span class="p">[</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">A3</span><span class="p">,</span> <span class="n">B1</span><span class="p">,</span> <span class="n">B2</span><span class="p">,</span> <span class="n">B3</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">]</span>
<span class="k">while</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="o">==</span> <span class="n">sat</span><span class="p">:</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">([</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">decls</span><span class="p">()</span> <span class="k">if</span> <span class="n">model</span><span class="p">[</span><span class="n">var</span><span class="p">]])</span>
    <span class="n">settings</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="o">==</span> <span class="n">model</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">everything</span><span class="p">]</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">Not</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="o">*</span><span class="n">settings</span><span class="p">))</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="z3_complete.out">
<div class="highlight"><pre><span></span><code>[B.3, C.2, A.3]
[C.1, B.2, A.2]
[A.1, C.1, B.1]
</code></pre></div>
</div>
<h2 id="pack-summary">Section 20.6: Summary</h2>
<p><a class="fig-ref" href="../pack/#pack-concept-map">Figure 20.5</a> summarizes the key ideas introduced in this chapter.
The most important thing to take away is that
modern theorem provers can solve many more problems than most programmers realize.
While formulating problems in ways that theorem provers understand can be challenging,
solving those problems ourselves is usually much harder.</p>
<figure id="pack-concept-map" class="here">
<img src="./concept_map.svg" alt="Concept map for package manager."/>
<figcaption markdown="1">Figure 20.5: Concepts for package manager.</figcaption>
</figure>

<h2 id="pack-exercises">Section 20.7: Exercises</h2>
<h3 class="exercise">Comparing Semantic Versions</h3>
<p>Write a function that takes an array of semantic version specifiers
and sorts them in ascending order.
Remember that <code>2.1</code> is greater than <code>1.99</code>.</p>
<h3 class="exercise">Parsing Semantic Versions</h3>
<p>Write a parser for a subset of the <a href="https://semver.org/">semantic versioning specification</a>.</p>
<h3 class="exercise">Using Scoring Functions</h3>
<p>Many different combinations of package versions can be mutually compatible.
One way to decide which actual combination to install
is to create a <a class="gl-ref" href="../glossary/#gl:scoring_function" title="A function that measures how good a solution to a problem is." markdown="1">scoring function</a>
that measures how good or bad a particular combination is.
For example,
a function could measure the &ldquo;distance&rdquo; between two versions as:</p>
<ul>
<li>
<p>100 times the difference in major version numbers;</p>
</li>
<li>
<p>10 times the difference in minor version numbers
    if the major numbers agree;
    and</p>
</li>
<li>
<p>the difference in the patch numbers
    if both major and minor numbers agree.</p>
</li>
</ul>
<p class="continue">Implement this function
and use it to measure the total distance between
the set of packages found by the solver
and the set containing the most recent version of each package.
Does it actually solve the original problem?</p>
<h3 class="exercise">Regular Releases</h3>
<p>Some packages release new versions regularly,
e.g.,
Version 2023.1 is released on March 1 of 2023,
Version 2023.2 is released on September 1 of that year,
version 2024.1 is released on March 1 of the following year,
and so on.</p>
<ol>
<li>
<p>How does this make package management easier?</p>
</li>
<li>
<p>How does it make it more difficult?</p>
</li>
</ol>
<h3 class="exercise">Searching Least First</h3>
<p>Rewrite the constraint solver so that it searches packages
by looking at those with the fewest available versions first.
Does this reduce the amount of work done for the small examples in this chapter?
Does it reduce the amount of work done for larger examples?</p>
<h3 class="exercise">Using Exclusions</h3>
<ol>
<li>
<p>Modify the constraint solver so that
    it uses a list of package exclusions instead of a list of package requirements,
    i.e.,
    its input tells it that version 1.2 of package Red
    can <em>not</em> work with versions 3.1 and 3.2 of package Green
    (which implies that Red 1.2 can work with any other versions of Green).</p>
</li>
<li>
<p>Explain why package managers aren&rsquo;t built this way.</p>
</li>
</ol>
<h3 class="exercise">Generating Constraints</h3>
<p>Write a function that reads a JSON manifest describing package compatibilities
and generates the constraints needed by the Z3 theorem prover.</p>
<h3 class="exercise">Buildability</h3>
<ol>
<li>
<p>Convert the build dependencies from one of the examples in <a class="x-ref" href="../build/">Chapter 19</a>
    to a set of constraints for Z3
    and use the solution to find a legal build order.</p>
</li>
<li>
<p>Modify the constraints to introduce
    a <span class="ix-entry" ix-key="circular dependency" markdown="1">circular dependency</span>
    and check that the solver correctly determines
    that there is no legal build order.</p>
</li>
</ol>
        </main>
      </div>
    </div>
  </body>
</html>
