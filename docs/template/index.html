<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="repo" content="https://github.com/gvwilson/sdxpy">
  <meta name="build_date" content="2023-08-13">
  <meta name="template" content="default">
  <meta name="major" content="template">
  <meta name="has_slides" content="true">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design by Example: A Template Expander</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <img src="../logo.svg" alt="site logo" class="logo" />
  <a href="../">Software Design by Example</a>
  
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../intro/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../oop/">
      Objects and Classes
    </a>
  </li>
  
  <li>
    <a href="../dup/">
      Finding Duplicate Files
    </a>
  </li>
  
  <li>
    <a href="../glob/">
      Matching Patterns
    </a>
  </li>
  
  <li>
    <a href="../parse/">
      Parsing Text
    </a>
  </li>
  
  <li>
    <a href="../test/">
      Running Tests
    </a>
  </li>
  
  <li>
    <a href="../interp/">
      An Interpreter
    </a>
  </li>
  
  <li>
    <a href="../func/">
      Functions and Closures
    </a>
  </li>
  
  <li>
    <a href="../protocols/">
      Protocols
    </a>
  </li>
  
  <li>
    <a href="../archive/">
      A File Archiver
    </a>
  </li>
  
  <li>
    <a href="../check/">
      An HTML Validator
    </a>
  </li>
  
  <li>
    <a href="../template/">
      <strong>A Template Expander</strong>
    </a>
  </li>
  
  <li>
    <a href="../lint/">
      A Code Linter
    </a>
  </li>
  
  <li>
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li>
    <a href="../perf/">
      Performance Profiling
    </a>
  </li>
  
  <li>
    <a href="../persist/">
      Object Persistence
    </a>
  </li>
  
  <li>
    <a href="../binary/">
      Binary Data
    </a>
  </li>
  
  <li>
    <a href="../db/">
      A Database
    </a>
  </li>
  
  <li>
    <a href="../build/">
      A Build Manager
    </a>
  </li>
  
  <li>
    <a href="../pack/">
      A Package Manager
    </a>
  </li>
  
  <li>
    <a href="../ftp/">
      Transferring Files
    </a>
  </li>
  
  <li>
    <a href="../http/">
      Serving Web Pages
    </a>
  </li>
  
  <li>
    <a href="../viewer/">
      A File Viewer
    </a>
  </li>
  
  <li>
    <a href="../undo/">
      Undo and Redo
    </a>
  </li>
  
  <li>
    <a href="../vm/">
      A Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      A Debugger
    </a>
  </li>
  
  <li>
    <a href="../finale/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../bib/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../bonus/">
      Bonus Material
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contrib/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../credits/">
      Credits
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 12: A Template Expander</h1>


          
<div class="draft notex">
  <p class="draft">
    DRAFT 2023-08-13
  </p>
  <p>
    revised 2023-08-04<br>
    Please use section heading links to submit feedback
    or go to <a href="https://github.com/gvwilson/sdxpy">https://github.com/gvwilson/sdxpy</a>.
  </p>
</div>


	  
<div class="chapterinfo">

  

  

  

  

  

  

  

  

  

  

  

  
  <ul class="syllabus">
  
  <li markdown="1">Static site generators create HTML pages from templates, directives, and data.</li>
  
  <li markdown="1">A static site generator has the same core features as a programming language.</li>
  
  <li markdown="1">Special-purpose mini-languages quickly become as complex as mainstream languages.</li>
  
  <li markdown="1">Static methods are a convenient way to group functions together.</li>
  
  </ul>
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  



<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#gl:abstract_class" markdown="1">abstract class</a>, <a class="gl-ref" href="../glossary/#gl:abstract_method" markdown="1">abstract method</a>, <a class="gl-ref" href="../glossary/#gl:api" markdown="1">Application Programming Interface</a>, <a class="gl-ref" href="../glossary/#gl:boolean_expression" markdown="1">Boolean expression</a>, <a class="gl-ref" href="../glossary/#gl:static_site_generator" markdown="1">static site generator</a>, <a class="gl-ref" href="../glossary/#gl:truthy" markdown="1">truthy</a>
</p>


</div>


          <div class="page-toc"></div>
          <p>Every program needs documentation,
and the best place to put documentation is on the web.
Writing and updating HTML pages by hand is time-consuming and error-prone,
particularly when many parts are the same,
so most modern websites use some kind of
<a class="gl-ref" href="../glossary/#gl:static_site_generator" title="A software tool that creates HTML pages from templates and content." markdown="1">static site generator</a> (SSG)
to create pages from templates.</p>
<p><a href="https://jamstack.org/generators/">Hundreds of SSGs</a> have been written in every popular programming language,
and languages like <span class="ix-entry" ix-key="PHP" markdown="1"><a href="https://www.php.net/">PHP</a></span> have been invented primarily for this purpose.
Most of these systems use one of three designs
(<a class="fig-ref" href="../template/#template-options">Figure 12.1</a>):</p>
<ol>
<li>
<p>Mix commands in an existing language such as JavaScript
    with the <span class="ix-entry" ix-key="HTML" markdown="1">HTML</span> or <span class="ix-entry" ix-key="Markdown" markdown="1">Markdown</span>
    using some kind of marker to indicate which parts are commands
    and which parts are to be taken as-is.
    This approach is taken by <span class="ix-entry" ix-key="EJS" markdown="1"><a href="https://ejs.co/">EJS</a></span>.</p>
</li>
<li>
<p>Create a mini-language with its own commands like <span class="ix-entry" ix-key="Jekyll" markdown="1"><a href="https://jekyllrb.com/">Jekyll</a></span>.
    Mini-languages are appealing because they are smaller and safer than general-purpose languages,
    but eventually they acquire most of the features of a general-purpose language.
    Again, some kind of marker must be used to show
    which parts of the page are code and which are ordinary text.</p>
</li>
<li>
<p>Put directives in specially-named <span class="ix-entry" ix-key="attribute" markdown="1">attributes</span> in the HTML.
    This approach is the least popular,
    but it eliminates the need for a special <span class="ix-entry" ix-key="parser" markdown="1">parser</span>.</p>
</li>
</ol>
<figure id="template-options">
<img src="./design_options.svg" alt="Three options for page templates"/>
<figcaption markdown="1">Figure 12.1: Three different ways to implement page templating.</figcaption>
</figure>

<p>This chapter builds a simple page templating system using the third strategy.
We will process each page independently by parsing the HTML
and walking the <span class="ix-entry" ix-key="DOM" markdown="1">DOM</span> to find <span class="ix-entry" ix-key="node" markdown="1">nodes</span> with special attributes.
Our program will execute the instructions in those nodes
to implement loops and if/else statements;
other nodes will be copied as-is to create text.</p>
<h2 id="template-syntax">Section 12.1: Syntax</h2>
<p>Let&rsquo;s start by deciding what &ldquo;done&rdquo; looks like.
Suppose we want to turn an array of strings into an HTML list.
Our template will look like this:</p>
<div class="code-sample lang-ht" title="loop.ht">
<div class="highlight"><pre><span></span><code>&lt;html&gt;
  &lt;body&gt;
    &lt;ul z-loop=&quot;item:names&quot;&gt;
      &lt;li&gt;&lt;span z-var=&quot;item&quot;/&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
</div>
<p>The attribute <code>z-loop</code> tells the tool to repeat the contents of that node;
the loop variable and the collection being looped over are separated by a colon.
The <code>span</code> with the attribute <code>z-var</code>
tells the tool to fill in the node with the value of the variable.
When our tool processes this page,
the output will be standard HTML without any traces of how it was created:</p>
<div class="code-sample lang-out" title="loop.out">
<div class="highlight"><pre><span></span><code>&lt;html&gt;
&lt;body&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span&gt;Johnson&lt;/span&gt;&lt;/li&gt;

&lt;li&gt;&lt;span&gt;Vaughan&lt;/span&gt;&lt;/li&gt;

&lt;li&gt;&lt;span&gt;Jackson&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
</div>
<div class="callout">
<h3>Human-Readable vs. Machine-Readable</h3>
<p>Mini-languages for page templating can quickly become unreadable.
We have already started down that road
by putting the loop variable and loop target in a single attribute
and splitting that attribute to get them out.
Doing this makes loops easy for people to type,
but hides important information from standard HTML processing tools:
they can&rsquo;t know that this particular attribute of these particular elements
contains multiple values
or that those values should be extracted by splitting a string on a colon.
We could instead use two attributes like this:</p>
<div class="highlight"><pre><span></span><code><span class="p">&lt;</span><span class="nt">ul</span> <span class="na">z-loop</span><span class="o">=</span><span class="s">&quot;names&quot;</span> <span class="na">z-loop-var</span><span class="o">=</span><span class="s">&quot;item&quot;</span><span class="p">&gt;</span>
</code></pre></div>
<p class="continue">but we have decided to save ourselves a little typing.
And strictly speaking
we should call our attributes <code>data-something</code> instead of <code>z-something</code>
to conform with the <span class="ix-entry" ix-key="HTML5 specification" markdown="1"><a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes">HTML5 specification</a></span>,
but by the time we&rsquo;re finished processing our templates,
there shouldn&rsquo;t be any <code>z-*</code> attributes left to confuse a browser.</p>
</div>
<p>The next step is to define the <a class="gl-ref" href="../glossary/#gl:api" title="A set of functions provided by a software library or web service that other software can call." markdown="1">Application Programming Interface</a> (API)
for filling in templates.
Our tool needs the template itself,
somewhere to write its output,
and the set of variables to use in the expansion.
Those variables might come from a configuration file
from a header in the file itself,
or from somewhere else entirely,
so we will assume the calling program has gotten them somehow
and have it pass them into the expansion function as an dictionary
(<a class="fig-ref" href="../template/#template-api">Figure 12.2</a>):</p>
<div class="code-sample lang-py" title="example_call.py">
<div class="highlight"><pre><span></span><code><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;names&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;Johnson&quot;</span><span class="p">,</span> <span class="s2">&quot;Vaughan&quot;</span><span class="p">,</span> <span class="s2">&quot;Jackson&quot;</span><span class="p">]}</span>

<span class="n">dom</span> <span class="o">=</span> <span class="n">read_html</span><span class="p">(</span><span class="s2">&quot;template.html&quot;</span><span class="p">)</span>
<span class="n">expander</span> <span class="o">=</span> <span class="n">Expander</span><span class="p">(</span><span class="n">dom</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="n">expander</span><span class="o">.</span><span class="n">walk</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">expander</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
</code></pre></div>
</div>
<figure id="template-api">
<img src="./api.svg" alt="Template API"/>
<figcaption markdown="1">Figure 12.2: Combining text and data in templating.</figcaption>
</figure>

<h2 id="template-values">Section 12.2: Managing Variables</h2>
<p>As soon as we have variables we need a way to track their values.
We also need to maintain multiple sets of variables
so that (for example) variables used inside a loop
don&rsquo;t conflict with ones used outside it.
As in <a class="x-ref" href="../interp/">Chapter 7</a>,
we will use a stack of <span class="ix-entry" ix-key="environment" markdown="1">environments</span>,
each of which is a dictionary.</p>
<p>Our stack-handling class <code>Env</code> has methods
to push and pop new <span class="ix-entry" ix-key="stack frame" markdown="1">stack frames</span>
and find a variable given its name.
If the variable can&rsquo;t be found,
<code>Env.find</code> returns <code>None</code> instead of raising an exception:</p>
<div class="code-sample lang-py" title="env.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Env</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">frame</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">frame</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
</div>
<h2 id="template-nodes">Section 12.3: Visiting Nodes</h2>
<p>As <a class="x-ref" href="../check/">Chapter 11</a> explained,
HTML pages are usually stored in memory as trees
and processed using the <span class="ix-entry" ix-key="Visitor pattern" markdown="1">Visitor</span> <span class="ix-entry" ix-key="design pattern" markdown="1">pattern</span>.
We therefore create a <code>Visitor</code> class
whose <span class="ix-entry" ix-key="constructor" markdown="1">constructor</span> takes the root node of the <span class="ix-entry" ix-key="DOM tree" markdown="1">DOM tree</span>
as an argument and saves it.
Calling <code>Visitor.walk</code> without a value starts <span class="ix-entry" ix-key="recursion" markdown="1">recursion</span> from that saved root;
when <code>.walk</code> is given a value (as it is during recursive calls),
it uses that instead.</p>
<div class="code-sample lang-py" title="visitor.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Visitor</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>

    <span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;open&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;close&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p><code>Visitor</code> defines two <a class="gl-ref" href="../glossary/#gl:abstract_method" title="In object-oriented programming, a method that is defined but not implemented. Programmers will define an abstract method in a parent class to specify operations that child classes must provide." markdown="1">abstract methods</a> <code>open</code> and <code>close</code>
that are called when we first arrive at a node and when we are finished with it.
These methods are called &ldquo;abstract&rdquo; because we can&rsquo;t actually use them:
any attempt to do so will <span class="ix-entry" ix-key="raise" markdown="1">raise</span> an <span class="ix-entry" ix-key="exception" markdown="1">exception</span>,
which means <span class="ix-entry" ix-key="child class" markdown="1">child classes</span> <em>must</em> override them.
(In object-oriented terminology, this means that <code>Visitor</code> is an <a class="gl-ref" href="../glossary/#gl:abstract_class" title="A class that defines or requires methods it does not implement. An abstract class typically specifies the methods that child classes must have without providing default implementations." markdown="1">abstract class</a>.)
This approach is different from that of the visitor in <a class="x-ref" href="../check/">Chapter 11</a>,
where we defined do-nothing methods so that derived classes could override
only the ones they needed.</p>
<p>The <code>Expander</code> class is specialization of <code>Visitor</code>
that uses an <code>Env</code> to keep track of variables.
It imports handlers for each type of special node—we will explore those in a moment—and
saves them along with a newly-created environment and a list of strings
making up the output:</p>
<div class="code-sample lang-py" title="expander.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Expander</span><span class="p">(</span><span class="n">Visitor</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span> <span class="o">=</span> <span class="n">Env</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span> <span class="o">=</span> <span class="n">HANDLERS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div>
</div>
<p>When recursion encounters a new node it calls <code>open</code> to do one of three things:</p>
<ol>
<li>
<p>If the node is plain text,
    copy it to the output.</p>
</li>
<li>
<p>If there is a handler for the node,
    call the handler&rsquo;s <code>open</code> or <code>close</code> method.</p>
</li>
<li>
<p>Otherwise, open a regular <span class="ix-entry" ix-key="tag" markdown="1">tag</span>.</p>
</li>
</ol>
<div class="code-sample lang-py" title="expander.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">NavigableString</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasHandler</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getHandler</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">showTag</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>
</div>
<p class="continue"><code>Expander.close</code> works much the same way.
Both methods find handlers by comparing the DOM node&rsquo;s attributes
to the keys in the dictionary of handlers built during construction:</p>
<div class="code-sample lang-py" title="expander.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">hasHandler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">any</span><span class="p">(</span>
        <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attrs</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">getHandler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="n">possible</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attrs</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span>
    <span class="p">]</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Should be exactly one handler&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="p">[</span><span class="n">possible</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
</code></pre></div>
</div>
<p class="continue">Finally, we need a few helper methods to show tags and generate output:</p>
<div class="code-sample lang-py" title="expander.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">showTag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">closing</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">closing</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&lt;/</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&gt;&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;z-&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">=&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;UNDEF&quot;</span> <span class="k">if</span> <span class="n">text</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">text</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">getResult</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Notice that <code>Expander</code> adds strings to an array
and joins them all right at the end
rather than concatenating strings repeatedly.
Doing this is more efficient;
it also helps with debugging,
since each string in the array corresponds to a single method call.</p>
<h2 id="template-handlers">Section 12.4: Implementing Handlers</h2>
<p>Our last task is to implement the handlers for filling in variables&rsquo; values,
looping,
and so on.
We could define an <span class="ix-entry" ix-key="abstract class" markdown="1">abstract class</span> with <code>open</code> and <code>close</code> methods,
derive one class for each of the template expander&rsquo;s capabilities,
and then construct one instance of each class for <code>Expander</code> to use,
but there&rsquo;s a simpler way.
When Python executes the statement <code>import something</code>
it executes the file <code>something.py</code>,
saves the result in a specialized dictionary-like object,
and assigns that object to the variable <code>something</code>.
That object can also be saved in data structures like lists and dictionaries
or passed as an argument to a function
just like numbers, functions, and classes—remember,
programs are just data.</p>
<p>Let&rsquo;s write a pair of functions
that each take an expander and a node as inputs
and expand a DOM node with a <code>z-num</code> attribute
to insert a number into the output:</p>
<div class="code-sample lang-py" title="z_num.py">
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;Insert a constant.&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="n">expander</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="n">expander</span><span class="o">.</span><span class="n">showTag</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">expander</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;z-num&quot;</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="n">expander</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="n">expander</span><span class="o">.</span><span class="n">showTag</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">When we enter a node like <code>&lt;span z-num="123"/&gt;</code>
this handler asks the expander to show an <span class="ix-entry" ix-key="opening tag" markdown="1">opening tag</span>
followed by the value of the <code>z-num</code> attribute.
When we exit the node,
the handler asks the expander to close the tag.
The handler doesn&rsquo;t know whether things are printed immediately,
added to an output list,
or something else;
it just knows that whoever called it implements the low-level operations it needs.</p>
<p>Here&rsquo;s how we connect this handler (and others we&rsquo;re going to write in a second)
to the expander:</p>
<div class="code-sample lang-py" title="expander.py">
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">z_if</span>
<span class="kn">import</span> <span class="nn">z_loop</span>
<span class="kn">import</span> <span class="nn">z_num</span>
<span class="kn">import</span> <span class="nn">z_var</span>

<span class="n">HANDLERS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;z-if&quot;</span><span class="p">:</span> <span class="n">z_if</span><span class="p">,</span>
    <span class="s2">&quot;z-loop&quot;</span><span class="p">:</span> <span class="n">z_loop</span><span class="p">,</span>
    <span class="s2">&quot;z-num&quot;</span><span class="p">:</span> <span class="n">z_num</span><span class="p">,</span>
    <span class="s2">&quot;z-var&quot;</span><span class="p">:</span> <span class="n">z_var</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p>The <code>HANDLERS</code> dictionary maps the names of special attributes in the HTML to modules,
each of which defines <code>open</code> and <code>close</code> functions for the expander to call.
In other words,
we are using modules to prevent <span class="ix-entry" ix-key="name collision" markdown="1">name collision</span>
just as we would use classes or functions.</p>
<p>The handlers for variables are:</p>
<div class="code-sample lang-py" title="z_var.py">
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;Insert value of variable.&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="n">expander</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="n">expander</span><span class="o">.</span><span class="n">showTag</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">expander</span><span class="o">.</span><span class="n">output</span><span class="p">(</span><span class="n">expander</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;z-var&quot;</span><span class="p">]))</span>

<span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="n">expander</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="n">expander</span><span class="o">.</span><span class="n">showTag</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">This code is almost the same as the previous example.
The only difference is that instead of copying the attribute&rsquo;s value
directly to the output,
we use it as a key to look up a value.</p>
<p>These two pairs of handlers look plausible, but do they work?
To find out,
we can build a program that loads variable definitions from a JSON file,
reads an HTML template using the <a href="https://beautiful-soup-4.readthedocs.io/">Beautiful Soup</a> module,
and does the expansion:</p>
<div class="code-sample lang-py" title="template.py">
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>
<span class="kn">from</span> <span class="nn">expander</span> <span class="kn">import</span> <span class="n">Expander</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(),</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
        <span class="n">template</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;html&quot;</span><span class="p">)</span>

    <span class="n">expander</span> <span class="o">=</span> <span class="n">Expander</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">variables</span><span class="p">)</span>
    <span class="n">expander</span><span class="o">.</span><span class="n">walk</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">expander</span><span class="o">.</span><span class="n">getResult</span><span class="p">())</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div>
</div>
<p>We added new variables for our test cases one by one
as we were writing this chapter.
To avoid repeating text repeatedly,
here&rsquo;s the entire set:</p>
<div class="code-sample lang-json" title="vars.json">
<div class="highlight"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;firstVar&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;firstValue&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;secondVar&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;secondValue&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;varName&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;varValue&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;yes&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;no&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;names&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;Johnson&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Vaughan&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Jackson&quot;</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p>Our first test checks whether static text is copied over as-is:</p>
<table class="twocol">
  <tbody>
    <tr>
      <td markdown="1"><div class="code-sample lang-ht" title="static_text.ht" markdown="1">
<div class="highlight"><pre><span></span><code>&lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Static Text&lt;/h1&gt;
    &lt;p&gt;test&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
</div></td>
      <td markdown="1"><div class="code-sample lang-out" title="static_text.out" markdown="1">
<div class="highlight"><pre><span></span><code>&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;Static Text&lt;/h1&gt;
&lt;p&gt;test&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
</div></td>
    </tr>
  </tbody>
</table>

<p>Good.
Now, does the expander handle constants?</p>
<table class="twocol">
  <tbody>
    <tr>
      <td markdown="1"><div class="code-sample lang-ht" title="single_constant.ht" markdown="1">
<div class="highlight"><pre><span></span><code>&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;&lt;span z-num=&quot;123&quot;/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
</div></td>
      <td markdown="1"><div class="code-sample lang-out" title="single_constant.out" markdown="1">
<div class="highlight"><pre><span></span><code>&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;span&gt;123&lt;/span&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
</div></td>
    </tr>
  </tbody>
</table>

<p class="continue">What about a single variable?</p>
<table class="twocol">
  <tbody>
    <tr>
      <td markdown="1"><div class="code-sample lang-ht" title="single_variable.ht" markdown="1">
<div class="highlight"><pre><span></span><code>&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;&lt;span z-var=&quot;varName&quot;/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
</div></td>
      <td markdown="1"><div class="code-sample lang-out" title="single_variable.out" markdown="1">
<div class="highlight"><pre><span></span><code>&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;span&gt;varValue&lt;/span&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
</div></td>
    </tr>
  </tbody>
</table>

<p>What about a page containing multiple variables?
There&rsquo;s no reason it should fail if the single-variable case works,
but we should still check—again,
software isn&rsquo;t done until it has been tested.</p>
<table class="twocol">
  <tbody>
    <tr>
      <td markdown="1"><div class="code-sample lang-ht" title="multiple_variables.ht" markdown="1">
<div class="highlight"><pre><span></span><code>&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;&lt;span z-var=&quot;firstVariable&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span z-var=&quot;secondVariable&quot; /&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
</div></td>
      <td markdown="1"><div class="code-sample lang-out" title="multiple_variables.out" markdown="1">
<div class="highlight"><pre><span></span><code>&lt;html&gt;
&lt;body&gt;
&lt;p&gt;&lt;span&gt;UNDEF&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UNDEF&lt;/span&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
</div></td>
    </tr>
  </tbody>
</table>

<h2 id="template-flow">Section 12.5: Control Flow</h2>
<p>Our tool supports conditional expressions and loops.
Since we&rsquo;re not implementing <a class="gl-ref" href="../glossary/#gl:boolean_expression" title="An expression that is either true or false, i.e., one that produces a Boolean value." markdown="1">Boolean expressions</a> like <code>and</code> and <code>or</code>,
all we have to do for a condition is look up a variable
and then expand the node if Python thinks the variable&rsquo;s value is <a class="gl-ref" href="../glossary/#gl:truthy" title="Refers to a value that is treated as true in Boolean expressions. In Python, this includes non-empty strings and lists and numbers other than zero." markdown="1">truthy</a>:</p>
<div class="code-sample lang-py" title="z_if.py">
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;Conditionalize part of a template.&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="n">expander</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="n">check</span> <span class="o">=</span> <span class="n">expander</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;z-if&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
        <span class="n">expander</span><span class="o">.</span><span class="n">showTag</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">check</span>

<span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="n">expander</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">expander</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;z-if&quot;</span><span class="p">]):</span>
        <span class="n">expander</span><span class="o">.</span><span class="n">showTag</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Let&rsquo;s test it:</p>
<table class="twocol">
  <tbody>
      <tr>
        <td markdown="1"><div class="code-sample lang-ht" title="conditional.ht" markdown="1">
<div class="highlight"><pre><span></span><code>&lt;html&gt;
  &lt;body&gt;
    &lt;p z-if=&quot;yes&quot;&gt;Should be shown.&lt;/p&gt;
    &lt;p z-if=&quot;no&quot;&gt;Should &lt;em&gt;not&lt;/em&gt; be shown.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
</div></td>
        <td markdown="1"><div class="code-sample lang-out" title="conditional.out" markdown="1">
<div class="highlight"><pre><span></span><code>&lt;html&gt;
&lt;body&gt;
&lt;p&gt;Should be shown.&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
</div></td>
      </tr>
  </tbody>
</table>

<div class="callout">
<h3>Spot the Bug</h3>
<p>This implementation of <code>if</code> contains a subtle bug.
<code>open</code> and <code>close</code> both check the value of the control variable;
If something inside the body of the <code>if</code> changes that value,
the result could be an opening tag
without a matching <span class="ix-entry" ix-key="closing tag" markdown="1">closing tag</span> or vice versa.
We haven&rsquo;t implemented an assignment operator,
so right now there&rsquo;s no way for that to happen,
but it&rsquo;s a plausible thing for us to add later,
and tracking down a bug in old code that is revealed by new code
is always a headache.</p>
</div>
<p>Finally we have loops.
For these,
we need to get the array we&rsquo;re looping over from the environment
and do the following for each item it contains:</p>
<ol>
<li>
<p>Create a new stack frame holding the current value of the loop variable.</p>
</li>
<li>
<p>Expand all of the node&rsquo;s children with that stack frame in place.</p>
</li>
<li>
<p>Pop the stack frame to get rid of the temporary variable.</p>
</li>
</ol>
<div class="code-sample lang-py" title="z_loop.py">
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;Repeat operations.&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="n">expander</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="n">index_name</span><span class="p">,</span> <span class="n">target_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;z-loop&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
    <span class="n">expander</span><span class="o">.</span><span class="n">showTag</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">expander</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">target</span><span class="p">:</span>
        <span class="n">expander</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">push</span><span class="p">({</span><span class="n">index_name</span><span class="p">:</span> <span class="n">value</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">expander</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">expander</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="n">expander</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="n">expander</span><span class="o">.</span><span class="n">showTag</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Once again,
it&rsquo;s not done until we test it:</p>
<table class="twocol">
  <tbody>
      <tr>
        <td markdown="1"><div class="code-sample lang-ht" title="loop.ht" markdown="1">
<div class="highlight"><pre><span></span><code>&lt;html&gt;
  &lt;body&gt;
    &lt;ul z-loop=&quot;item:names&quot;&gt;
      &lt;li&gt;&lt;span z-var=&quot;item&quot;/&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
</div></td>
        <td markdown="1"><div class="code-sample lang-out" title="loop.out" markdown="1">
<div class="highlight"><pre><span></span><code>&lt;html&gt;
&lt;body&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span&gt;Johnson&lt;/span&gt;&lt;/li&gt;

&lt;li&gt;&lt;span&gt;Vaughan&lt;/span&gt;&lt;/li&gt;

&lt;li&gt;&lt;span&gt;Jackson&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div>
</div></td>
      </tr>
  </tbody>
</table>

<p>We have just implemented another simple programming language
like the one in <a class="x-ref" href="../interp/">Chapter 7</a>.
It&rsquo;s unlikely that anyone would want to use it as-is,
but adding a new feature is now as simple as writing a matching pair
of <code>open</code> and <code>close</code> functions.</p>
<h2 id="template-summary">Section 12.6: Summary</h2>
<figure id="template-concept-map" class="here">
<img src="./concept_map.svg" alt="Concept map for HTML templating"/>
<figcaption markdown="1">Figure 12.3: HTML templating concept map.</figcaption>
</figure>

<p><em>Please see <a class="x-ref" href="../bonus/">Appendix B</a> for extra material related to these ideas.</em></p>
<h2 id="template-exercises">Section 12.7: Exercises</h2>
<h3 class="exercise">Tracing Execution</h3>
<p>Add a directive <code>&lt;span z-trace="variable"/&gt;</code>
that prints the current value of a variable for debugging.</p>
<h3 class="exercise">Unit Tests</h3>
<p>Write unit tests for template expansion using <a href="https://docs.pytest.org/">pytest</a>.</p>
<h3 class="exercise">Sub-keys</h3>
<p>Modify the template expander so that a variable name like <code>person.name</code>
looks up the <code>"name"</code> value in a dictionary called <code>"person"</code>
in the current environment.</p>
<h3 class="exercise">Literal Text</h3>
<p>Add a directive <code>&lt;div z-literal="true"&gt;…&lt;/div&gt;</code> that copies the enclosed text as-is
without interpreting or expanding any contained directives.
(A directive like this would be needed when writing documentation for the template expander.)</p>
<h3 class="exercise">Including Other Files</h3>
<ol>
<li>
<p>Add a directive <code>&lt;div z-include="filename.html"/&gt;</code> that includes another file
    in the file being processed.</p>
</li>
<li>
<p>Should included files be processed and the result copied into the including file,
    or should the text be copied in and then processed?
    What difference does it make to the way variables are evaluated?</p>
</li>
</ol>
<h3 class="exercise">HTML Snippets</h3>
<p>Add a directive <code>&lt;div z-snippet="variable"&gt;…&lt;/div&gt;</code> that saves some text in a variable
so that it can be displayed later.
For example:</p>
<div class="highlight"><pre><span></span><code><span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">z-snippet</span><span class="o">=</span><span class="s">&quot;prefix&quot;</span><span class="p">&gt;&lt;</span><span class="nt">strong</span><span class="p">&gt;</span>Important:<span class="p">&lt;/</span><span class="nt">strong</span><span class="p">&gt;&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Expect three items<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">li</span> <span class="na">z-loop</span><span class="o">=</span><span class="s">&quot;item:names&quot;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">span</span> <span class="na">z-var</span><span class="o">=</span><span class="s">&quot;prefix&quot;</span><span class="p">&gt;&lt;</span><span class="nt">span</span> <span class="na">z-var</span><span class="o">=</span><span class="s">&quot;item&quot;</span><span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div>
<p class="continue">would printed the word &ldquo;Important:&rdquo; in bold before each item in the list.</p>
<h3 class="exercise">YAML Headers</h3>
<p>Modify the template expander to handle variables defined in a YAML header in the page being processed.
For example, if the page is:</p>
<div class="highlight"><pre><span></span><code>---
name: &quot;Dorothy Johnson Vaughan&quot;
---
<span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;&lt;</span><span class="nt">span</span> <span class="na">z-var</span><span class="o">=</span><span class="s">&quot;name&quot;</span><span class="p">/&gt;&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div>
<p class="continue">will create a paragraph containing the given name.</p>
<h3 class="exercise">Expanding All Files</h3>
<p>Write a program <code>expand_all.py</code> that takes two directory names as command-line arguments
and builds a website in the second directory by expanding all of the HTML files found in the first
or in sub-directories of the first.</p>
<h3 class="exercise">Counting Loops</h3>
<p>Add a directive <code>&lt;div z-index="indexName" z-limit="limitName"&gt;…&lt;/div&gt;</code>
that loops from zero to the value in the variable <code>limitName</code>,
putting the current iteration index in <code>indexName</code>.</p>
<h3 class="exercise">Boolean Expression</h3>
<p>Design and implement a way to express the Boolean operators <code>and</code> and <code>or</code>.</p>
        </main>
      </div>
    </div>
  </body>
</html>
