<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="repo" content="https://github.com/gvwilson/sdxpy">
  <meta name="build_date" content="2023-08-11">
  <meta name="template" content="default">
  <meta name="major" content="oop">
  <meta name="has_slides" content="true">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design by Example: Objects and Classes</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <img src="../logo.svg" alt="site logo" class="logo" />
  <a href="../">Software Design by Example</a>
  
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../intro/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../oop/">
      <strong>Objects and Classes</strong>
    </a>
  </li>
  
  <li>
    <a href="../dup/">
      Finding Duplicate Files
    </a>
  </li>
  
  <li>
    <a href="../glob/">
      Matching Patterns
    </a>
  </li>
  
  <li>
    <a href="../parse/">
      Parsing Text
    </a>
  </li>
  
  <li>
    <a href="../test/">
      Running Tests
    </a>
  </li>
  
  <li>
    <a href="../interp/">
      An Interpreter
    </a>
  </li>
  
  <li>
    <a href="../func/">
      Functions and Closures
    </a>
  </li>
  
  <li>
    <a href="../protocols/">
      Protocols
    </a>
  </li>
  
  <li>
    <a href="../archive/">
      A File Archiver
    </a>
  </li>
  
  <li>
    <a href="../check/">
      An HTML Validator
    </a>
  </li>
  
  <li>
    <a href="../template/">
      A Template Expander
    </a>
  </li>
  
  <li>
    <a href="../lint/">
      A Code Linter
    </a>
  </li>
  
  <li>
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li>
    <a href="../perf/">
      Performance Profiling
    </a>
  </li>
  
  <li>
    <a href="../persist/">
      Object Persistence
    </a>
  </li>
  
  <li>
    <a href="../binary/">
      Binary Data
    </a>
  </li>
  
  <li>
    <a href="../db/">
      A Database
    </a>
  </li>
  
  <li>
    <a href="../build/">
      A Build Manager
    </a>
  </li>
  
  <li>
    <a href="../pack/">
      A Package Manager
    </a>
  </li>
  
  <li>
    <a href="../ftp/">
      Transferring Files
    </a>
  </li>
  
  <li>
    <a href="../http/">
      Serving Web Pages
    </a>
  </li>
  
  <li>
    <a href="../viewer/">
      A File Viewer
    </a>
  </li>
  
  <li>
    <a href="../undo/">
      Undo and Redo
    </a>
  </li>
  
  <li>
    <a href="../vm/">
      A Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      A Debugger
    </a>
  </li>
  
  <li>
    <a href="../finale/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../bib/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../bonus/">
      Bonus Material
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contrib/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../credits/">
      Credits
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 2: Objects and Classes</h1>


          
<div class="draft notex">
  <p class="draft">
    DRAFT 2023-08-11
  </p>
  <p>
    revised 2023-07-27<br>
    Please use section heading links to submit feedback
    or go to <a href="https://github.com/gvwilson/sdxpy">https://github.com/gvwilson/sdxpy</a>.
  </p>
</div>


	  
<div class="chapterinfo">

  

  
  <ul class="syllabus">
  
  <li markdown="1">Objects are useful without classes, but classes make them easier to understand.</li>
  
  <li markdown="1">A well-designed class defines a contract that code using its instances can rely on.</li>
  
  <li markdown="1">Objects that respect the same contract are polymorphic, i.e., they can be used interchangeably even if they do different specific things.</li>
  
  <li markdown="1">Objects and classes can be thought of as dictionaries with stereotyped behavior.</li>
  
  <li markdown="1">Most programming languages allow functions and methods to take a variable number of arguments.</li>
  
  <li markdown="1">Inheritance can be implemented in several ways that differ in the order in which objects and classes are searched for methods.</li>
  
  </ul>
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  



<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#gl:alias" markdown="1">alias</a>, <a class="gl-ref" href="../glossary/#gl:argument" markdown="1">argument</a>, <a class="gl-ref" href="../glossary/#gl:cache" markdown="1">cache</a>, <a class="gl-ref" href="../glossary/#gl:class_method" markdown="1">class method</a>, <a class="gl-ref" href="../glossary/#gl:constructor" markdown="1">constructor</a>, <a class="gl-ref" href="../glossary/#gl:derived_class" markdown="1">derived class</a>, <a class="gl-ref" href="../glossary/#gl:design_by_contract" markdown="1">design by contract</a>, <a class="gl-ref" href="../glossary/#gl:monkey_patching" markdown="1">monkey patching</a>, <a class="gl-ref" href="../glossary/#gl:multiple_inheritance" markdown="1">multiple inheritance</a>, <a class="gl-ref" href="../glossary/#gl:oop" markdown="1">object-oriented programming</a>, <a class="gl-ref" href="../glossary/#gl:parameter" markdown="1">parameter</a>, <a class="gl-ref" href="../glossary/#gl:polymorphism" markdown="1">polymorphism</a>, <a class="gl-ref" href="../glossary/#gl:recursion" markdown="1">recursion</a>, <a class="gl-ref" href="../glossary/#gl:spread" markdown="1">spread</a>, <a class="gl-ref" href="../glossary/#gl:static_method" markdown="1">static method</a>, <a class="gl-ref" href="../glossary/#gl:upcall" markdown="1">upcall</a>, <a class="gl-ref" href="../glossary/#gl:varargs" markdown="1">varargs</a>
</p>


</div>


          <div class="page-toc"></div>
          <p>We are going to create a lot of <span class="ix-entry" ix-key="object" markdown="1">objects</span> and <span class="ix-entry" ix-key="class" markdown="1">classes</span> in these lessons,
and they will be a lot easier to use if we understand how they are implemented.
Historically,
<a class="gl-ref" href="../glossary/#gl:oop" title="A style of programming in which functions and data are bound together in objects that only interact with each other through well-defined interfaces." markdown="1">object-oriented programming</a> was invented to solve two problems:</p>
<ol>
<li>
<p>What is a natural way to represent real-world &ldquo;things&rdquo; in code?</p>
</li>
<li>
<p>How can we organize code to make it easier to understand, test, and extend?</p>
</li>
</ol>
<h2 id="oop-objects">Section 2.1: Objects</h2>
<p>As a motivating problem,
let&rsquo;s define some of the things a generic shape in a drawing package must be able to do:</p>
<div class="code-sample lang-py" title="shapes_original.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Shape</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;perimeter&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;area&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">A specification like this is sometimes called
a <a class="gl-ref" href="../glossary/#gl:design_by_contract" title="A style of designing software in which functions specify the pre-conditions that must be true in order for them to run and the post-conditions they guarantee will be true when they return. A function can then be replaced by one with weaker pre-conditions (i.e., it accepts a wider set of input) and/or stronger post-conditions (i.e., it produces a smaller range of output) without breaking anything else." markdown="1">contract</a>
because an object must satisfy it in order to be considered a shape,
i.e.,
must provide methods with these names that do what those names suggest.
For example,
we can <a class="gl-ref" href="../glossary/#gl:derived_class" title="In object-oriented programming, a class that is a direct or indirect extension of a base class." markdown="1">derive</a> classes from <code>Shape</code>
to represent squares and circles</p>
<div class="code-sample lang-py" title="shapes_original.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Square</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">side</span> <span class="o">=</span> <span class="n">side</span>

    <span class="k">def</span> <span class="nf">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">side</span>

    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">side</span> <span class="o">**</span> <span class="mi">2</span>

<span class="k">class</span> <span class="nc">Circle</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span>

    <span class="k">def</span> <span class="nf">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span>

    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span>
</code></pre></div>
</div>
<p>Since squares and circles have the same methods,
we can use them interchangeably.
This is called <a class="gl-ref" href="../glossary/#gl:polymorphism" title="Having many different implementations of the same interface. If a set of functions or objects are polymorphic, they can be called interchangeably." markdown="1">polymorphism</a>,
and it reduces <span class="ix-entry" ix-key="cognitive load" markdown="1">cognitive load</span>
by allowing the people using related things to ignore their differences:</p>
<div class="code-sample lang-py" title="shapes_original.py">
<div class="highlight"><pre><span></span><code><span class="n">examples</span> <span class="o">=</span> <span class="p">[</span><span class="n">Square</span><span class="p">(</span><span class="s2">&quot;sq&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">Circle</span><span class="p">(</span><span class="s2">&quot;ci&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">thing</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">thing</span><span class="o">.</span><span class="n">name</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">thing</span><span class="o">.</span><span class="n">perimeter</span><span class="p">()</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">thing</span><span class="o">.</span><span class="n">area</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> has perimeter </span><span class="si">{</span><span class="n">p</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> and area </span><span class="si">{</span><span class="n">a</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="shapes_original.out">
<div class="highlight"><pre><span></span><code>sq is a Square 12.00 12.00
ci is a Circle 12.57 12.57
</code></pre></div>
</div>
<p>But how does polymorphism work?</p>
<p>The first thing we need to understand is that a function is an <span class="ix-entry" ix-key="object" markdown="1">object</span>.
While the bytes in a string represent characters
and the bytes in an image represent pixels,
the bytes in a function are instructions
(<a class="fig-ref" href="../oop/#oop-func-obj">Figure 2.1</a>).
When Python executes the code below,
it creates an object in memory
that contains the instructions to print a string
and assigns that object to the variable <code>example</code>:</p>
<div class="code-sample lang-py" title="func_obj.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">example</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;in example&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<figure id="oop-func-obj">
<img src="./func_obj.svg" alt="Bytes as characters, pixels, or instructions"/>
<figcaption markdown="1">Figure 2.1: Bytes can be interpreted as text, images, instructions, and more.</figcaption>
</figure>

<p class="continue">We can create an <a class="gl-ref" href="../glossary/#gl:alias" title="A second or subsequent reference to the same object. Aliases are useful, but increase the cognitive load on readers who have to remember that all these names refer to the same thing." markdown="1">alias</a> for the function
by assigning it to another variable,
and then call the function by referencing that second variable.
Doing this doesn&rsquo;t alter or erase
the connection between the function and the original name:</p>
<div class="code-sample lang-py" title="func_obj.py">
<div class="highlight"><pre><span></span><code><span class="n">alias</span> <span class="o">=</span> <span class="n">example</span>
<span class="n">alias</span><span class="p">()</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="func_obj.out">
<div class="highlight"><pre><span></span><code>in example
</code></pre></div>
</div>
<p>We can also store function objects in data structures like
lists and <span class="ix-entry" ix-key="dictionary" markdown="1">dictionaries</span>.
Let&rsquo;s write some functions that do
the same things as the <span class="ix-entry" ix-key="method" markdown="1">methods</span> in our original Python
and store them in a dictionary to represent a square (<a class="fig-ref" href="../oop/#oop-shapes-dict">Figure 2.2</a>):</p>
<div class="code-sample lang-py" title="shapes_dict.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">square_perimeter</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">thing</span><span class="p">[</span><span class="s2">&quot;side&quot;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">square_area</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">thing</span><span class="p">[</span><span class="s2">&quot;side&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">square_new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
        <span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="n">side</span><span class="p">,</span>
        <span class="s2">&quot;perimeter&quot;</span><span class="p">:</span> <span class="n">square_perimeter</span><span class="p">,</span>
        <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="n">square_area</span>
    <span class="p">}</span>
</code></pre></div>
</div>
<figure id="oop-shapes-dict">
<img src="./shapes_dict.svg" alt="Storing shapes as dictionaries"/>
<figcaption markdown="1">Figure 2.2: Using dictionaries to emulate objects.</figcaption>
</figure>

<p>If we want to use one of the &ldquo;methods&rdquo; in this dictionary,
we call it like this:</p>
<div class="code-sample lang-py" title="shapes_dict.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">method_name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">thing</span><span class="p">[</span><span class="n">method_name</span><span class="p">](</span><span class="n">thing</span><span class="p">)</span>

<span class="n">examples</span> <span class="o">=</span> <span class="p">[</span><span class="n">square_new</span><span class="p">(</span><span class="s2">&quot;sq&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">circle_new</span><span class="p">(</span><span class="s2">&quot;ci&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">call</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="s2">&quot;perimeter&quot;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">call</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="s2">&quot;area&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">p</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">p</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">The function <code>call</code> looks up the function stored in the dictionary,
then calls that function with the dictionary as its first object;
in other words,
instead of using <code>obj.meth(arg)</code> we use <code>obj["meth"](obj, arg)</code>.
Behind the scenes,
this is (almost) how objects actually work.
We can think of an object as a special kind of dictionary.
A method is just a function that takes an object of the right kind
as its first <span class="ix-entry" ix-key="parameter" markdown="1">parameter</span>
(typically called <code>self</code> in Python).</p>
<h2 id="oop-classes">Section 2.2: Classes</h2>
<p>One problem with implementing objects as dictionaries is that
it allows every single object to behave slightly differently.
In practice,
we want objects to store different values
(e.g., different squares to have different sizes)
but the same behaviors
(e.g., all squares should have the same methods).
We can implement this by storing the methods in a dictionary called <code>Square</code>
that corresponds to a class,
and have each individual square contain a reference to that higher-level dictionary
(<a class="fig-ref" href="../oop/#oop-shapes-class">Figure 2.3</a>).
In the code below,
that special reference uses the key <code>"_class"</code>:</p>
<div class="code-sample lang-py" title="shapes_class.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">square_perimeter</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">thing</span><span class="p">[</span><span class="s2">&quot;side&quot;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">square_area</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">thing</span><span class="p">[</span><span class="s2">&quot;side&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>

<span class="n">Square</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;perimeter&quot;</span><span class="p">:</span> <span class="n">square_perimeter</span><span class="p">,</span>
    <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="n">square_area</span><span class="p">,</span>
    <span class="s2">&quot;_classname&quot;</span><span class="p">:</span> <span class="s2">&quot;Square&quot;</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">square_new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
        <span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="n">side</span><span class="p">,</span>
        <span class="s2">&quot;_class&quot;</span><span class="p">:</span> <span class="n">Square</span>
    <span class="p">}</span>
</code></pre></div>
</div>
<figure id="oop-shapes-class">
<img src="./shapes_class.svg" alt="Separating properties from methods"/>
<figcaption markdown="1">Figure 2.3: Using dictionaries to emulate classes.</figcaption>
</figure>

<p>Calling a method now involves one more lookup
because we have go to from the object to the class to the method,
but once again we call the &ldquo;method&rdquo; with the object as the first argument:</p>
<div class="code-sample lang-py" title="shapes_class.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">method_name</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">thing</span><span class="p">[</span><span class="s2">&quot;_class&quot;</span><span class="p">][</span><span class="n">method_name</span><span class="p">](</span><span class="n">thing</span><span class="p">)</span>

<span class="n">examples</span> <span class="o">=</span> <span class="p">[</span><span class="n">square_new</span><span class="p">(</span><span class="s2">&quot;sq&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">circle_new</span><span class="p">(</span><span class="s2">&quot;ci&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">call</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="s2">&quot;perimeter&quot;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">call</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="s2">&quot;area&quot;</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;_class&quot;</span><span class="p">][</span><span class="s2">&quot;_classname&quot;</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> is a </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">p</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">p</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">As a bonus,
we can now reliably identify objects&rsquo; classes
and ask whether two objects are of the same class or not
by checking what their <code>"_class"</code> keys refer to.</p>
<div class="callout">
<h3>Arguments vs. Parameters</h3>
<p>Many programmers use the words <a class="gl-ref" href="../glossary/#gl:argument" title="A value passed into a function or method call." markdown="1">argument</a>
and <a class="gl-ref" href="../glossary/#gl:parameter" title="The name that a function gives to one of the values passed to it when it is called." markdown="1">parameter</a> interchangeably,
but to make our meaning clear,
we call the values passed into a function its arguments
and the names the function uses to refer to them as its parameters.
Put it another way,
parameters are part of the definition
and arguments are given when the function is called.</p>
</div>
<h2 id="oop-args">Section 2.3: Arguments</h2>
<p>The methods we have defined so far operate on
the values stored in the object&rsquo;s dictionary,
but none of them take any extra arguments as input.
Implementing this is a little bit tricky
because different methods might need different numbers of arguments.
We could define functions <code>call_0</code>, <code>call_1</code>, <code>call_2</code> and so on
to handle each case,
but like most modern languages,
Python gives us a better way.
If we define a parameter in a function with a leading <code>*</code>,
it captures any &ldquo;extra&rdquo; values passed to the function
that don&rsquo;t line up with named parameters.
Similarly,
if we define a parameter with two leading stars <code>**</code>,
it captures any extra named parameters:</p>
<div class="code-sample lang-py" title="varargs.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">show_args</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s2"> args &#39;</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">&#39; and kwargs &#39;</span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

<span class="n">show_args</span><span class="p">(</span><span class="s2">&quot;nothing&quot;</span><span class="p">)</span>
<span class="n">show_args</span><span class="p">(</span><span class="s2">&quot;one unnamed argument&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">show_args</span><span class="p">(</span><span class="s2">&quot;one named argument&quot;</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="s2">&quot;2&quot;</span><span class="p">)</span>
<span class="n">show_args</span><span class="p">(</span><span class="s2">&quot;one of each&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">fourth</span><span class="o">=</span><span class="s2">&quot;4&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="varargs.out">
<div class="highlight"><pre><span></span><code>nothing args &#39;()&#39; and kwargs &#39;{}&#39;
one unnamed argument args &#39;(1,)&#39; and kwargs &#39;{}&#39;
one named argument args &#39;()&#39; and kwargs &#39;{&#39;second&#39;: &#39;2&#39;}&#39;
one of each args &#39;(3,)&#39; and kwargs &#39;{&#39;fourth&#39;: &#39;4&#39;}&#39;
direct args &#39;([7, 8], {&#39;nine&#39;: 9, &#39;ten&#39;: 10})&#39; and kwargs &#39;{}&#39;
spreading args &#39;(7, 8)&#39; and kwargs &#39;{&#39;nine&#39;: 9, &#39;ten&#39;: 10}&#39;
</code></pre></div>
</div>
<p>This mechanism is sometimes referred to as <a class="gl-ref" href="../glossary/#gl:varargs" title="Short for &quot;variable arguments&quot;, a mechanism that captures any &quot;extra&quot; arguments to a function or method." markdown="1">varargs</a>
(short for &ldquo;variable arguments&rdquo;).
A complementary mechanism called <a class="gl-ref" href="../glossary/#gl:spread" title="To automatically match the values from a list or dictionary supplied by the caller to the parameters of a function." markdown="1">spreading</a>
allows us to take a list or dictionary full of arguments
and spread them out in a call to match a function&rsquo;s parameters:</p>
<div class="code-sample lang-py" title="spread.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">show_spread</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">middle</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;left </span><span class="si">{</span><span class="n">left</span><span class="si">}</span><span class="s2"> middle </span><span class="si">{</span><span class="n">middle</span><span class="si">}</span><span class="s2"> right </span><span class="si">{</span><span class="n">right</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">all_in_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">show_spread</span><span class="p">(</span><span class="o">*</span><span class="n">all_in_list</span><span class="p">)</span>

<span class="n">all_in_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;middle&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span>
<span class="n">show_spread</span><span class="p">(</span><span class="o">**</span><span class="n">all_in_dict</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="spread.out">
<div class="highlight"><pre><span></span><code>left 1 middle 2 right 3
left 10 middle 20 right 30
</code></pre></div>
</div>
<p>With these tools in hand,
let&rsquo;s add a method to our <code>Square</code> class
to tell us whether a square is larger than a user-specified size:</p>
<div class="code-sample lang-py" title="larger.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">square_larger</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">call</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="s2">&quot;area&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span>

<span class="n">Square</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;perimeter&quot;</span><span class="p">:</span> <span class="n">square_perimeter</span><span class="p">,</span>
    <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="n">square_area</span><span class="p">,</span>
    <span class="s2">&quot;larger&quot;</span><span class="p">:</span> <span class="n">square_larger</span><span class="p">,</span>
    <span class="s2">&quot;_classname&quot;</span><span class="p">:</span> <span class="s2">&quot;Square&quot;</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p class="continue">The function that implements this check for circles
looks exactly the same:</p>
<div class="code-sample lang-py" title="larger.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">circle_larger</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">call</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="s2">&quot;area&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span>
</code></pre></div>
</div>
<p class="continue">We then modify <code>call</code> to capture extra arguments in <code>*args</code>
and spread them into the function being called:</p>
<div class="code-sample lang-py" title="larger.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">thing</span><span class="p">[</span><span class="s2">&quot;_class&quot;</span><span class="p">][</span><span class="n">method_name</span><span class="p">](</span><span class="n">thing</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Our tests show that this works:</p>
<div class="code-sample lang-py" title="larger.py">
<div class="highlight"><pre><span></span><code><span class="n">examples</span> <span class="o">=</span> <span class="p">[</span><span class="n">square_new</span><span class="p">(</span><span class="s2">&quot;sq&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">circle_new</span><span class="p">(</span><span class="s2">&quot;ci&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">call</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="s2">&quot;larger&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;is </span><span class="si">{</span><span class="n">ex</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> larger? </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="larger.out">
<div class="highlight"><pre><span></span><code>is sq larger? False
is ci larger? True
</code></pre></div>
</div>
<p class="continue">However,
we now have two functions that do exactly the same thingâ€”the
only difference between them is their names.
Anything in a program that is duplicated in several places
will eventually be wrong in at least one,
so we need to find some way to share this code.</p>
<h2 id="oop-inheritance">Section 2.4: Inheritance</h2>
<p>The tool we want is <span class="ix-entry" ix-key="inheritance" markdown="1">inheritance</span>.
To see how this works in Python,
let&rsquo;s add a method called <code>density</code> to our original <code>Shape</code> class
that uses other methods defined by the class</p>
<div class="code-sample lang-py" title="inherit_original.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Shape</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;perimeter&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;area&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">weight</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">area</span><span class="p">()</span>
</code></pre></div>
</div>
<div class="code-sample lang-py" title="inherit_original.py">
<div class="highlight"><pre><span></span><code><span class="n">examples</span> <span class="o">=</span> <span class="p">[</span><span class="n">Square</span><span class="p">(</span><span class="s2">&quot;sq&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">Circle</span><span class="p">(</span><span class="s2">&quot;ci&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">name</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">density</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">d</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="inherit_original.out">
<div class="highlight"><pre><span></span><code>sq: 0.56
ci: 0.40
</code></pre></div>
</div>
<p>To enable our dictionary-based &ldquo;classes&rdquo; to do the same thing,
we create a dictionary to represent a generic shape
and give it a &ldquo;method&rdquo; to calculate density:</p>
<div class="code-sample lang-py" title="inherit_class.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">shape_density</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">call</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="s2">&quot;area&quot;</span><span class="p">)</span>

<span class="n">Shape</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;density&quot;</span><span class="p">:</span> <span class="n">shape_density</span><span class="p">,</span>
    <span class="s2">&quot;_classname&quot;</span><span class="p">:</span> <span class="s2">&quot;Shape&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_parent&quot;</span><span class="p">:</span> <span class="kc">None</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p>We then add another specially-named field to
the dictionaries for &ldquo;classes&rdquo; like <code>Square</code>
to keep track of their parents:</p>
<div class="code-sample lang-py" title="inherit_class.py">
<div class="highlight"><pre><span></span><code><span class="n">Square</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;perimeter&quot;</span><span class="p">:</span> <span class="n">square_perimeter</span><span class="p">,</span>
    <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="n">square_area</span><span class="p">,</span>
    <span class="s2">&quot;_classname&quot;</span><span class="p">:</span> <span class="s2">&quot;Square&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_parent&quot;</span><span class="p">:</span> <span class="n">Shape</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p class="continue">and modify the <code>call</code> function to search for
the requested method (<a class="fig-ref" href="../oop/#oop-inherit-class">Figure 2.4</a>):</p>
<div class="code-sample lang-py" title="inherit_class.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">thing</span><span class="p">[</span><span class="s2">&quot;_class&quot;</span><span class="p">],</span> <span class="n">method_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="bp">cls</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">[</span><span class="n">method_name</span><span class="p">]</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">[</span><span class="s2">&quot;_parent&quot;</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;method_name&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<figure id="oop-inherit-class">
<img src="./inherit_class.svg" alt="Implementing inheritance"/>
<figcaption markdown="1">Figure 2.4: Using dictionary search to implement inheritance.</figcaption>
</figure>

<p>A simple test shows that this is working as intended:</p>
<div class="code-sample lang-py" title="inherit_class.py">
<div class="highlight"><pre><span></span><code><span class="n">examples</span> <span class="o">=</span> <span class="p">[</span><span class="n">square_new</span><span class="p">(</span><span class="s2">&quot;sq&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">circle_new</span><span class="p">(</span><span class="s2">&quot;ci&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">call</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">d</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="inherit_class.out">
<div class="highlight"><pre><span></span><code>sq: 0.56
ci: 0.40
</code></pre></div>
</div>
<p>We do have one task left, though:
we need to make sure that when a square or circle is made,
it is made correctly.
In short, we need to implement <a class="gl-ref" href="../glossary/#gl:constructor" title="A function that creates an object of a particular class." markdown="1">constructors</a>.
We do this by giving the dictionaries that implements classes
a special key <code>_new</code>
whose value is the function that builds something of that type:</p>
<div class="code-sample lang-py" title="inherit_constructor.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">shape_new</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
        <span class="s2">&quot;_class&quot;</span><span class="p">:</span> <span class="n">Shape</span>
    <span class="p">}</span>

<span class="n">Shape</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;density&quot;</span><span class="p">:</span> <span class="n">shape_density</span><span class="p">,</span>
    <span class="s2">&quot;_classname&quot;</span><span class="p">:</span> <span class="s2">&quot;Shape&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_parent&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="s2">&quot;_new&quot;</span><span class="p">:</span> <span class="n">shape_new</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p class="continue">In order to make an object,
we call the function associated with its <code>_new</code> key:</p>
<div class="code-sample lang-py" title="inherit_constructor.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">make</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">[</span><span class="s2">&quot;_new&quot;</span><span class="p">](</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">That function is responsible for <a class="gl-ref" href="../glossary/#gl:upcall" title="The act of explicitly invoking a method of a parent class from inside a child class. A method in a child class may upcall to the corresponding method in the parent class as parent of extending that method." markdown="1">upcalling</a>
the constructor of its parent.
For example,
the constructor for a square calls the constructor for a generic shape
and adds square-specific values using <code>|</code> to combine two dictionaries:</p>
<div class="code-sample lang-py" title="inherit_constructor.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">square_new</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">make</span><span class="p">(</span><span class="n">Shape</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">|</span> <span class="p">{</span>
        <span class="s2">&quot;side&quot;</span><span class="p">:</span> <span class="n">side</span><span class="p">,</span>
        <span class="s2">&quot;_class&quot;</span><span class="p">:</span> <span class="n">Square</span>
    <span class="p">}</span>

<span class="n">Square</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;perimeter&quot;</span><span class="p">:</span> <span class="n">square_perimeter</span><span class="p">,</span>
    <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="n">square_area</span><span class="p">,</span>
    <span class="s2">&quot;_classname&quot;</span><span class="p">:</span> <span class="s2">&quot;Square&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_parent&quot;</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span>
    <span class="s2">&quot;_new&quot;</span><span class="p">:</span> <span class="n">square_new</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p>Of course,
we&rsquo;re not done until we test it:</p>
<div class="code-sample lang-py" title="inherit_constructor.py">
<div class="highlight"><pre><span></span><code><span class="n">examples</span> <span class="o">=</span> <span class="p">[</span><span class="n">make</span><span class="p">(</span><span class="n">Square</span><span class="p">,</span> <span class="s2">&quot;sq&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">make</span><span class="p">(</span><span class="n">Circle</span><span class="p">,</span> <span class="s2">&quot;ci&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ex</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">call</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="s2">&quot;density&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">d</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="inherit_constructor.out">
<div class="highlight"><pre><span></span><code>sq: 0.56
ci: 0.40
</code></pre></div>
</div>
<h2 id="oop-summary">Section 2.5: Summary</h2>
<p>We have only scratched the surface of Python&rsquo;s object system.
<a class="gl-ref" href="../glossary/#gl:multiple_inheritance" title="Inheriting from two or more classes when creating a new class." markdown="1">Multiple inheritance</a>,
<a class="gl-ref" href="../glossary/#gl:class_method" title="A function defined inside a class that takes the class object as an input rather than an instance of the class." markdown="1">class methods</a>,
<a class="gl-ref" href="../glossary/#gl:static_method" title="A function that is defined within a class but does not require either the class itself or an instance of the class as a parameter." markdown="1">static methods</a>,
and <a class="gl-ref" href="../glossary/#gl:monkey_patching" title="To replace methods in a class or object at run-time without modifying the original code." markdown="1">monkey patching</a>
are powerful tools,
but they can all be understood in terms of dictionaries
that contain references to properties, functions, and other dictionaries.</p>
<figure id="oop-concept-map" class="here">
<img src="./concept_map.svg" alt="Concept map for objects and classes"/>
<figcaption markdown="1">Figure 2.5: Concept map for implementing objects and classes.</figcaption>
</figure>

<h2 id="oop-exercises">Section 2.6: Exercises</h2>
<h3 class="exercise">Handling Named Arguments</h3>
<p>The final version of <code>call</code> declares a parameter called <code>*args</code>
to capture all the positional parameters of the method being called
and then spreads them in the actual call.
Modify it to capture and spread named parameters as well.</p>
<h3 class="exercise">Multiple Inheritance</h3>
<p>Implement multiple inheritance using dictionaries.
Does your implementation look methods up in the same order as Python would?</p>
<h3 class="exercise">Class Methods and Static Methods</h3>
<ol>
<li>
<p>Explain the differences between class methods and static methods.</p>
</li>
<li>
<p>Implement both using dictionaries.</p>
</li>
</ol>
<h3 class="exercise">Reporting Type</h3>
<p>Python <code>type</code> method reports the most specific type of an object,
while <code>isinstance</code> determines whether an object inherits from a type
either directly or indirectly.
Add your own versions of both to dictionary-based objects and classes.</p>
<h3 class="exercise">Using Recursion</h3>
<p>A <a class="gl-ref" href="../glossary/#gl:recursion" title="To define something in terms of itself, or the act of a function invoking itself (directly or indirectly)." markdown="1">recursive function</a>
is one that calls itself,
either directly or indirectly.
Modify the <code>find</code> function that finds a method to call
so that it uses recursion instead of a loop.
Which version is easier to understand?
Which version is more efficient?</p>
<h3 class="exercise">Method Caching</h3>
<p>Our implementation searches for the implementation of a method
every time that method is called.
An alternative is to add a <a class="gl-ref" href="../glossary/#gl:cache" title="Something that stores copies of data so that future requests for it can be satisfied more quickly. The CPU in a computer uses a hardware cache to hold recently-accessed values; many programs rely on a software cache to reduce network traffic and latency. Figuring out when something in a cache is out-of-date and should be replaced is one of the two hard problems in computer science." markdown="1">cache</a> to each object
to save the methods that have been looked up before.
For example,
each object could have a special key called <code>_cache</code> whose value is a dictionary.
The keys in that dictionary are the names of methods that have been called in the past,
and the values are the functions that were found to implement those methods.
Add this feature to our dictionary-based objects.
How much more complex does it make the code?
How much extra storage space does it need compared to repeated lookup?</p>
        </main>
      </div>
    </div>
  </body>
</html>
