<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="logo.svg">
<link rel="stylesheet" href="tango.css" type="text/css">
<link rel="stylesheet" href="mccole.css" type="text/css">
<title>Software Design by Example</title>
<script>
  MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)']]
    }
  };
</script>
<script
  type="text/javascript"
  id="MathJax-script"
  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


  </head>
  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <a href="https://www.routledge.com/Software-Design-by-Example-A-Tool-Based-Introduction-with-Python/Wilson/p/book/9781032725215"><img src="sdxpy-cover.png" alt="Book cover" class="bookcover" /></a>
  
</p>

<div class="screen-reader-only">
  <a href="#printable">Skip to content</a>
</div>

<ol class="toc-chapters"><li><a href="intro/">Introduction</a></li><li><a href="oop/">Objects and Classes</a></li><li><a href="dup/">Finding Duplicate Files</a></li><li><a href="glob/">Matching Patterns</a></li><li><a href="parse/">Parsing Text</a></li><li><a href="test/">Running Tests</a></li><li><a href="interp/">An Interpreter</a></li><li><a href="func/">Functions and Closures</a></li><li><a href="protocols/">Protocols</a></li><li><a href="archive/">A File Archiver</a></li><li><a href="check/">An HTML Validator</a></li><li><a href="template/">A Template Expander</a></li><li><a href="lint/">A Code Linter</a></li><li><a href="layout/">Page Layout</a></li><li><a href="perf/">Performance Profiling</a></li><li><a href="persist/">Object Persistence</a></li><li><a href="binary/">Binary Data</a></li><li><a href="db/">A Database</a></li><li><a href="build/">A Build Manager</a></li><li><a href="pack/">A Package Manager</a></li><li><a href="ftp/">Transferring Files</a></li><li><a href="http/">Serving Web Pages</a></li><li><a href="viewer/">A File Viewer</a></li><li><a href="undo/">Undo and Redo</a></li><li><a href="vm/">A Virtual Machine</a></li><li><a href="debugger/">A Debugger</a></li><li><a href="observe/">Observers</a></li><li><a href="docgen/">Generating Documentation</a></li><li><a href="search/">Search</a></li><li><a href="compress/">File Compression</a></li><li><a href="cache/">A File Cache</a></li><li><a href="query/">A Query Builder</a></li><li><a href="concur/">Concurrency</a></li><li><a href="finale/">Conclusion</a></li></ol>
<ol class="toc-appendices"><li><a href="bib/">Bibliography</a></li><li><a href="bonus/">Bonus Material</a></li><li><a href="syllabus/">Syllabus</a></li><li><a href="license/">License</a></li><li><a href="conduct/">Code of Conduct</a></li><li><a href="contrib/">Contributing</a></li><li><a href="glossary/">Glossary</a></li><li><a href="colophon/">Colophon</a></li><li><a href="contents/">Index</a></li></ol>


<p><a href="sdxpy-examples.zip" type="application/zip">download examples</a></p>


<p><a href="https://github.com/gvwilson/sdxpy">GitHub repository</a></p>

      </div>
      <div id="printable" class="contents bordered">
	<main>
	  <div class="row notex">
  <div class="col-12 center">
    
      <h1>Software Design by Example</h1>
      <p class="subtitle">a tool-based introduction with Python</p>
    
  </div>
</div>

	  

	  
	  
	  <p>The best way to learn design in any field is to study examples,
and the most approachable examples are ones that readers are already familiar with.
These lessons therefore build small versions
of tools that programmers use every day
to show how experienced software designers think.
Along the way,
they introduce some fundamental ideas in computer science
that many self-taught programmers haven&rsquo;t encountered.
We hope these lessons will help you design better software yourself,
and that if you know how programming tools work,
you&rsquo;ll be more likely to use them
and better able to use them well.</p>
<p>Help of all kinds is welcome—we are very grateful for the following:</p>
<ol>
<li>
<p>Fixes for mistakes in the code, the descriptions, or the formatting.
    All of the examples run and all of the tests pass,
    that doesn&rsquo;t guarantee they&rsquo;re correct.</p>
</li>
<li>
<p>Reports of continuity errors,
    e.g.,
    places where a concept is used before it is explained.</p>
</li>
<li>
<p>Suggestions for new diagrams, or for ways to improve existing ones.</p>
</li>
<li>
<p>New or clearer summary points for each chapter&rsquo;s syllabus.</p>
</li>
<li>
<p>More or better exercises.
    &ldquo;This is too hard&rdquo; or &ldquo;this is unclear&rdquo; helps as well.</p>
</li>
</ol>
<p>Please see <a href="contrib/">Appendix&nbsp;F</a> for more details.</p>
<h2>Contents</h2>
<p><strong><a href="intro/">Chapter 1: Introduction</a>.</strong>
The best way to learn design is to study examples, and the best programs to use as examples are the ones programmers use every day. These lessons therefore build small versions of tools that programmers use every day to show how experienced software designers think. Along the way, they introduce some fundamental ideas in computer science that many self-taught programmers haven&rsquo;t encountered. The lessons assume readers can write small programs and want to write larger ones, or are looking for material to use in software design classes that they teach.</p>
<p><strong><a href="oop/">Chapter 2: Objects and Classes</a>.</strong>
Object-oriented programming was invented to solve two problems: what is a natural way to represent real-world &ldquo;things&rdquo; in code, and how can we organize that code so that it&rsquo;s easiser to understand, test, and extend? This chapter shows how object-oriented systems solve those problems by implementing a very simple object system using simpler data structures.</p>
<p><strong><a href="dup/">Chapter 3: Finding Duplicate Files</a>.</strong>
The naïve way to find duplicated files is to compare each file to all the others, but that is unworkably slow for large sets of files. A better approach is to generate a short label that depends only on the file&rsquo;s contents so that we only need to compare files with the same label. This idea is the basis of many real-world applications, including the cryptographic systems used for secure online communication.</p>
<p><strong><a href="glob/">Chapter 4: Matching Patterns</a>.</strong>
Pattern matching is ubiquitous in computer programs. Whether we are selecting a set of files to open or finding names and email addresses inside those files, we need an efficient way to find matches for complex patterns. This chapter therefore implements the filename matching used in the Unix shell to show how more complicated tools like regular expressions works.</p>
<p><strong><a href="parse/">Chapter 5: Parsing Text</a>.</strong>
A parser turns text that&rsquo;s easy for a human being to read into a data structure that a computer can work with. The complete parser for a language like Python can be very complex, but this chapter illustrates the key ideas by building a parser for the simple filename matching patterns implemented in the previous chapter.</p>
<p><strong><a href="test/">Chapter 6: Running Tests</a>.</strong>
Every programming language has tools to collect tests, run them, and report their results. This chapter shows how such tools are built, both to help programmers use them more effectively, and to illustrate the single most important idea in this book: that programs are just another kind of data.</p>
<p><strong><a href="interp/">Chapter 7: An Interpreter</a>.</strong>
A program in memory is just a data structure, each of whose elements triggers some operation in the interpreter that&rsquo;s executing it. This chapter builds a very simple interpreter to show how this process works, and to show that we can evaluate the quality of a program&rsquo;s design by asking how extensible it is.</p>
<p><strong><a href="func/">Chapter 8: Functions and Closures</a>.</strong>
This chapter extends the little interpreter of the previous one to allow users to define functions of their own. By doing so, it shows that the way programs handle variable scope is a design choice, and that the use of a particular technique called closures enables programs written in Python (and other modern programming languages) to encapsulate information in useful ways.</p>
<p><strong><a href="protocols/">Chapter 9: Protocols</a>.</strong>
This chapter starts by showing how we can simplify testing by temporarily replacing real functions with ones that return predictable values, then uses our need to do that to motivate discussion of ways that programmers can hook their own code into the Python interpreter. Unlike other chapters in this book, this one focuses on Python itself rather than the things we can build with it.</p>
<p><strong><a href="archive/">Chapter 10: A File Archiver</a>.</strong>
Most programmers would agree that once they have a text editor and a way to run their programs, the next tool they need is version control. This chapter therefore shows how the core of a simple version control system works by building a file archiver that avoids creating duplicate copies of the same files.</p>
<p><strong><a href="check/">Chapter 11: An HTML Validator</a>.</strong>
This chapter builds a tool to check the structure of web pages in order to show how programs can process HTML, and to introduce a design pattern that is frequently used to manage irregular data structures.</p>
<p><strong><a href="template/">Chapter 12: A Template Expander</a>.</strong>
Writing and updating HTML pages by hand is time-consuming and error-prone, so most modern websites use some kind of static site generator (SSG) to create pages from templates. This chapter builds a simple SSG to show how they work and to reinforce earlier lessons about creating little programming languages.</p>
<p><strong><a href="lint/">Chapter 13: A Code Linter</a>.</strong>
This chapter brings together pieces from the preceding few lessons to show how one program can check the structure of another. Tools that do this, called linters, rely once again on the fact that programs are just another kind of data.</p>
<p><strong><a href="layout/">Chapter 14: Page Layout</a>.</strong>
Browsers, e-book readers, and text editors all rely on some kind of layout engine that takes text and formatting instructions as input and decides where to put each character and image. To explore how they work, this chapter builds a small HTML layout engine, and in doing so, introduces some useful ideas about recursion and multiple inheritance.</p>
<p><strong><a href="perf/">Chapter 15: Performance Profiling</a>.</strong>
This chapter implements the kind of multi-column table frequently used in data science in two different ways in order to reinforce earlier ideas about the value of abstraction and to show how systematic performance testing can be used to decide between different implementation strategies.</p>
<p><strong><a href="persist/">Chapter 16: Object Persistence</a>.</strong>
Some simple kinds of data can be saved as lines of text, but more complex data structures require a framework capable of handling aliasing and circularity. This chapter shows how to build such a framework, and in doing so demonstrates how libraries for handling JSON and other formats work.</p>
<p><strong><a href="binary/">Chapter 17: Binary Data</a>.</strong>
Python and other high-level languages shield programmers from the low-level details of how computers actually store and manipulate data, but sooner or later someone has to worry about bits and bytes. This chapter explores how computers represent numbers and text and shows how to work with data at this level.</p>
<p><strong><a href="db/">Chapter 18: A Database</a>.</strong>
Almost every real-world application relies on some kind of database that allows code to look up data without loading everything into memory. To show how they work, this chapter builds a very simple database that appends every new copy of a record to a running log of operations.</p>
<p><strong><a href="build/">Chapter 19: A Build Manager</a>.</strong>
Programmers frequently need to chain operations together so that if one file is updated, everything that depends on it is also updated, and then things that depend on them are updated as well. This chapter builds a simple build manager to show how such tools work, and to introduce some fundamental algorithms on directed graphs.</p>
<p><strong><a href="pack/">Chapter 20: A Package Manager</a>.</strong>
Most languages have an online archive from which people can download packages, each of which has a name, one or more versions, and a list of dependencies. In order to install a package, we need to figure out exactly what versions of its dependencies to install; this chapter explores how to find a workable installation or prove that there isn&rsquo;t one.</p>
<p><strong><a href="ftp/">Chapter 21: Transferring Files</a>.</strong>
A typical web application is made up of clients that send messages to servers and then wait for them to respond. This chapter shows how they work at a low level by building a simple low-level client-server program to move files from one machine to another.</p>
<p><strong><a href="http/">Chapter 22: Serving Web Pages</a>.</strong>
The Hypertext Transfer Protocol (HTTP) defines a way for programs to exchange data over the web. Clients (such as browsers) send requests to servers, which respond by copying files from disk, pulling records from a database, or in any of dozens of other ways. This chapter shows how to build a simple web server that understands the basics of HTTP and how to test programs of this kind.</p>
<p><strong><a href="viewer/">Chapter 23: A File Viewer</a>.</strong>
Even simple editors like Notepad and Nano do a lot of things: moving a cursor, inserting and deleting characters, and more. This is too much to fit into one lesson, so this chapter builds a tool for viewing files, which the next chapters extends to create an editor with undo and redo.</p>
<p><strong><a href="undo/">Chapter 24: Undo and Redo</a>.</strong>
Viewing text files is useful, but we&rsquo;d like to be able to edit them as well. This chapter therefore modifies the file viewer of the preceding chapter so that we can add and delete text. And since people make mistakes, it also implements undo, which introduces another commonly-used design pattern.</p>
<p><strong><a href="vm/">Chapter 25: A Virtual Machine</a>.</strong>
The standard version of Python is implemented in C, but C is compiled to instructions for a particular processor. To show how that lower layer works, this chapter builds a simulator of a small computer and an assembler for a very simple language that can be used to program it.</p>
<p><strong><a href="debugger/">Chapter 26: A Debugger</a>.</strong>
Debuggers are as much a part of good programmers&rsquo; working lives as version control but are taught far less often. This chapter therefore builds a simple single-stepping debugger for the virtual machine of the previous chapter and shows how we can test it and other interactive applications.</p>
<p><strong><a href="finale/">Chapter 27: Conclusion</a>.</strong>
We have long accepted that software can and should be critiqued by asking if it does what it&rsquo;s supposed to do and if it&rsquo;s pleasurable to use. What is often missing is the question of whether its design facilitated its manufacture and maintenance. We hope that this book has helped you move one step closer to being able to ask and answer that question about the things you build.</p>
<h2>Dedication</h2>
<div class="center">
<p><em>This one&rsquo;s for Mike and Jon: I&rsquo;m glad you always found time to chat.</em></p>
</div>
<h2>About the Author</h2>
<p><strong>Greg Wilson</strong> has worked in industry and academia for 35 years
and is the author, co-author, or editor of several books,
including <em>Beautiful Code</em>,
<em>The Architecture of Open Source Applications</em>,
<em>JavaScript for Data Science</em>,
<em>Teaching Tech Together</em>,
and <em>Research Software Engineering with Python</em>.
He was the co-founder and first Executive Director of Software Carpentry
and received ACM SIGSOFT&rsquo;s Influential Educator Award in 2020.</p>
	</main>
	<footer>
  © 2025 <a href="https://third-bit.com/">Greg Wilson</a>
  &middot;
  <a href="#">home</a>
  &middot;
  <a href="https://github.com/gvwilson/sdxpy">repository</a>
  &middot;
  <a href="license/">license</a>
  &middot;
  <a href="mailto:gvwilson@third-bit.com">contact</a>
</footer>

      </div>
    </div>
  </body>
</html>
