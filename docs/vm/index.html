<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="repo" content="https://github.com/gvwilson/sdxpy">
  <meta name="build_date" content="2023-09-23">
  <meta name="template" content="default">
  <meta name="major" content="vm">
  <meta name="has_slides" content="true">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design by Example: A Virtual Machine</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <img src="../logo.svg" alt="site logo" class="logo" />
  <a href="../">Software Design by Example</a>
  
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../intro/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../oop/">
      Objects and Classes
    </a>
  </li>
  
  <li>
    <a href="../dup/">
      Finding Duplicate Files
    </a>
  </li>
  
  <li>
    <a href="../glob/">
      Matching Patterns
    </a>
  </li>
  
  <li>
    <a href="../parse/">
      Parsing Text
    </a>
  </li>
  
  <li>
    <a href="../test/">
      Running Tests
    </a>
  </li>
  
  <li>
    <a href="../interp/">
      An Interpreter
    </a>
  </li>
  
  <li>
    <a href="../func/">
      Functions and Closures
    </a>
  </li>
  
  <li>
    <a href="../protocols/">
      Protocols
    </a>
  </li>
  
  <li>
    <a href="../archive/">
      A File Archiver
    </a>
  </li>
  
  <li>
    <a href="../check/">
      An HTML Validator
    </a>
  </li>
  
  <li>
    <a href="../template/">
      A Template Expander
    </a>
  </li>
  
  <li>
    <a href="../lint/">
      A Code Linter
    </a>
  </li>
  
  <li>
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li>
    <a href="../perf/">
      Performance Profiling
    </a>
  </li>
  
  <li>
    <a href="../persist/">
      Object Persistence
    </a>
  </li>
  
  <li>
    <a href="../binary/">
      Binary Data
    </a>
  </li>
  
  <li>
    <a href="../db/">
      A Database
    </a>
  </li>
  
  <li>
    <a href="../build/">
      A Build Manager
    </a>
  </li>
  
  <li>
    <a href="../pack/">
      A Package Manager
    </a>
  </li>
  
  <li>
    <a href="../ftp/">
      Transferring Files
    </a>
  </li>
  
  <li>
    <a href="../http/">
      Serving Web Pages
    </a>
  </li>
  
  <li>
    <a href="../viewer/">
      A File Viewer
    </a>
  </li>
  
  <li>
    <a href="../undo/">
      Undo and Redo
    </a>
  </li>
  
  <li>
    <a href="../vm/">
      <strong>A Virtual Machine</strong>
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      A Debugger
    </a>
  </li>
  
  <li>
    <a href="../finale/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../bib/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../bonus/">
      Bonus Material
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contrib/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../credits/">
      Credits
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>

<p><a href="https://github.com/gvwilson/sdxpy">GitHub repository</a></p>

      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 25: A Virtual Machine</h1>


          

	  
<div class="chapterinfo">

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
  <ul class="syllabus">
  
  <li markdown="1">Every computer has a processor with a particular instruction set, some registers, and memory.</li>
  
  <li markdown="1">Instructions are just numbers, but may be represented as assembly code.</li>
  
  <li markdown="1">Instructions may refer to registers, memory, both, or neither.</li>
  
  <li markdown="1">A processor usually executes instructions in order, but may jump to another location based on whether a conditional is true or false.</li>
  
  </ul>
  

  



<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#gl:abi" markdown="1">Application Binary Interface</a>, <a class="gl-ref" href="../glossary/#gl:assembler" markdown="1">assembler</a>, <a class="gl-ref" href="../glossary/#gl:assembly_code" markdown="1">assembly code</a>, <a class="gl-ref" href="../glossary/#gl:bytecode" markdown="1">bytecode</a>, <a class="gl-ref" href="../glossary/#gl:conditional_jump" markdown="1">conditional jump</a>, <a class="gl-ref" href="../glossary/#gl:disassembler" markdown="1">disassembler</a>, <a class="gl-ref" href="../glossary/#gl:instruction_pointer" markdown="1">instruction pointer</a>, <a class="gl-ref" href="../glossary/#gl:instruction_set" markdown="1">instruction set</a>, <a class="gl-ref" href="../glossary/#gl:label_address" markdown="1">label (of address in memory)</a>, <a class="gl-ref" href="../glossary/#gl:op_code" markdown="1">op code</a>, <a class="gl-ref" href="../glossary/#gl:register_hardware" markdown="1">register (in hardware)</a>, <a class="gl-ref" href="../glossary/#gl:virtual_machine" markdown="1">virtual machine</a>, <a class="gl-ref" href="../glossary/#gl:word_memory" markdown="1">word (of memory)</a>
</p>


</div>


          <div class="page-toc"></div>
          <p>The interpreter in <a class="x-ref" href="../interp/">Chapter 7</a> relied on Python to do
most of the actual work.
The standard version of Python is implemented in C,
and relies on C&rsquo;s operators to add numbers, index arrays, and so on,
but C is compiled to instructions for a particular processor.
Each operation in the little language of <a class="x-ref" href="../interp/">Chapter 7</a>
is therefore expanded by several layers of software
to become something that hardware can actually run.
To show how that lower layer works,
this chapter builds a simulator of a small computer.
If you want to dive deeper into programming at this level,
have a look at the game <span class="ix-entry" ix-key="Human Resource Machine" markdown="1"><a href="https://tomorrowcorporation.com/humanresourcemachine">Human Resource Machine</a></span>.</p>
<h2 id="vm-arch">Section 25.1: Architecture</h2>
<p>Our <a class="gl-ref" href="../glossary/#gl:virtual_machine" title="A program that pretends to be a computer. This may seem a bit redundant, but VMs are quick to create and start up, and changes made inside the virtual machine are contained within that VM so we can install new packages or run a completely different operating system without affecting the underlying computer." markdown="1">virtual machine</a>
simulates a computer with three parts (<a class="fig-ref" href="../vm/#vm-architecture">Figure 25.1</a>):</p>
<ol>
<li>
<p>The <a class="gl-ref" href="../glossary/#gl:instruction_pointer" title="A special register in a processor that stores the address of the next instruction to execute." markdown="1">instruction pointer</a> (IP)
    holds the memory address of the next instruction to execute.
    It is automatically initialized to point at address 0,
    so that is where every program must start.
    This requirement is part of our VM&rsquo;s
    <a class="gl-ref" href="../glossary/#gl:abi" title="The low-level layout that a piece of software must have to work on a particular kind of machine." markdown="1">Application Binary Interface</a> (ABI).</p>
</li>
<li>
<p>Four <a class="gl-ref" href="../glossary/#gl:register_hardware" title="A small piece of memory (typically one word long) built into a processor that operations can refer to directly." markdown="1">registers</a> named R0 to R3
    that instructions can access directly.
    There are no memory-to-memory operations in our VM:
    everything happens in or through registers.</p>
</li>
<li>
<p>256 <a class="gl-ref" href="../glossary/#gl:word_memory" title="The unit of memory that a particular processor most naturally works with. While a byte is a fixed size (8 bits), a word may be 16, 32, or 64 bits long depending on the processor." markdown="1">words</a> of memory, each of which can store a single value.
    Both the program and its data live in this single <span class="ix-entry" ix-key="block (of memory)" markdown="1">block</span> of memory;
    we chose the size 256 so that the address of each word will fit in a single byte.</p>
</li>
</ol>
<figure id="vm-architecture">
<img src="./architecture.svg" alt="Virtual machine architecture"/>
<figcaption markdown="1">Figure 25.1: Architecture of the virtual machine.</figcaption>
</figure>

<p>Our processor&rsquo;s <a class="gl-ref" href="../glossary/#gl:instruction_set" title="The basic operations that a particular processor can execute directly." markdown="1">instruction set</a>
defines what it can do.
Instructions are just numbers,
but we will write them in a simple text format called
<a class="gl-ref" href="../glossary/#gl:assembly_code" title="A low-level programming language whose statements correspond closely to the actual instruction set of a particular kind of processor." markdown="1">assembly code</a>
that gives those number human-readable names.</p>
<div class="pagebreak"></div>

<p>The instructions for our VM are 3 bytes long.
The <a class="gl-ref" href="../glossary/#gl:op_code" title="The numerical operation code for an instruction that a processor can execute." markdown="1">op code</a> fits in one byte,
and each instruction may include zero, one, or two single-byte operands.
(Instructions are sometimes called <a class="gl-ref" href="../glossary/#gl:bytecode" title="A set of instructions designed to be executed efficiently by an interpreter." markdown="1">bytecode</a>,
since they&rsquo;re packed into bytes,
but so is everything else in a computer.)</p>
<p>Each operand is a register identifier,
a constant,
or an address,
which is just a constant that identifies a location in memory.
Since constants have to fit in one byte,
this means that the largest number we can represent directly is 256.
<a class="tbl-ref" href="../vm/#vm-op-codes">Table 25.1</a> uses the letters <code>r</code>, <code>c</code>, and <code>a</code>
to indicate instruction format,
where <code>r</code> indicates a register identifier,
<code>c</code> indicates a constant,
and <code>a</code> indicates an address.</p>
<div class="table"><table id="vm-op-codes"><caption>Table 25.1: Virtual machine op codes</caption>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: right;">Code</th>
<th style="text-align: left;">Format</th>
<th style="text-align: left;">Action</th>
<th style="text-align: left;">Example</th>
<th style="text-align: left;">Equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>hlt</code></td>
<td style="text-align: right;">1</td>
<td style="text-align: left;"><code>--</code></td>
<td style="text-align: left;">Halt program</td>
<td style="text-align: left;"><code>hlt</code></td>
<td style="text-align: left;"><code>sys.exit(0)</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>ldc</code></td>
<td style="text-align: right;">2</td>
<td style="text-align: left;"><code>rc</code></td>
<td style="text-align: left;">Load constant</td>
<td style="text-align: left;"><code>ldc R0 99</code></td>
<td style="text-align: left;"><code>R0 = 99</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>ldr</code></td>
<td style="text-align: right;">3</td>
<td style="text-align: left;"><code>rr</code></td>
<td style="text-align: left;">Load register</td>
<td style="text-align: left;"><code>ldr R0 R1</code></td>
<td style="text-align: left;"><code>R0 = memory[R1]</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>cpy</code></td>
<td style="text-align: right;">4</td>
<td style="text-align: left;"><code>rr</code></td>
<td style="text-align: left;">Copy register</td>
<td style="text-align: left;"><code>cpy R0 R1</code></td>
<td style="text-align: left;"><code>R0 = R1</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>str</code></td>
<td style="text-align: right;">5</td>
<td style="text-align: left;"><code>rr</code></td>
<td style="text-align: left;">Store register</td>
<td style="text-align: left;"><code>str R0 R1</code></td>
<td style="text-align: left;"><code>memory[R1] = R0</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>add</code></td>
<td style="text-align: right;">6</td>
<td style="text-align: left;"><code>rr</code></td>
<td style="text-align: left;">Add</td>
<td style="text-align: left;"><code>add R0 R1</code></td>
<td style="text-align: left;"><code>R0 = R0 + R1</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>sub</code></td>
<td style="text-align: right;">7</td>
<td style="text-align: left;"><code>rr</code></td>
<td style="text-align: left;">Subtract</td>
<td style="text-align: left;"><code>sub R0 R1</code></td>
<td style="text-align: left;"><code>R0 = R0 - R1</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>beq</code></td>
<td style="text-align: right;">8</td>
<td style="text-align: left;"><code>ra</code></td>
<td style="text-align: left;">Branch if equal</td>
<td style="text-align: left;"><code>beq R0 99</code></td>
<td style="text-align: left;"><code>if (R0==0) PC = 99</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>bne</code></td>
<td style="text-align: right;">9</td>
<td style="text-align: left;"><code>ra</code></td>
<td style="text-align: left;">Branch if not equal</td>
<td style="text-align: left;"><code>bne R0 99</code></td>
<td style="text-align: left;"><code>if (R0!=0) PC = 99</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>prr</code></td>
<td style="text-align: right;">10</td>
<td style="text-align: left;"><code>r-</code></td>
<td style="text-align: left;">Print register</td>
<td style="text-align: left;"><code>prr R0</code></td>
<td style="text-align: left;"><code>print(R0)</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>prm</code></td>
<td style="text-align: right;">11</td>
<td style="text-align: left;"><code>r-</code></td>
<td style="text-align: left;">Print memory</td>
<td style="text-align: left;"><code>prm R0</code></td>
<td style="text-align: left;"><code>print(memory[R0])</code></td>
</tr>
</tbody>
</table>
</div>
<p>To start building our virtual machine,
we put the VM&rsquo;s details in a file
that can be loaded by other modules:</p>
<div class="code-sample lang-py" title="architecture.py">
<div class="highlight"><pre><span></span><code><span class="n">NUM_REG</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># number of registers</span>
<span class="n">RAM_LEN</span> <span class="o">=</span> <span class="mi">256</span>  <span class="c1"># number of words in RAM</span>

<span class="n">OPS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;hlt&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="mh">0x1</span><span class="p">,</span> <span class="s2">&quot;fmt&quot;</span><span class="p">:</span> <span class="s2">&quot;--&quot;</span><span class="p">},</span>  <span class="c1"># Halt program</span>
    <span class="s2">&quot;ldc&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="mh">0x2</span><span class="p">,</span> <span class="s2">&quot;fmt&quot;</span><span class="p">:</span> <span class="s2">&quot;rv&quot;</span><span class="p">},</span>  <span class="c1"># Load value</span>
    <span class="s2">&quot;ldr&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="mh">0x3</span><span class="p">,</span> <span class="s2">&quot;fmt&quot;</span><span class="p">:</span> <span class="s2">&quot;rr&quot;</span><span class="p">},</span>  <span class="c1"># Load register</span>
    <span class="s2">&quot;cpy&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="mh">0x4</span><span class="p">,</span> <span class="s2">&quot;fmt&quot;</span><span class="p">:</span> <span class="s2">&quot;rr&quot;</span><span class="p">},</span>  <span class="c1"># Copy register</span>
    <span class="s2">&quot;str&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="mh">0x5</span><span class="p">,</span> <span class="s2">&quot;fmt&quot;</span><span class="p">:</span> <span class="s2">&quot;rr&quot;</span><span class="p">},</span>  <span class="c1"># Store register</span>
    <span class="s2">&quot;add&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="mh">0x6</span><span class="p">,</span> <span class="s2">&quot;fmt&quot;</span><span class="p">:</span> <span class="s2">&quot;rr&quot;</span><span class="p">},</span>  <span class="c1"># Add</span>
    <span class="s2">&quot;sub&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="mh">0x7</span><span class="p">,</span> <span class="s2">&quot;fmt&quot;</span><span class="p">:</span> <span class="s2">&quot;rr&quot;</span><span class="p">},</span>  <span class="c1"># Subtract</span>
    <span class="s2">&quot;beq&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="mh">0x8</span><span class="p">,</span> <span class="s2">&quot;fmt&quot;</span><span class="p">:</span> <span class="s2">&quot;rv&quot;</span><span class="p">},</span>  <span class="c1"># Branch if equal</span>
    <span class="s2">&quot;bne&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="mh">0x9</span><span class="p">,</span> <span class="s2">&quot;fmt&quot;</span><span class="p">:</span> <span class="s2">&quot;rv&quot;</span><span class="p">},</span>  <span class="c1"># Branch if not equal</span>
    <span class="s2">&quot;prr&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="mh">0xA</span><span class="p">,</span> <span class="s2">&quot;fmt&quot;</span><span class="p">:</span> <span class="s2">&quot;r-&quot;</span><span class="p">},</span>  <span class="c1"># Print register</span>
    <span class="s2">&quot;prm&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="mh">0xB</span><span class="p">,</span> <span class="s2">&quot;fmt&quot;</span><span class="p">:</span> <span class="s2">&quot;r-&quot;</span><span class="p">},</span>  <span class="c1"># Print memory</span>
<span class="p">}</span>

<span class="n">OP_MASK</span> <span class="o">=</span> <span class="mh">0xFF</span>  <span class="c1"># select a single byte</span>
<span class="n">OP_SHIFT</span> <span class="o">=</span> <span class="mi">8</span>  <span class="c1"># shift up by one byte</span>
<span class="n">OP_WIDTH</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># op width in characters when printing</span>
</code></pre></div>
</div>
<p class="continue">There isn&rsquo;t a name for this <span class="ix-entry" ix-key="design pattern" markdown="1">design pattern</span>,
but putting all the constants that define a system in one file
instead of scattering them across multiple files
makes them easier to find as well as ensuring consistency.</p>
<h2 id="vm-execute">Section 25.2: Execution</h2>
<p>We start by defining a class with an instruction pointer, some registers, and some memory
along with a prompt for output:</p>
<div class="code-sample lang-py" title="vm.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">VirtualMachine</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prompt</span> <span class="o">=</span> <span class="s2">&quot;&gt;&gt;&quot;</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">program</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">program</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">RAM_LEN</span><span class="p">,</span> <span class="s2">&quot;Program too long&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ram</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">program</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">program</span><span class="p">))</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">RAM_LEN</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ip</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">NUM_REG</span>
</code></pre></div>
</div>
<p>A program is just an array of numbers representing instructions.
To load a program into our VM,
we copy those numbers into memory and reset the instruction pointer and registers:</p>
<div class="code-sample lang-py" title="vm.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">VirtualMachine</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prompt</span> <span class="o">=</span> <span class="s2">&quot;&gt;&gt;&quot;</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">program</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">program</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">RAM_LEN</span><span class="p">,</span> <span class="s2">&quot;Program too long&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ram</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">program</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">program</span><span class="p">))</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">RAM_LEN</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ip</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">NUM_REG</span>
</code></pre></div>
</div>
<p class="continue">Notice that the VM&rsquo;s constructor calls <code>initialize</code> with an empty array
(i.e., a program with no instructions)
to do initial setup.
If an object has a method to reset or reinitialize itself,
having its constructor use that method
is a way to avoid duplicating code.</p>
<div class="pagebreak"></div>

<p>To execute the next instruction,
the VM gets the value in memory that the instruction pointer currently refers to
and moves the instruction pointer on by one address.
It then uses <span class="ix-entry" ix-key="bitwise operation" markdown="1">bitwise operations</span>
(<a class="x-ref" href="../binary/">Chapter 17</a>)
to extract the op code and operands from the instruction
(<a class="fig-ref" href="../vm/#vm-unpacking">Figure 25.2</a>).</p>
<div class="code-sample lang-py" title="vm.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">instruction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ram</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ip</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ip</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">instruction</span> <span class="o">&amp;</span> <span class="n">OP_MASK</span>
    <span class="n">instruction</span> <span class="o">&gt;&gt;=</span> <span class="n">OP_SHIFT</span>
    <span class="n">arg0</span> <span class="o">=</span> <span class="n">instruction</span> <span class="o">&amp;</span> <span class="n">OP_MASK</span>
    <span class="n">instruction</span> <span class="o">&gt;&gt;=</span> <span class="n">OP_SHIFT</span>
    <span class="n">arg1</span> <span class="o">=</span> <span class="n">instruction</span> <span class="o">&amp;</span> <span class="n">OP_MASK</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">op</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span><span class="p">]</span>
</code></pre></div>
</div>
<figure id="vm-unpacking">
<img src="./unpacking.svg" alt="Unpacking instructions"/>
<figcaption markdown="1">Figure 25.2: Using bitwise operations to unpack instructions.</figcaption>
</figure>

<p class="continue">We always unpack two operands regardless of whether the instructions has them or not,
since this is what most hardware implementations would do.</p>
<div class="callout">
<h3>Processor Design</h3>
<p>Some processor do have variable-length instructions,
but they make the hardware more complicated and therefore slower.
To decide whether these costs are worth paying,
engineers rely on simulation and profiling (<a class="x-ref" href="../perf/">Chapter 15</a>).
Backward compatibility is also an issue:
if earlier processors supported variable-length instructions,
later ones must somehow do so as well in order to run old programs.</p>
</div>
<p>The next step is to add a <code>run</code> method to our VM
that fetches instructions and executes them until told to stop:</p>
<div class="code-sample lang-py" title="vm.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">running</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">running</span><span class="p">:</span>
        <span class="n">op</span><span class="p">,</span> <span class="n">arg0</span><span class="p">,</span> <span class="n">arg1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OPS</span><span class="p">[</span><span class="s2">&quot;hlt&quot;</span><span class="p">][</span><span class="s2">&quot;code&quot;</span><span class="p">]:</span>
            <span class="n">running</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OPS</span><span class="p">[</span><span class="s2">&quot;ldc&quot;</span><span class="p">][</span><span class="s2">&quot;code&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reg</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg1</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OPS</span><span class="p">[</span><span class="s2">&quot;ldr&quot;</span><span class="p">][</span><span class="s2">&quot;code&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reg</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ram</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reg</span><span class="p">[</span><span class="n">arg1</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OPS</span><span class="p">[</span><span class="s2">&quot;cpy&quot;</span><span class="p">][</span><span class="s2">&quot;code&quot;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reg</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg</span><span class="p">[</span><span class="n">arg1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unknown op </span><span class="si">{</span><span class="n">op</span><span class="si">:</span><span class="s2">06x</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div>
</div>
<p>Let&rsquo;s look more closely at three of these instructions.
The first, <code>str</code>, stores the value of one register in the address held by another register:</p>
<div class="code-sample lang-py" title="vm.py">
<div class="highlight"><pre><span></span><code><span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OPS</span><span class="p">[</span><span class="s2">&quot;str&quot;</span><span class="p">][</span><span class="s2">&quot;code&quot;</span><span class="p">]:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ram</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reg</span><span class="p">[</span><span class="n">arg1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span>
</code></pre></div>
</div>
<p>Adding the value in one register to the value in another register is simpler:</p>
<div class="code-sample lang-py" title="vm.py">
<div class="highlight"><pre><span></span><code><span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OPS</span><span class="p">[</span><span class="s2">&quot;add&quot;</span><span class="p">][</span><span class="s2">&quot;code&quot;</span><span class="p">]:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reg</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg</span><span class="p">[</span><span class="n">arg1</span><span class="p">]</span>
</code></pre></div>
</div>
<p class="continue">as is jumping to a fixed address if the value in a register is zero.
This <a class="gl-ref" href="../glossary/#gl:conditional_jump" title="An instruction that tells a processor to start executing somewhere other than at the next address if a condition is true. Conditional jumps are used to implement higher-level constructs like <code>if</code> statements and loops." markdown="1">conditional jump</a> instruction is how we implement <code>if</code>:</p>
<div class="code-sample lang-py" title="vm.py">
<div class="highlight"><pre><span></span><code><span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OPS</span><span class="p">[</span><span class="s2">&quot;beq&quot;</span><span class="p">][</span><span class="s2">&quot;code&quot;</span><span class="p">]:</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg</span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ip</span> <span class="o">=</span> <span class="n">arg1</span>
</code></pre></div>
</div>
<h2 id="vm-assembly">Section 25.3: Assembly Code</h2>
<p>We could write out numerical op codes by hand just as <a href="http://eniacprogrammers.org/">early programmers</a> did.
However,
it is much easier to use an <a class="gl-ref" href="../glossary/#gl:assembler" title="A compiler that translates software written in assembly code into machine instructions." markdown="1">assembler</a>,
which is just a small <span class="ix-entry" ix-key="compiler" markdown="1">compiler</span> for a language
that very closely represents actual machine instructions.</p>
<p>Each command in our assembly languages matches an instruction in the VM.
Here&rsquo;s an assembly language program to print the value stored in R1 and then halt:</p>
<div class="code-sample lang-as" title="print_r1.as">
<div class="highlight"><pre><span></span><code><span class="err">#</span><span class="w"> </span><span class="nx">Print</span><span class="w"> </span><span class="nx">initial</span><span class="w"> </span><span class="nx">contents</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">R1</span><span class="p">.</span>
<span class="nx">prr</span><span class="w"> </span><span class="nx">R1</span>
<span class="nx">hlt</span>
</code></pre></div>
</div>
<p class="continue">Its numeric representation (in <span class="ix-entry" ix-key="hexadecimal" markdown="1">hexadecimal</span>) is:</p>
<div class="code-sample lang-mx" title="print_r1.mx">
<div class="highlight"><pre><span></span><code>00010a
000001
</code></pre></div>
</div>
<p>One thing the assembly language has that the instruction set doesn&rsquo;t
is <a class="gl-ref" href="../glossary/#gl:label_address" title="A human-readable name given to a particular location in memory when writing programs in assembly code." markdown="1">labels</a> on addresses in memory.
The label <code>loop</code> doesn&rsquo;t take up any space;
instead,
it tells the assembler to give the address of the next instruction a name
so that we can refer to <code>@loop</code> in jump instructions.
For example,
this program prints the numbers from 0 to 2
(<a class="fig-ref" href="../vm/#vm-count-up">Figure 25.3</a>):</p>
<table class="twocol">
  <tbody>
    <tr>
      <td markdown="1"><div class="code-sample lang-as" title="count_up.as" markdown="1">
<div class="highlight"><pre><span></span><code><span class="err">#</span><span class="w"> </span><span class="nx">Count</span><span class="w"> </span><span class="nx">up</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="mi">3</span><span class="p">.</span>
<span class="err">#</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">R0</span><span class="o">:</span><span class="w"> </span><span class="nx">loop</span><span class="w"> </span><span class="nx">index</span><span class="p">.</span>
<span class="err">#</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">R1</span><span class="o">:</span><span class="w"> </span><span class="nx">loop</span><span class="w"> </span><span class="nx">limit</span><span class="p">.</span>
<span class="nx">ldc</span><span class="w"> </span><span class="nx">R0</span><span class="w"> </span><span class="mi">0</span>
<span class="nx">ldc</span><span class="w"> </span><span class="nx">R1</span><span class="w"> </span><span class="mi">3</span>
<span class="nx">loop</span><span class="o">:</span>
<span class="nx">prr</span><span class="w"> </span><span class="nx">R0</span>
<span class="nx">ldc</span><span class="w"> </span><span class="nx">R2</span><span class="w"> </span><span class="mi">1</span>
<span class="nx">add</span><span class="w"> </span><span class="nx">R0</span><span class="w"> </span><span class="nx">R2</span>
<span class="nx">cpy</span><span class="w"> </span><span class="nx">R2</span><span class="w"> </span><span class="nx">R1</span>
<span class="nx">sub</span><span class="w"> </span><span class="nx">R2</span><span class="w"> </span><span class="nx">R0</span>
<span class="nx">bne</span><span class="w"> </span><span class="nx">R2</span><span class="w"> </span><span class="err">@</span><span class="nx">loop</span>
<span class="nx">hlt</span>
</code></pre></div>
</div></td>
      <td markdown="1"><div class="code-sample lang-mx" title="count_up.mx" markdown="1">
<div class="highlight"><pre><span></span><code>000002
030102
00000a
010202
020006
010204
000207
020209
000001
</code></pre></div>
</div></td>
    </tr>
  </tbody>
</table>

<div class="pagebreak"></div>

<figure id="vm-count-up" class="here">
<img src="./count_up.svg" alt="Counting from 0 to 2"/>
<figcaption markdown="1">Figure 25.3: Flowchart of assembly language program to count up from 0 to 2.</figcaption>
</figure>

<p>Let&rsquo;s trace this program&rsquo;s execution
(<a class="fig-ref" href="../vm/#vm-count-trace">Figure 25.4</a>):</p>
<ol>
<li>R0 holds the current loop index.</li>
<li>R1 holds the loop&rsquo;s upper bound (in this case 3).</li>
<li>The loop prints the value of R0 (one instruction).</li>
<li>The program adds 1 to R0.
    This takes two instructions because we can only add register-to-register.</li>
<li>It checks to see if we should loop again,
    which takes three instructions.</li>
<li>If the program <em>doesn&rsquo;t</em> jump back, it halts.</li>
</ol>
<figure id="vm-count-trace">
<img src="./count_trace.svg" alt="Trace counting program"/>
<figcaption markdown="1">Figure 25.4: Tracing registers and memory values for a simple counting program.</figcaption>
</figure>

<p>The implementation of the assembler mirrors the simplicity of assembly language.
The main method gets interesting lines,
finds the addresses of labels,
and turns each remaining line into an instruction:</p>
<div class="code-sample lang-py" title="assembler.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Assembler</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">assemble</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_labels</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">ln</span> <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">lines</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_label</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">compiled</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_compile</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span> <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">instructions</span>
        <span class="p">]</span>
        <span class="n">program</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_text</span><span class="p">(</span><span class="n">compiled</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">program</span>
</code></pre></div>
</div>
<p>To find labels,
we go through the lines one by one
and either save the label <em>or</em> increment the current address
(because labels don&rsquo;t take up space):</p>
<div class="code-sample lang-py" title="assembler.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_find_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_label</span><span class="p">(</span><span class="n">ln</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">ln</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Duplicated </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">result</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">_is_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p>To compile a single instruction we break the line into pieces,
look up the format for the operands,
and pack the values:</p>
<div class="code-sample lang-py" title="assembler.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instruction</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">instruction</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">op</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">fmt</span><span class="p">,</span> <span class="n">code</span> <span class="o">=</span> <span class="n">OPS</span><span class="p">[</span><span class="n">op</span><span class="p">][</span><span class="s2">&quot;fmt&quot;</span><span class="p">],</span> <span class="n">OPS</span><span class="p">[</span><span class="n">op</span><span class="p">][</span><span class="s2">&quot;code&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s2">&quot;--&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s2">&quot;r-&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reg</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">code</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s2">&quot;rr&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reg</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reg</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">code</span>
        <span class="p">)</span>

    <span class="k">elif</span> <span class="n">fmt</span> <span class="o">==</span> <span class="s2">&quot;rv&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combine</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_val</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">labels</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reg</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">code</span>
        <span class="p">)</span>
</code></pre></div>
</div>
<p>To convert a value,
we either look up the label&rsquo;s address (if the value starts with <code>@</code>)
or convert the value to a number:</p>
<div class="code-sample lang-py" title="assembler.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">token</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;@&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="n">lbl</span> <span class="o">=</span> <span class="n">token</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">assert</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Unknown label &#39;</span><span class="si">{</span><span class="n">token</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
    <span class="k">return</span> <span class="n">labels</span><span class="p">[</span><span class="n">lbl</span><span class="p">]</span>
</code></pre></div>
</div>
<p class="continue">Combining op codes and operands into a single value
is the reverse of the unpacking done by the virtual machine:</p>
<div class="code-sample lang-py" title="assembler.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Cannot combine no arguments&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">&lt;&lt;=</span> <span class="n">OP_SHIFT</span>
        <span class="n">result</span> <span class="o">|=</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
</div>
<p>As a test,
this program counts up to three:</p>
<div class="code-sample lang-as" title="count_up.as">
<div class="highlight"><pre><span></span><code><span class="err">#</span><span class="w"> </span><span class="nx">Count</span><span class="w"> </span><span class="nx">up</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="mi">3</span><span class="p">.</span>
<span class="err">#</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">R0</span><span class="o">:</span><span class="w"> </span><span class="nx">loop</span><span class="w"> </span><span class="nx">index</span><span class="p">.</span>
<span class="err">#</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">R1</span><span class="o">:</span><span class="w"> </span><span class="nx">loop</span><span class="w"> </span><span class="nx">limit</span><span class="p">.</span>
<span class="nx">ldc</span><span class="w"> </span><span class="nx">R0</span><span class="w"> </span><span class="mi">0</span>
<span class="nx">ldc</span><span class="w"> </span><span class="nx">R1</span><span class="w"> </span><span class="mi">3</span>
<span class="nx">loop</span><span class="o">:</span>
<span class="nx">prr</span><span class="w"> </span><span class="nx">R0</span>
<span class="nx">ldc</span><span class="w"> </span><span class="nx">R2</span><span class="w"> </span><span class="mi">1</span>
<span class="nx">add</span><span class="w"> </span><span class="nx">R0</span><span class="w"> </span><span class="nx">R2</span>
<span class="nx">cpy</span><span class="w"> </span><span class="nx">R2</span><span class="w"> </span><span class="nx">R1</span>
<span class="nx">sub</span><span class="w"> </span><span class="nx">R2</span><span class="w"> </span><span class="nx">R0</span>
<span class="nx">bne</span><span class="w"> </span><span class="nx">R2</span><span class="w"> </span><span class="err">@</span><span class="nx">loop</span>
<span class="nx">hlt</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="count_up.out">
<div class="highlight"><pre><span></span><code>&gt;&gt; 0
&gt;&gt; 1
&gt;&gt; 2
R000000 = 000003
R000001 = 000003
R000002 = 000000
R000003 = 000000
000000:   000002  030102  00000a  010202
000004:   020006  010204  000207  020209
000008:   000001  000000  000000  000000
</code></pre></div>
</div>
<h2 id="vm-arrays">Section 25.4: Arrays</h2>
<p>It&rsquo;s tedious to write programs when each value needs a unique name.
We can do a lot more once we have <span class="ix-entry" ix-key="array (implementation of)" markdown="1">arrays</span>,
so let&rsquo;s add those to our assembler.
We don&rsquo;t have to make any changes to the virtual machine,
which doesn&rsquo;t care if we think of a bunch of numbers as individuals or elements of an array,
but we do need a way to create arrays and refer to them.</p>
<p>We will allocate storage for arrays at the end of the program
by using <code>.data</code> on a line of its own to mark the start of the data section
and then <code>label: number</code> to give a region a name and allocate some storage space
(<a class="fig-ref" href="../vm/#vm-array">Figure 25.5</a>).</p>
<figure id="vm-array">
<img src="./array.svg" alt="Array storage allocation"/>
<figcaption markdown="1">Figure 25.5: Allocating storage for arrays in the virtual machine.</figcaption>
</figure>

<p>This enhancement only requires a few changes to the assembler.
First,
we need to split the lines into instructions and data allocations:</p>
<div class="code-sample lang-py" title="arrays.py">
<div class="highlight"><pre><span></span><code><span class="n">DIVIDER</span> <span class="o">=</span> <span class="s2">&quot;.data&quot;</span>

<span class="k">def</span> <span class="nf">assemble</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
    <span class="n">to_compile</span><span class="p">,</span> <span class="n">to_allocate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_labels</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span><span class="n">ln</span> <span class="k">for</span> <span class="n">ln</span> <span class="ow">in</span> <span class="n">to_compile</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_label</span><span class="p">(</span><span class="n">ln</span><span class="p">)]</span>

    <span class="n">base_of_data</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_add_allocations</span><span class="p">(</span><span class="n">base_of_data</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">to_allocate</span><span class="p">)</span>

    <span class="n">compiled</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_compile</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span> <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">]</span>
    <span class="n">program</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_text</span><span class="p">(</span><span class="n">compiled</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">program</span>

<span class="k">def</span> <span class="nf">_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">split</span> <span class="o">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DIVIDER</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">split</span><span class="p">],</span> <span class="n">lines</span><span class="p">[</span><span class="n">split</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="p">[]</span>
</code></pre></div>
</div>
<p>Second,
we need to figure out where each allocation lies and create a label accordingly:</p>
<div class="code-sample lang-py" title="arrays.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_add_allocations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_of_data</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">to_allocate</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">alloc</span> <span class="ow">in</span> <span class="n">to_allocate</span><span class="p">:</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alloc</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Invalid allocation directive &#39;</span><span class="si">{</span><span class="n">alloc</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="n">lbl</span><span class="p">,</span> <span class="n">num_words_text</span> <span class="o">=</span> <span class="n">fields</span>
        <span class="k">assert</span> <span class="n">lbl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Duplicate label &#39;</span><span class="si">{</span><span class="n">lbl</span><span class="si">}</span><span class="s2">&#39; in allocation&quot;</span>
        <span class="n">num_words</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_words_text</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">base_of_data</span> <span class="o">+</span> <span class="n">num_words</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">RAM_LEN</span><span class="p">,</span> \
            <span class="sa">f</span><span class="s2">&quot;Allocation &#39;</span><span class="si">{</span><span class="n">lbl</span><span class="si">}</span><span class="s2">&#39; requires too much memory&quot;</span>
        <span class="n">labels</span><span class="p">[</span><span class="n">lbl</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_of_data</span>
        <span class="n">base_of_data</span> <span class="o">+=</span> <span class="n">num_words</span>
</code></pre></div>
</div>
<p>And that&rsquo;s it:
no other changes are needed to either compilation or execution.
To test it,
let&rsquo;s fill an array with the numbers from 0 to 3:</p>
<div class="code-sample lang-as" title="fill_array.as">
<div class="highlight"><pre><span></span><code><span class="err">#</span><span class="w"> </span><span class="nx">Count</span><span class="w"> </span><span class="nx">up</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="mi">3</span><span class="p">.</span>
<span class="err">#</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">R0</span><span class="o">:</span><span class="w"> </span><span class="nx">loop</span><span class="w"> </span><span class="nx">index</span><span class="p">.</span>
<span class="err">#</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">R1</span><span class="o">:</span><span class="w"> </span><span class="nx">loop</span><span class="w"> </span><span class="nx">limit</span><span class="p">.</span>
<span class="err">#</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">R2</span><span class="o">:</span><span class="w"> </span><span class="nx">array</span><span class="w"> </span><span class="nx">index</span><span class="p">.</span>
<span class="err">#</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">R3</span><span class="o">:</span><span class="w"> </span><span class="nx">temporary</span><span class="p">.</span>
<span class="nx">ldc</span><span class="w"> </span><span class="nx">R0</span><span class="w"> </span><span class="mi">0</span>
<span class="nx">ldc</span><span class="w"> </span><span class="nx">R1</span><span class="w"> </span><span class="mi">3</span>
<span class="nx">ldc</span><span class="w"> </span><span class="nx">R2</span><span class="w"> </span><span class="err">@</span><span class="nx">array</span>
<span class="nx">loop</span><span class="o">:</span>
<span class="nx">str</span><span class="w"> </span><span class="nx">R0</span><span class="w"> </span><span class="nx">R2</span>
<span class="nx">ldc</span><span class="w"> </span><span class="nx">R3</span><span class="w"> </span><span class="mi">1</span>
<span class="nx">add</span><span class="w"> </span><span class="nx">R0</span><span class="w"> </span><span class="nx">R3</span>
<span class="nx">add</span><span class="w"> </span><span class="nx">R2</span><span class="w"> </span><span class="nx">R3</span>
<span class="nx">cpy</span><span class="w"> </span><span class="nx">R3</span><span class="w"> </span><span class="nx">R1</span>
<span class="nx">sub</span><span class="w"> </span><span class="nx">R3</span><span class="w"> </span><span class="nx">R0</span>
<span class="nx">bne</span><span class="w"> </span><span class="nx">R3</span><span class="w"> </span><span class="err">@</span><span class="nx">loop</span>
<span class="nx">hlt</span>
<span class="p">.</span><span class="nx">data</span>
<span class="nx">array</span><span class="o">:</span><span class="w"> </span><span class="mi">10</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="fill_array.out">
<div class="highlight"><pre><span></span><code>R000000 = 000003
R000001 = 000003
R000002 = 00000e
R000003 = 000000
000000:   000002  030102  0b0202  020005
000004:   010302  030006  030206  010304
000008:   000307  030309  000001  000000
00000c:   000001  000002  000000  000000
</code></pre></div>
</div>
<div class="pagebreak"></div>

<h2 id="vm-summary">Section 25.5: Summary</h2>
<figure id="vm-concept-map" class="here">
<img src="./concept_map.svg" alt="Concept map for virtual machine and assembler"/>
<figcaption markdown="1">Figure 25.6: Concept map for virtual machine and assembler.</figcaption>
</figure>

<h2 id="vm-exercises">Section 25.6: Exercises</h2>
<h3 class="exercise">Swapping Values</h3>
<p>Write an assembly language program that swaps the values in R1 and R2
without affecting the values in other registers.</p>
<h3 class="exercise">Reversing an Array</h3>
<p>Write an assembly language program that starts with:</p>
<ul>
<li>the base address of an array in one word</li>
<li>the length of the array N in the next word</li>
<li>N values immediately thereafter</li>
</ul>
<p class="continue">and reverses the array in place.</p>
<h3 class="exercise">Increment and Decrement</h3>
<ol>
<li>
<p>Add instructions <code>inc</code> and <code>dec</code> that add one to the value of a register
    and subtract one from the value of a register respectively.</p>
</li>
<li>
<p>Rewrite the examples to use these instructions.
    How much shorter do they make the programs?
    How much easier to read?</p>
</li>
</ol>
<h3 class="exercise">Using Long Addresses</h3>
<ol>
<li>
<p>Modify the virtual machine so that the <code>ldr</code> and <code>str</code> instructions
    contain 16-bit addresses rather than 8-bit addresses
    and increase the virtual machine&rsquo;s memory to 64K words to match.</p>
</li>
<li>
<p>How does this complicate instruction interpretation?</p>
</li>
</ol>
<h3 class="exercise">Operating on Strings</h3>
<p>The C programming language stored character strings as non-zero bytes terminated by a byte containing zero.</p>
<ol>
<li>
<p>Write a program that starts with the base address of a string in R1
    and finishes with the length of the string (not including the terminator) in the same register.</p>
</li>
<li>
<p>Write a program that starts with the base address of a string in R1
    and the base address of some other block of memory in R2
    and copies the string to that new location (including the terminator).</p>
</li>
<li>
<p>What happens in each case if the terminator is missing?</p>
</li>
</ol>
<h3 class="exercise">Call and Return</h3>
<ol>
<li>
<p>Add another register to the virtual machine called SP (for &ldquo;stack pointer&rdquo;)
    that is automatically initialized to the <em>last</em> address in memory.</p>
</li>
<li>
<p>Add an instruction <code>psh</code> (short for &ldquo;push&rdquo;) that copies a value from a register
    to the address stored in SP and then subtracts one from SP.</p>
</li>
<li>
<p>Add an instruction <code>pop</code> (short for &ldquo;pop&rdquo;) that adds one to SP
    and then copies a value from that address into a register.</p>
</li>
<li>
<p>Using these instructions,
    write a subroutine that evaluates <code>2x+1</code> for every value in an array.</p>
</li>
</ol>
<h3 class="exercise">Disassembling Instructions</h3>
<p>A <a class="gl-ref" href="../glossary/#gl:disassembler" title="A program that translates machine instructions into assembly code or some higher-level language." markdown="1">disassembler</a> turns machine instructions into assembly code.
Write a disassembler for the instruction set used by our virtual machine.
(Since the labels for addresses are not stored in machine instructions,
disassemblers typically generate labels like <code>@L001</code> and <code>@L002</code>.)</p>
<h3 class="exercise">Linking Multiple Files</h3>
<ol>
<li>
<p>Modify the assembler to handle <code>.include filename</code> directives.</p>
</li>
<li>
<p>What does your modified assembler do about duplicate label names?
    How does it prevent infinite includes
    (i.e., <code>A.as</code> includes <code>B.as</code> which includes <code>A.as</code> again)?</p>
</li>
</ol>
<h3 class="exercise">Providing System Calls</h3>
<p>Modify the virtual machine so that developers can add &ldquo;system calls&rdquo; to it.</p>
<ol>
<li>
<p>On startup,
    the virtual machine loads an array of functions defined in a file called <code>syscalls.py</code>.</p>
</li>
<li>
<p>The <code>sys</code> instruction takes a one-byte constant argument.
    It looks up the corresponding function and calls it with the values of R0-R3 as arguments
    and places the result in R0.</p>
</li>
</ol>
<h3 class="exercise">Unit Testing</h3>
<ol>
<li>
<p>Write unit tests for the assembler.</p>
</li>
<li>
<p>Once they are working,
    write unit tests for the virtual machine.</p>
</li>
</ol>
        </main>
      </div>
    </div>
  </body>
</html>
