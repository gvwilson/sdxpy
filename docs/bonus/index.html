<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="../logo.svg">
<link rel="stylesheet" href="../tango.css" type="text/css">
<link rel="stylesheet" href="../mccole.css" type="text/css">
<title>Software Design by Example &middot; Bonus Material</title>
<script>
  MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)']]
    }
  };
</script>
<script
  type="text/javascript"
  id="MathJax-script"
  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


  </head>
  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <a href="https://www.routledge.com/Software-Design-by-Example-A-Tool-Based-Introduction-with-Python/Wilson/p/book/9781032725215"><img src="../sdxpy-cover.png" alt="Book cover" class="bookcover" /></a>
  
</p>

<div class="screen-reader-only">
  <a href="#printable">Skip to content</a>
</div>

<ol class="toc-chapters"><li><a href="../intro/">Introduction</a></li><li><a href="../oop/">Objects and Classes</a></li><li><a href="../dup/">Finding Duplicate Files</a></li><li><a href="../glob/">Matching Patterns</a></li><li><a href="../parse/">Parsing Text</a></li><li><a href="../test/">Running Tests</a></li><li><a href="../interp/">An Interpreter</a></li><li><a href="../func/">Functions and Closures</a></li><li><a href="../protocols/">Protocols</a></li><li><a href="../archive/">A File Archiver</a></li><li><a href="../check/">An HTML Validator</a></li><li><a href="../template/">A Template Expander</a></li><li><a href="../lint/">A Code Linter</a></li><li><a href="../layout/">Page Layout</a></li><li><a href="../perf/">Performance Profiling</a></li><li><a href="../persist/">Object Persistence</a></li><li><a href="../binary/">Binary Data</a></li><li><a href="../db/">A Database</a></li><li><a href="../build/">A Build Manager</a></li><li><a href="../pack/">A Package Manager</a></li><li><a href="../ftp/">Transferring Files</a></li><li><a href="../http/">Serving Web Pages</a></li><li><a href="../viewer/">A File Viewer</a></li><li><a href="../undo/">Undo and Redo</a></li><li><a href="../vm/">A Virtual Machine</a></li><li><a href="../debugger/">A Debugger</a></li><li><a href="../observe/">Observers</a></li><li><a href="../docgen/">Generating Documentation</a></li><li><a href="../search/">Search</a></li><li><a href="../compress/">File Compression</a></li><li><a href="../cache/">A File Cache</a></li><li><a href="../query/">A Query Builder</a></li><li><a href="../concur/">Concurrency</a></li><li><a href="../finale/">Conclusion</a></li></ol>
<ol class="toc-appendices"><li><a href="../bib/">Bibliography</a></li><li><a href="../bonus/">Bonus Material</a></li><li><a href="../syllabus/">Syllabus</a></li><li><a href="../license/">License</a></li><li><a href="../conduct/">Code of Conduct</a></li><li><a href="../contrib/">Contributing</a></li><li><a href="../glossary/">Glossary</a></li><li><a href="../colophon/">Colophon</a></li><li><a href="../contents/">Index</a></li></ol>


<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


<p><a href="https://github.com/gvwilson/sdxpy">GitHub repository</a></p>

      </div>
      <div id="printable" class="contents bordered">
	<main>
	  <div class="row notex">
  <div class="col-12 center">
    
      <h1>Bonus Material</h1>
    
  </div>
</div>

	  
<nav class="row-always notex">
  <div class="col-1 left">
    <a href="../bib/" title="previous" class="undecorated">&#8678;</a>
  </div>
  <div class="col-10 center">
    <a href="../" title="home" class="undecorated">&#9737;</a>
  </div>
  <div class="col-1 right">
    <a href="../syllabus/" title="next" class="undecorated">&#8680;</a>
  </div>
</nav>


	  
	  
	  <p>Each chapter in this book is designed to be teachable in one classroom hour.
This appendix presents material that extends core ideas
but would break that <a class="gl-ref" href="../glossary/#attention_budget" markdown="1">attention budget</a>.</p>
<h2 id="bonus-attributes">Using Function Attributes</h2>
<div class="center">
<p><em>This material extends <a href="../test/">Chapter&nbsp;6</a>.</em></p>
</div>
<p>Since functions are objects,
they can have attributes.
The function <code>dir</code> (short for &ldquo;directory&rdquo;) returns a list of their names:</p>
<div class="language-py" title="func_dir.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">example</span><span class="p">():</span>
    <span class="s2">&quot;Docstring for example.&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;in example&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">example</span><span class="p">))</span>
</code></pre></div>
</div>
<div class="language-out" title="func_dir.out">
<div class="highlight"><pre><span></span><code>[&#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;__call__&#39;, &#39;__class__&#39;, \
&#39;__closure__&#39;, &#39;__code__&#39;, &#39;__defaults__&#39;, &#39;__delattr__&#39;, \
&#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, \
&#39;__get__&#39;, &#39;__getattribute__&#39;, &#39;__getstate__&#39;, &#39;__globals__&#39;, \
&#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, \
&#39;__kwdefaults__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__name__&#39;, \
&#39;__ne__&#39;, &#39;__new__&#39;, &#39;__qualname__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, \
&#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, \
&#39;__subclasshook__&#39;]
</code></pre></div>
</div>
<p>Most programmers never need to use most of these,
but <code>__name__</code> holds the function&rsquo;s original name
and <code>__doc__</code> holds its <span class="ix-entry" ix-key="docstring" markdown="1">docstring</span>:</p>
<div class="language-py" title="func_attr.py">
<div class="highlight"><pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;docstring:&quot;</span><span class="p">,</span> <span class="n">example</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;name:&quot;</span><span class="p">,</span> <span class="n">example</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="language-out" title="func_attr.out">
<div class="highlight"><pre><span></span><code>docstring: Docstring for example.
name: example
</code></pre></div>
</div>
<p>We can modify the test runner of <a href="../test/">Chapter&nbsp;6</a>
to use the function&rsquo;s <code>__name__</code> attribute in reports
instead of the key in the <code>globals</code> dictionary:</p>
<div class="language-py" title="with_name.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">run_tests</span><span class="p">(</span><span class="n">prefix</span><span class="p">):</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">func</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s2">&quot;passed&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s2">&quot;failed&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s2">&quot;had error&quot;</span><span class="p">)</span>

<span class="n">run_tests</span><span class="p">(</span><span class="s2">&quot;test_&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="language-out" title="with_name.out">
<div class="highlight"><pre><span></span><code>test_sign_negative passed
test_sign_positive passed
test_sign_zero failed
test_sign_error had error
</code></pre></div>
</div>
<p>More usefully,
we can say that if a test function&rsquo;s docstring contains the string <code>"test:skip"</code>
then we should skip the test,
while <code>"test:fail"</code> means we expect this test to fail.
Let&rsquo;s rewrite our tests to show this off:</p>
<div class="language-py" title="docstring.py">
<div class="highlight"><pre><span></span><code><span class="n">TEST_FAIL</span> <span class="o">=</span> <span class="s2">&quot;test:fail&quot;</span>
<span class="n">TEST_SKIP</span> <span class="o">=</span> <span class="s2">&quot;test:skip&quot;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_sign_negative</span><span class="p">():</span>
    <span class="s2">&quot;test:skip&quot;</span>
    <span class="k">assert</span> <span class="n">sign</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_sign_positive</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">sign</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_sign_zero</span><span class="p">():</span>
    <span class="s2">&quot;test:fail&quot;</span>
    <span class="k">assert</span> <span class="n">sign</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_sign_error</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Expect an error.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">sgn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>
</div>
<p class="continue">and then modify <code>run_tests</code> to look for these strings and act accordingly:</p>
<div class="language-py" title="docstring.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">run_tests</span><span class="p">(</span><span class="n">prefix</span><span class="p">):</span>
    <span class="n">all_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">all_names</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">and</span> <span class="n">TEST_SKIP</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skip: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pass: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">TEST_FAIL</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pass (expected failure): </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fail: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;/</span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error: </span><span class="si">{</span><span class="n">name</span><span class="si">}{</span><span class="n">doc</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">run_tests</span><span class="p">(</span><span class="s2">&quot;test_&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p>The output is now:</p>
<div class="language-out" title="docstring.out">
<div class="highlight"><pre><span></span><code>skip: test_sign_negative
pass: test_sign_positive
pass (expected failure): test_sign_zero
error: test_sign_error/Expect an error. name &#39;sgn&#39; is not defined
</code></pre></div>
</div>
<p>Instead of (ab)using docstrings like this,
we can instead add our own attributes to functions.
Let&rsquo;s say that if a function has an attribute called <code>skip</code> with the value <code>True</code>
then the function is to be skipped,
while if it has an attribute called <code>fail</code> whose value is <code>True</code>
then the test is expected to fail.
Our tests become:</p>
<div class="language-py" title="attribute.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">test_sign_negative</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">sign</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">test_sign_negative</span><span class="o">.</span><span class="n">skip</span> <span class="o">=</span> <span class="kc">True</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_sign_positive</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">sign</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_sign_zero</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">sign</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="n">test_sign_zero</span><span class="o">.</span><span class="n">fail</span> <span class="o">=</span> <span class="kc">True</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_sign_error</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">sgn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</code></pre></div>
</div>
<p>We can write a helper function called <code>classify</code> to classify tests.
Note that it uses <code>hasattr</code> to check if an attribute is present
before trying to get its value:</p>
<div class="language-py" title="attribute.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">classify</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;skip&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">func</span><span class="o">.</span><span class="n">skip</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;skip&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;fail&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">func</span><span class="o">.</span><span class="n">fail</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;fail&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;run&quot;</span>
</code></pre></div>
</div>
<p>Finally,
our test runner becomes:</p>
<div class="language-py" title="attribute.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">run_tests</span><span class="p">(</span><span class="n">prefix</span><span class="p">):</span>
    <span class="n">all_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">all_names</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="n">classify</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;skip&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;skip: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">func</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pass: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;fail&quot;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pass (expected failure): </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fail: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;error: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">run_tests</span><span class="p">(</span><span class="s2">&quot;test_&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="pagebreak"></div>

<h2 id="bonus-lazy">Lazy Evaluation</h2>
<div class="center">
<p><em>This material extends <a href="../interp/">Chapter&nbsp;7</a>.</em></p>
</div>
<p>One way to evaluate a design is to ask how <span class="ix-entry" ix-key="extensibility" markdown="1">extensible</span> it is.
The answer for our interpreter is now, &ldquo;Pretty easily.&rdquo;
For example,
we can add a <code>comment</code> &ldquo;operation&rdquo; that does nothing and returns <code>None</code>
simply by writing <code>do_comment</code> function:</p>
<div class="language-py" title="stmt.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">do_comment</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ignore instructions.</span>
<span class="sd">    [&quot;comment&quot; &quot;text&quot;] =&gt; None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
</div>
<p>An <code>if</code> statement is a bit more complex.
If its first argument is true,
it evaluates and returns its second argument (the &ldquo;if&rdquo; branch).
Otherwise,
it evaluates and returns its second argument (the &ldquo;else&rdquo; branch):</p>
<div class="language-py" title="stmt.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">do_if</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a choice: only one sub-expression is evaluated.</span>
<span class="sd">    [&quot;if&quot; C A B] =&gt; A if C else B</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">do</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">choice</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">cond</span> <span class="k">else</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">do</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">As we said in <a href="../func/">Chapter&nbsp;8</a>,
this is called <span class="ix-entry" ix-key="lazy evaluation" markdown="1">lazy evaluation</span>
to distinguish it from the more usual <span class="ix-entry" ix-key="eager evaluation" markdown="1">eager evaluation</span>
that evaluates everything up front.
<code>do_if</code> only evaluates what it absolutely needs to;
most languages do this so that we can safely write things like:</p>
<div class="language-py" title="lazy.py">
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">None</span>
</code></pre></div>
</div>
<p class="continue">If the language always evaluated both branches,
then the code shown above would fail whenever <code>x</code> was zero,
even though it&rsquo;s supposed to handle that case.
In this case it might seem obvious what the language should do,
but most languages use lazy evaluation for <code>and</code> and <code>or</code> as well
so that expressions like:</p>
<div class="language-py" title="ex_and_shortcut.py">
<div class="highlight"><pre><span></span><code><span class="n">thing</span> <span class="ow">and</span> <span class="n">thing</span><span class="o">.</span><span class="n">part</span>
</code></pre></div>
</div>
<p class="continue">will produce <code>None</code> if <code>thing</code> is <code>None</code>
and <code>reference.part</code> if it isn&rsquo;t.</p>
<h2 id="bonus-extension">Extension</h2>
<div class="center">
<p><em>This material extends <a href="../lint/">Chapter&nbsp;13</a>.</em></p>
</div>
<p>It&rsquo;s easy to check a single style rule by extending <code>NodeVisitor</code>,
but what if we want to check dozens of rules?
Traversing the AST dozens of times would be inefficient.
And what if we want people to be able to add their own rules?
Inheritance is the wrong tool for this:
if several people each create their own <code>NodeVisitor</code> with a <code>visit_Name</code> method,
we&rsquo;d have to inherit from all those classes
and then have the new class&rsquo;s <code>visit_Name</code> call up to all of its parents&rsquo; equivalent methods.</p>
<p>One way around this is to <a class="gl-ref" href="../glossary/#method_injection" markdown="1">inject</a> methods into classes
after they have been defined.
The code fragment below creates a new class called <code>BlankNodeVisitor</code>
that doesn&rsquo;t add anything to <code>NodeVisitor</code>,
then uses <code>setattr</code> to add a method to it after it has been defined
(<a class="fig-ref" href="../bonus/#bonus-injection">Figure&nbsp;B.1</a>):</p>
<div class="language-py" title="injection.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">BlankNodeVisitor</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span><span class="w"> </span><span class="nf">print_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

<span class="nb">setattr</span><span class="p">(</span><span class="n">BlankNodeVisitor</span><span class="p">,</span> <span class="s2">&quot;visit_Name&quot;</span><span class="p">,</span> <span class="n">print_name</span><span class="p">)</span>
</code></pre></div>
</div>
<figure id="bonus-injection">
<img src="./injection.svg" alt="Method injection"/>
<figcaption>Figure&nbsp;B.1: Adding methods to classes after their definition.</figcaption>
</figure>

<p>This trick works because classes and objects are just specialized dictionaries
(for some large value of &ldquo;just&rdquo;).
If we create an object of <code>BlankNodeVisitor</code> and call its <code>visit</code> method:</p>
<div class="language-py" title="injection.py">
<div class="highlight"><pre><span></span><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">BlankNodeVisitor</span><span class="p">()</span>
<span class="n">finder</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="pagebreak"></div>

<p class="continue">then the inherited <code>generic_visit</code> method does what it always does.
When it encounters a <code>Name</code> node,
it looks in the object for something called <code>visit_Name</code>.
Since it doesn&rsquo;t find anything,
it looks in the object&rsquo;s class for something with that name,
finds our injected method,
and calls it.</p>
<p>With a bit more work,
we could have our injected method save and then call
whatever <code>visit_Name</code> method was there when it was added to the class,
but we would quickly run into a problem.
As we&rsquo;ve seen in earlier examples,
the methods that handle nodes are responsible for deciding
whether and when to recurse into those nodes&rsquo; children.
If we pile method on top of one another,
then either each one is going to trigger recursion
(so we recurse many times)
or there will have to be some way for each one to signal
whether it did that
so that other methods don&rsquo;t.</p>
<p>To avoid this complication,
most systems use a different approach.
Consider this class:</p>
<div class="language-py" title="register.py">
<div class="highlight"><pre><span></span><code><span class="n">Handler</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Handler&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;func&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">])</span>

<span class="k">class</span><span class="w"> </span><span class="nc">RegisterNodeVisitor</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeType</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">handler</span> <span class="o">=</span> <span class="n">Handler</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nodeType</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="p">[</span><span class="n">nodeType</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="p">[</span><span class="n">nodeType</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="n">handler</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">handler</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</code></pre></div>
</div>
<p>The <code>add_handler</code> method takes three parameters:
the type of node a callback function is meant to handle,
the function itself,
and an optional extra piece of data to pass to the function
along with an AST node.
It saves the handler function and the data in a lookup table
indexed by the type of node the function is meant to handle.
Each of the methods inherited from <code>NodeVisitor</code>
then looks up handlers for its node type and runs them.</p>
<p>So what do handlers look like?
Each one is a function that takes a node and some data as input
and does whatever it&rsquo;s supposed to do:</p>
<div class="language-py" title="register.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count_names</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">counter</span><span class="p">):</span>
    <span class="n">counter</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>
</div>
<p>Setting up the visitor is a bit more complicated,
since we have to create and <span class="ix-entry" ix-key="register (in code)" markdown="1">register</span> the handler:</p>
<div class="language-py" title="register.py">
<div class="highlight"><pre><span></span><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>

<span class="n">finder</span> <span class="o">=</span> <span class="n">RegisterNodeVisitor</span><span class="p">()</span>
<span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="n">finder</span><span class="o">.</span><span class="n">add_handler</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">count_names</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>

<span class="n">finder</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">However,
we can now register as many handlers as we want
for each kind of node.</p>
<h2 id="bonus-inheritance">Tracing Inheritance</h2>
<div class="center">
<p><em>This material extends <a href="../lint/">Chapter&nbsp;13</a>.</em></p>
</div>
<p>In order to keep track of the code we wrote for this book,
we built a tool that reports which methods are defined or redefined in which classes.
To show how it works,
this file that defines four classes,
each of which defines or redefines some methods:</p>
<div class="language-py" title="inheritance_example.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Parent</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">red</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">green</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">LeftChild</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">green</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">blue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">RightChild</span><span class="p">(</span><span class="n">Parent</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">red</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">blue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GrandChild</span><span class="p">(</span><span class="n">LeftChild</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">red</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">blue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">orange</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</code></pre></div>
</div>
<p>As in <a href="../lint/">Chapter&nbsp;13</a>,
our class&rsquo;s constructor creates a stack to keep track of where we are.
It also creates a couple of dictionaries to keep track of
how classes inherit from each other
and the methods each class defines:</p>
<div class="language-py" title="inheritance.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">FindClassesAndMethods</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">methods</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div>
</div>
<p>When we encounter a new class definition,
we push its name on the stack,
record its parents,
and create an empty set to hold its methods:</p>
<div class="language-py" title="inheritance.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">visit_ClassDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
        <span class="k">assert</span> <span class="n">class_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">class_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">methods</span><span class="p">[</span><span class="n">class_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">class_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">bases</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
</code></pre></div>
</div>
<p>When we encounter a function definition,
the first thing we do is check the stack.
If it&rsquo;s empty,
we&rsquo;re looking at a top-level function rather than a method,
so there&rsquo;s nothing for us to do.
(We actually should recurse through the function&rsquo;s children,
since it&rsquo;s possible to define classes inside functions,
but we&rsquo;ll leave as an exercise.)
If this function definition is inside a class,
on the other hand,
we add its name to our records:</p>
<div class="language-py" title="inheritance.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">visit_FunctionDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">class_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">methods</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
        <span class="k">assert</span> <span class="n">method_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">methods</span><span class="p">[</span><span class="n">class_name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">methods</span><span class="p">[</span><span class="n">class_name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">method_name</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Once we&rsquo;re done searching the AST,
we print out a table
of the classes and methods we&rsquo;ve seen (<a class="tbl-ref" href="../bonus/#linter-inheritance">Table&nbsp;B.1</a>).
We could make this display easier to read—for example,
we could sort the classes from parent to child
and display methods in the order they were first defined—but
none of that requires us to inspect the AST.</p>
<table id="linter-inheritance"><caption>Table&nbsp;B.1: Inheritance and methods.</caption>
<thead>
<tr>
<th></th>
<th><code>GrandChild</code></th>
<th><code>LeftChild</code></th>
<th><code>Parent</code></th>
<th><code>RightChild</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>blue</code></td>
<td>X</td>
<td>X</td>
<td></td>
<td>X</td>
</tr>
<tr>
<td><code>green</code></td>
<td></td>
<td>X</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td><code>orange</code></td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>red</code></td>
<td>X</td>
<td></td>
<td>X</td>
<td>X</td>
</tr>
</tbody>
</table>

<h2 id="bonus-inspect">Inspecting Functions</h2>
<div class="center">
<p><em>This material extends <a href="../perf/">Chapter&nbsp;15</a>.</em></p>
</div>
<p>The implementation of dataframe filtering in <a href="../perf/">Chapter&nbsp;15</a> was somewhat brittle.
A better implementation of filtering would make use of the fact that
Python&rsquo;s <a href="https://docs.python.org/3/library/inspect.html"><code>inspect</code></a> module lets us examine objects in memory.
In particular, <code>inspect.signature</code> can tell us what parameters a function takes:</p>
<div class="language-py" title="inspect_func.py">
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>

<span class="k">def</span><span class="w"> </span><span class="nf">example</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;signature:&quot;</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;type:&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;names:&quot;</span><span class="p">,</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;parameters:&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
</code></pre></div>
</div>
<div class="language-out" title="inspect_func.out">
<div class="highlight"><pre><span></span><code>signature: (first, second)
type: &lt;class &#39;inspect.Signature&#39;&gt;
names: OrderedDict([(&#39;first&#39;, &lt;Parameter &quot;first&quot;&gt;), (&#39;second&#39;, \
&lt;Parameter &quot;second&quot;&gt;)])
parameters: [&#39;first&#39;, &#39;second&#39;]
</code></pre></div>
</div>
<p class="continue">If, for example,
the user wants to compare the <code>red</code> and <code>blue</code> columns of a dataframe,
they can give us a function that has two parameters called <code>red</code> and <code>blue</code>.
We can then use those parameter names to figure out
which columns we need from the dataframe.</p>
<h2 id="bonus-extend">User-Defined Classes</h2>
<div class="center">
<p><em>This material extends <a href="../persist/">Chapter&nbsp;16</a>.</em></p>
</div>
<p>The persistence framework of <a href="../persist/">Chapter&nbsp;16</a> only handles built-in data types,
but can easily be extended to handle user-defined classes as well.
To start,
we refactor the code so that the <code>save</code> method doesn&rsquo;t get any larger:</p>
<div class="language-py" title="extend.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SaveExtend</span><span class="p">(</span><span class="n">SaveAlias</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">writer</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thing</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aliased</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_builtin</span><span class="p">(</span><span class="n">thing</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to handle </span><span class="si">{</span><span class="n">thing</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div>
</div>
<p class="continue">The method to handle built-in types is:</p>
<div class="language-py" title="extend.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">_builtin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thing</span><span class="p">):</span>
        <span class="n">typename</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">method</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">typename</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">thing</span><span class="p">))</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="n">thing</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>
</div>
<p class="continue">and the one that handles aliases is:</p>
<div class="language-py" title="extend.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">_aliased</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thing</span><span class="p">):</span>
        <span class="n">thing_id</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">thing</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">thing_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seen</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">(</span><span class="s2">&quot;alias&quot;</span><span class="p">,</span> <span class="n">thing_id</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>
</div>
<p class="continue">None of this code is new:
we&rsquo;ve just moved things into methods
to make each piece easier to understand.</p>
<p>So how does a class indicate that it can be saved and loaded by our framework?
Our options are:</p>
<ol>
<li>
<p>Require it to inherit from a <span class="ix-entry" ix-key="base class" markdown="1">base class</span> that we provide
    so that we can use <code>isinstance</code> to check if an object is persistable.
    This approach is used in strictly-typed languages like Java,
    but method #2 below is considered more <a class="gl-ref" href="../glossary/#pythonic" markdown="1">Pythonic</a>.</p>
</li>
<li>
<p>Require it to implement a method with a specific name and signature
    without deriving from a particular base class.
    This approach is called <a class="gl-ref" href="../glossary/#duck_typing" markdown="1">duck typing</a>:
    if it walks like a duck and quacks like a duck, it&rsquo;s a duck.
    Since option #1 would require users to write this method anyway,
    it&rsquo;s the one we&rsquo;ll choose.</p>
</li>
<li>
<p>Require users to <span class="ix-entry" ix-key="register (in code)" markdown="1">register</span>
    a <a class="gl-ref" href="../glossary/#helper_class" markdown="1">helper class</a>
    that knows how to save and load objects of the class we&rsquo;re interested in.
    This approach is also commonly used in strictly-typed languages
    as a way of adding persistence after the fact
    without disrupting the class hierarchy.</p>
</li>
</ol>
<p>To implement option #2,
we specify that if a class has a method called <code>to_dict</code>,
we will call that to get the object&rsquo;s contents as a dictionary
and then persist that dictionary.
Before doing that,
though,
we will save a line indicating that
this dictionary should be used to reconstruct an object
of a particular class:</p>
<div class="language-py" title="extend.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">_extension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thing</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">thing</span><span class="p">,</span> <span class="s2">&quot;to_dict&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write</span><span class="p">(</span><span class="s2">&quot;@extension&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">thing</span><span class="p">),</span> <span class="n">thing</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">thing</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>
</div>
<p>Loading user-defined classes requires more work
because we have to map class names back to actual classes.
(We could also use <span class="ix-entry" ix-key="introspection" markdown="1">introspection</span>
to find <em>all</em> the classes in the program
and build a lookup table of the ones with the right method.)
We start by modifying the loader&rsquo;s constructor
to take zero or more extension classes as arguments
and then build a name-to-class lookup table from them:</p>
<div class="language-py" title="extend.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">LoadExtend</span><span class="p">(</span><span class="n">LoadAlias</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader</span><span class="p">,</span> <span class="o">*</span><span class="n">extensions</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seen</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extensions</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">extensions</span><span class="p">}</span>
</code></pre></div>
</div>
<p>The <code>load</code> method then looks for aliases,
built-in types,
and extensions in that order.
Instead of using a chain of <code>if</code> statements
we loop over the methods that handle these cases.
If a method decides that it can handle the incoming data
it returns a result;
if it can&rsquo;t,
it raises a <code>KeyError</code> exception,
and if none of the methods handle a case
we fail:</p>
<div class="language-py" title="extend.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_aliased</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_builtin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to handle </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">ident</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span>
</code></pre></div>
</div>
<p>The code to handle built-ins and aliases is copied from our previous work
and modified to raise <code>KeyError</code>:</p>
<div class="language-py" title="extend.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">_aliased</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;alias&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">ident</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seen</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seen</span><span class="p">[</span><span class="n">ident</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_builtin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">method</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="n">ident</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</code></pre></div>
</div>
<p>The method that handles extensions
checks that the value on the line just read indicates an extension,
then reads the dictionary containing the object&rsquo;s contents
from the input stream
and uses it to build an <span class="ix-entry" ix-key="instance" markdown="1">instance</span> of the right class:</p>
<div class="language-py" title="extend.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">_extension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">ident</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;@extension&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extensions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">()</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extensions</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>
        <span class="n">contents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">contents</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Here&rsquo;s a class that defines the required method:</p>
<div class="language-py" title="user_classes.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Parent</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">}</span>
</code></pre></div>
</div>
<p>and here&rsquo;s a test to make sure everything works:</p>
<div class="language-py" title="test_extend.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">test_extend_extension_class</span><span class="p">():</span>
    <span class="n">fixture</span> <span class="o">=</span> <span class="n">Parent</span><span class="p">(</span><span class="s2">&quot;subject&quot;</span><span class="p">)</span>
    <span class="n">writer</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
    <span class="n">Save</span><span class="p">(</span><span class="n">writer</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">fixture</span><span class="p">)</span>
    <span class="n">reader</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="n">writer</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">Load</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">Parent</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Parent</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">fixture</span><span class="o">.</span><span class="n">name</span>
</code></pre></div>
</div>
<div class="callout">
<h3>What&rsquo;s in a Name?</h3>
<p>The first version of these classes used the word <code>"extension"</code>
rather than <code>"@extension"</code>.
That led to the most confusing bug in this whole chapter.
When <code>load</code> reads a line,
it runs <code>self._builtin</code> before running <code>self._extension</code>.
If the first word on the line is <code>"extension"</code> (without the <code>@</code>)
then <code>self._builtin</code> constructs the method name <code>_extension</code>,
finds that method,
and calls it
as if we were loading an object of a built-in type:
which we&rsquo;re not.
Using <code>@extension</code> as the leading indicator
leads to <code>self._builtin</code> checking for <code>"_@extension"</code> in the loader&rsquo;s attributes,
which doesn&rsquo;t exist,
so everything goes as it should.</p>
</div>
<h2 id="bonus-float">Floating Point Numbers</h2>
<div class="center">
<p><em>This material extends <a href="../binary/">Chapter&nbsp;17</a>.</em></p>
</div>
<p>The rules for storing floating point numbers make those for Unicode look simple.
The root of the problem is that
we cannot represent an infinite number of real values
with a finite set of bit patterns.
And no matter what values we represent,
there will be an infinite number of values between each of them that we can&rsquo;t.
The explanation that follows is simplified to keep it manageable;
please read <span class="bib-ref">[<a class="bib-ref" href="../bib/#Goldberg1991">Goldberg1991</a>]</span> for more detail.</p>
<p>Floating point numbers are represented by a sign,
a <a class="gl-ref" href="../glossary/#mantissa" markdown="1">mantissa</a>,
and an <a class="gl-ref" href="../glossary/#exponent" markdown="1">exponent</a>.
In a 32-bit <span class="ix-entry" ix-key="word (of memory)" markdown="1">word</span>
the <span class="ix-entry" ix-key="IEEE 754 standard" markdown="1">IEEE 754</span> standard calls for 1 bit of sign,
23 bits for the mantissa,
and 8 bits for the exponent.
We will illustrate how it works using a much smaller representation:
no sign,
3 bits for the mantissa,
and 2 for the exponent.
<a class="fig-ref" href="../bonus/#bonus-floating-point">Figure&nbsp;B.2</a> shows the values this scheme can represent.</p>
<figure id="bonus-floating-point" class="here">
<img src="./floating_point.svg" alt="Representing floating point numbers"/>
<figcaption>Figure&nbsp;B.2: Representing floating point numbers.</figcaption>
</figure>

<p>The IEEE standard avoids the redundancy in this representation by shifting things around.
Even with that,
though,
formats like this can&rsquo;t represent a lot of values:
for example,
ours can store 8 and 10 but not 9.
This is exactly like the problem hand calculators have
with fractions like 1/3:
in decimal, we have to round that to 0.3333 or 0.3334.</p>
<p>But if this scheme has no representation for 9
then \( 8+1 \) must be stored as either 8 or 10.
What should \( 8+1+1 \) be?
If we add from the left,
\( (8+1)+1 \) is \( 8+1 \) is 8,
but if we add from the right,
\( 8+(1+1) \) is \( 8+2 \) is 10.
Changing the order of operations makes the difference between right and wrong.</p>
<p>The authors of numerical libraries spend a lot of time worrying about things like this.
In this case
sorting the values and adding them from smallest to largest
gives the best chance of getting the best possible answer.
In other situations,
like inverting a matrix, the rules are much more complicated.</p>
<p>Another observation about our number line is that
while the values are unevenly spaced,
the <em>relative</em> spacing between each set of values stays the same:
the first group is separated by 1,
then the separation becomes 2,
then 4,
and so on.
This observation leads to a couple of useful definitions:</p>
<ul>
<li>
<p>The <a class="gl-ref" href="../glossary/#absolute_error" markdown="1">absolute error</a> in an approximation
    is the absolute value of the difference
    between the approximation and the actual value.</p>
</li>
<li>
<p>The <a class="gl-ref" href="../glossary/#relative_error" markdown="1">relative error</a>
    is the ratio of the absolute error
    to the absolute value we&rsquo;re approximating.</p>
</li>
</ul>
<p>For example,
being off by 1 in approximating 8+1 and 56+1 is the same absolute error,
but the relative error is larger in the first case than in the second.
Relative error is almost always more useful than absolute:
it makes little sense to say that we&rsquo;re off by a hundredth
when the value in question is a billionth.</p>
<p>One implication of this is that
we should never compare floating point numbers with <code>==</code> or <code>!=</code>
because two numbers calculated in different ways
will probably not have exactly the same bits.
It&rsquo;s safe to use <code>&lt;</code>, <code>&gt;=</code>, and other orderings,
though,
since they don&rsquo;t depend on being the same down to the last bit.</p>
<p>If we do want to compare floating point numbers
we can use something like <a href="https://docs.pytest.org/en/4.6.x/reference.html#pytest-approx">the <code>approx</code> class</a> from <a href="https://docs.pytest.org/">pytest</a>
which checks whether two numbers are within some tolerance of each other.
A completely different approach is to use something like
the <a href="https://docs.python.org/3/library/fractions.html"><code>fractions</code></a> module,
which (as its name suggests) uses numerators and denominators
to avoid some precision issues.
<a href="https://www.textualize.io/blog/7-things-ive-learned-building-a-modern-tui-framework/">This post</a> describes one clever use of the module.</p>
<h2 id="bonus-endian">Big and Little Endian</h2>
<div class="center">
<p><em>This material extends <a href="../binary/">Chapter&nbsp;17</a>.</em></p>
</div>
<p>Suppose we want to store a 32-bit integer in memory.
As <a class="fig-ref" href="../bonus/#bonus-big-little">Figure&nbsp;B.3</a> shows,
we can order its four bytes in two different ways.
<a class="gl-ref" href="../glossary/#little_endian" markdown="1">Little-endian</a> order
stores the least significant bits of integer at the first (lowest) address in memory,
while <a class="gl-ref" href="../glossary/#big_endian" markdown="1">big-endian</a> order stores the most significant bits first.</p>
<figure id="bonus-big-little" class="here">
<img src="./big_little_endian.svg" alt="Endian order"/>
<figcaption>Figure&nbsp;B.3: Big-endian and little-endian byte order.</figcaption>
</figure>

<p>Modern Intel processors use little-endian order,
but as <a href="https://en.wikipedia.org/wiki/Endianness">this article</a> explains,
some other processors (and most network protocols) use big-endian order.
There are pros and cons to both, which we won&rsquo;t go into here.
What you <em>do</em> need to know is that if you move data from one architecture to another,
it&rsquo;s your responsibility to flip the bytes around,
because the machine doesn&rsquo;t know what the bytes mean.
This is such a pain that the <a href="https://docs.python.org/3/library/struct.html"><code>struct</code></a> module and other libraries like it 
will do things for you if you ask it to.
If you&rsquo;re using <code>struct</code>,
the first character of a format string optionally indicates the byte order
(<a class="tbl-ref" href="../bonus/#bonus-endian-formats">Table&nbsp;B.2</a>).</p>
<table id="bonus-endian-formats"><caption>Table&nbsp;B.2: <code>struct</code> package endian indicators.</caption>
<thead>
<tr>
<th>Character</th>
<th>Byte order</th>
<th>Size</th>
<th>Alignment</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@</code></td>
<td>native</td>
<td>native</td>
<td>native</td>
</tr>
<tr>
<td><code>=</code></td>
<td>native</td>
<td>standard</td>
<td>none</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>little</td>
<td>endian</td>
<td>standard none</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>big</td>
<td>endian</td>
<td>standard none</td>
</tr>
<tr>
<td><code>!</code></td>
<td>network</td>
<td>standard</td>
<td>none</td>
</tr>
</tbody>
</table>

<h2 id="bonus-theorem">Generating Test Cases</h2>
<div class="center">
<p><em>This material extends <a href="../pack/">Chapter&nbsp;20</a>.</em></p>
</div>
<p>Theorem provers like Z3 and <a href="http://fmv.jku.at/picosat/">PicoSAT</a>
are far more powerful than most programmers realize.
Borrowing an example from <a href="https://andreas-zeller.info/">Andreas Zeller</a>,
we can use theorem provers to generate test cases.
Suppose we have a function that classifies triangles as equilateral,
scalene,
or isosceles.
We can set up some integer variables:</p>
<div class="language-py" title="equilateral.py">
<div class="highlight"><pre><span></span><code><span class="n">A</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
<span class="n">lengths</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">B</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">C</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">and then ask it to create an equilateral triangle
based solely on the definition:</p>
<div class="language-py" title="equilateral.py">
<div class="highlight"><pre><span></span><code><span class="n">equilateral</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span><span class="p">,</span> <span class="n">B</span> <span class="o">==</span> <span class="n">C</span><span class="p">,</span> <span class="n">C</span> <span class="o">==</span> <span class="n">A</span><span class="p">)</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">equilateral</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;equilateral&quot;</span><span class="p">,</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">(),</span> <span class="n">solver</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
</code></pre></div>
</div>
<div class="language-out" title="equilateral.out">
<div class="highlight"><pre><span></span><code>equilateral sat [C = 1, B = 1, A = 1]
</code></pre></div>
</div>
<p>The same technique can generate a test case for scalene triangles:</p>
<div class="language-py" title="scalene.py">
<div class="highlight"><pre><span></span><code><span class="n">scalene</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="n">B</span><span class="p">,</span> <span class="n">B</span> <span class="o">!=</span> <span class="n">C</span><span class="p">,</span> <span class="n">C</span> <span class="o">!=</span> <span class="n">A</span><span class="p">)</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">scalene</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;scalene&quot;</span><span class="p">,</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">(),</span> <span class="n">solver</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
</code></pre></div>
</div>
<div class="language-out" title="scalene.out">
<div class="highlight"><pre><span></span><code>scalene sat [C = 3, A = 1, B = 2]
</code></pre></div>
</div>
<p class="continue">and isosceles triangles:</p>
<div class="language-py" title="isosceles.py">
<div class="highlight"><pre><span></span><code><span class="n">isosceles</span> <span class="o">=</span> <span class="n">Or</span><span class="p">(</span>
    <span class="n">And</span><span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">!=</span> <span class="n">A</span><span class="p">),</span>
    <span class="n">And</span><span class="p">(</span><span class="n">A</span> <span class="o">==</span> <span class="n">B</span><span class="p">,</span> <span class="n">B</span> <span class="o">!=</span> <span class="n">C</span><span class="p">),</span>
    <span class="n">And</span><span class="p">(</span><span class="n">A</span> <span class="o">!=</span> <span class="n">B</span><span class="p">,</span> <span class="n">B</span> <span class="o">==</span> <span class="n">C</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lengths</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">isosceles</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;isosceles&quot;</span><span class="p">,</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">(),</span> <span class="n">solver</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
</code></pre></div>
</div>
<div class="language-out" title="isosceles.out">
<div class="highlight"><pre><span></span><code>isosceles sat [C = 2, A = 1, B = 2]
</code></pre></div>
</div>
	</main>
	<footer>
  © 2025 <a href="https://third-bit.com/">Greg Wilson</a>
  &middot;
  <a href="../">home</a>
  &middot;
  <a href="https://github.com/gvwilson/sdxpy">repository</a>
  &middot;
  <a href="../license/">license</a>
  &middot;
  <a href="mailto:gvwilson@third-bit.com">contact</a>
</footer>

      </div>
    </div>
  </body>
</html>
