<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="../logo.svg">
<link rel="stylesheet" href="../tango.css" type="text/css">
<link rel="stylesheet" href="../mccole.css" type="text/css">
<title>Software Design by Example &middot; A Code Linter</title>
<script>
  MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)']]
    }
  };
</script>
<script
  type="text/javascript"
  id="MathJax-script"
  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


  </head>
  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <a href="https://www.routledge.com/Software-Design-by-Example-A-Tool-Based-Introduction-with-Python/Wilson/p/book/9781032725215"><img src="../sdxpy-cover.png" alt="Book cover" class="bookcover" /></a>
  
</p>

<div class="screen-reader-only">
  <a href="#printable">Skip to content</a>
</div>

<ol class="toc-chapters"><li><a href="../intro/">Introduction</a></li><li><a href="../oop/">Objects and Classes</a></li><li><a href="../dup/">Finding Duplicate Files</a></li><li><a href="../glob/">Matching Patterns</a></li><li><a href="../parse/">Parsing Text</a></li><li><a href="../test/">Running Tests</a></li><li><a href="../interp/">An Interpreter</a></li><li><a href="../func/">Functions and Closures</a></li><li><a href="../protocols/">Protocols</a></li><li><a href="../archive/">A File Archiver</a></li><li><a href="../check/">An HTML Validator</a></li><li><a href="../template/">A Template Expander</a></li><li><a href="../lint/">A Code Linter</a></li><li><a href="../layout/">Page Layout</a></li><li><a href="../perf/">Performance Profiling</a></li><li><a href="../persist/">Object Persistence</a></li><li><a href="../binary/">Binary Data</a></li><li><a href="../db/">A Database</a></li><li><a href="../build/">A Build Manager</a></li><li><a href="../pack/">A Package Manager</a></li><li><a href="../ftp/">Transferring Files</a></li><li><a href="../http/">Serving Web Pages</a></li><li><a href="../viewer/">A File Viewer</a></li><li><a href="../undo/">Undo and Redo</a></li><li><a href="../vm/">A Virtual Machine</a></li><li><a href="../debugger/">A Debugger</a></li><li><a href="../observe/">Observers</a></li><li><a href="../docgen/">Generating Documentation</a></li><li><a href="../search/">Search</a></li><li><a href="../compress/">File Compression</a></li><li><a href="../cache/">A File Cache</a></li><li><a href="../query/">A Query Builder</a></li><li><a href="../concur/">Concurrency</a></li><li><a href="../finale/">Conclusion</a></li></ol>
<ol class="toc-appendices"><li><a href="../bib/">Bibliography</a></li><li><a href="../bonus/">Bonus Material</a></li><li><a href="../syllabus/">Syllabus</a></li><li><a href="../license/">License</a></li><li><a href="../conduct/">Code of Conduct</a></li><li><a href="../contrib/">Contributing</a></li><li><a href="../glossary/">Glossary</a></li><li><a href="../colophon/">Colophon</a></li><li><a href="../contents/">Index</a></li></ol>


<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


<p><a href="https://github.com/gvwilson/sdxpy">GitHub repository</a></p>

      </div>
      <div id="printable" class="contents bordered">
	<main>
	  <div class="row notex">
  <div class="col-12 center">
    
      <h1>A Code Linter</h1>
    
  </div>
</div>

	  
<nav class="row-always notex">
  <div class="col-1 left">
    <a href="../template/" title="previous" class="undecorated">&#8678;</a>
  </div>
  <div class="col-10 center">
    <a href="../" title="home" class="undecorated">&#9737;</a>
  </div>
  <div class="col-1 right">
    <a href="../layout/" title="next" class="undecorated">&#8680;</a>
  </div>
</nav>


	  <ul class="keypoints">
<li>A linter checks that a program conforms to a set of style and usage rules.</li>
<li>Linters typically use the Visitor design pattern to find nodes of interest in an abstract syntax tree.</li>
<li>Programs can modify a program&rsquo;s AST and then unparse it to create modified versions of the original program.</li>
<li>Dynamic code modification is very powerful, but the technique can produce insecure and unmaintainable code.</li>
</ul>
	  <p class="terms">Terms defined: 
<a class="gl-ref" href="../glossary/#false_negative" markdown="1">false negative</a>, <a class="gl-ref" href="../glossary/#linter" markdown="1">linter</a>
</p>
	  <p>This book relies on about 1800 lines of Python to turn Markdown into HTML,
fill in cross-references,
and so on.
To keep that code readable,
we use <a href="https://black.readthedocs.io/"><code>black</code></a>, <a href="https://flake8.pycqa.org/"><code>flake8</code></a>, and <a href="https://pycqa.github.io/isort/"><code>isort</code></a>
to check that lines aren&rsquo;t too long,
that classes and functions have consistent names,
that modules are imported in a consistent order,
and dozens of other things.</p>
<p>Checking tools are often called <a class="gl-ref" href="../glossary/#linter" markdown="1">linters</a>
because an early tool like this that found fluff in C programs was called <code>lint</code>.
Many projects insist that code pass linting checks
before being committed to version control.
To show how linters work,
this chapter builds a trio of tools that
find duplicate keys in dictionaries,
look for unused variables,
and create a table showing which classes in a hierarchy define which methods.</p>
<h2 id="lint-machinery">Machinery</h2>
<p><a href="../check/">Chapter&nbsp;11</a> represented HTML as a <span class="ix-entry" ix-key="DOM tree" markdown="1">DOM tree</span>.
We can also represent the structure of a program
as an <span class="ix-entry" ix-key="abstract syntax tree" markdown="1">abstract syntax tree</span> (AST)
whose nodes represent functions,
statements,
variables,
array indexing operations,
and so on.</p>
<p>Python&rsquo;s <a href="https://docs.python.org/3/library/ast.html"><code>ast</code></a> module will parse Python source code
and produce an AST for us.
For example,
<a class="fig-ref" href="../lint/#lint-ast-simple">Figure&nbsp;13.1</a> shows key parts of the AST
for the short program shown below:</p>
<div class="language-py" title="simple.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">double</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div>
</div>
<figure id="lint-ast-simple">
<img src="./ast_simple.svg" alt="Simple AST"/>
<figcaption>Figure&nbsp;13.1: The abstract syntax tree for a simple Python program.</figcaption>
</figure>

<p>We said &ldquo;key parts of the AST&rdquo; because
the complete structure contains many details that we haven&rsquo;t bothered to draw.
To see them,
let&rsquo;s use <code>ast.parse</code> to turn our example code into an AST
and <code>ast.dump</code> to display it:</p>
<div class="language-py" title="dump_ast.py">
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">ast</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</code></pre></div>
</div>
<div class="language-sh" title="dump_ast_simple.sh">
<div class="highlight"><pre><span></span><code>python<span class="w"> </span>dump_ast.py<span class="w"> </span>simple.py
</code></pre></div>
</div>
<div class="language-out" title="dump_ast_simple.out">
<div class="highlight"><pre><span></span><code>Module(
    body=[
        FunctionDef(
            name=&#39;double&#39;,
            args=arguments(
                posonlyargs=[],
                args=[
                    arg(arg=&#39;x&#39;)],
                kwonlyargs=[],
                kw_defaults=[],
                defaults=[]),
            body=[
                Return(
                    value=BinOp(
                        left=Constant(value=2),
                        op=Mult(),
                        right=Name(id=&#39;x&#39;, ctx=Load())))],
            decorator_list=[]),
        Assign(
            targets=[
                Name(id=&#39;result&#39;, ctx=Store())],
            value=Call(
                func=Name(id=&#39;double&#39;, ctx=Load()),
                args=[
                    Constant(value=3)],
                keywords=[])),
        Expr(
            value=Call(
                func=Name(id=&#39;print&#39;, ctx=Load()),
                args=[
                    Name(id=&#39;result&#39;, ctx=Load())],
                keywords=[]))],
    type_ignores=[])
</code></pre></div>
</div>
<p>The node representing the definition of the function <code>double</code>
is a <code>FunctionDef</code> node with a <code>name</code>
and an <code>arguments</code> sub-node that stores information
about the function&rsquo;s <span class="ix-entry" ix-key="argument" markdown="1">arguments</span>;
other nodes that we have left out
represent its return value,
the call to <code>double</code>,
the assignment to <code>result</code>,
and so on.</p>
<p>If we want a list of all the functions defined in this module,
we can walk through this tree to find all the <code>FunctionDef</code> nodes
and record their <code>name</code> properties.
Since each node&rsquo;s structure is a little different,
we would have to write one function for each type of node
that knew which fields of that node were worth exploring.</p>
<p>Luckily for us the <code>ast</code> module has tools to do this for us.
The class <code>ast.NodeVisitor</code> uses
the now-familiar <span class="ix-entry" ix-key="Visitor pattern" markdown="1">Visitor</span> <span class="ix-entry" ix-key="design pattern" markdown="1">design pattern</span>
to recurse through a structure like the one in <a class="fig-ref" href="../lint/#lint-ast-simple">Figure&nbsp;13.1</a>.
Each time the visitor reaches a node of type <code>Thing</code>,
it looks for a <span class="ix-entry" ix-key="method" markdown="1">method</span> called <code>visit_Thing</code>;
for example,
when it reaches a <code>FunctionDef</code> node it looks for <code>visit_FunctionDef</code>.
If that method has been defined,
<code>NodeVisitor</code> calls it with the node as an argument.
The class <code>CollectNames</code> uses this machinery
to create a list of the function and variable names
defined in a program:</p>
<div class="language-py" title="walk_ast.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CollectNames</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_Assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_FunctionDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">col_offset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">({</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="p">},</span> <span class="p">{</span><span class="n">node</span><span class="o">.</span><span class="n">col_offset</span><span class="p">})</span>
</code></pre></div>
</div>
<p class="continue">A few things worth noting about this class are:</p>
<ol>
<li>
<p>The <span class="ix-entry" ix-key="constructor" markdown="1">constructor</span> of <code>CollectNames</code> invokes
    the constructor of <code>NodeVisitor</code>
    using <code>super().__init__()</code>
    before doing anything else.</p>
</li>
<li>
<p>The methods <code>visit_Assign</code> and <code>visit_FunctionDef</code>
    must call <code>self.generic_visit(node)</code> explicitly
    to recurse down through their children.
    By requiring this to be explicit,
    <code>NodeVisitor</code> gives programmers control on
    whether and when <span class="ix-entry" ix-key="recursion" markdown="1">recursion</span> takes place.</p>
</li>
<li>
<p>The method <code>position</code> relies on the fact that
    every node in the AST keeps track of
    where in the source code it came from.</p>
</li>
</ol>
<p>To use this class,
we read the source of the program that we want to analyze,
parse it,
and then call the <code>visit</code> method of our class to trigger recursion:</p>
<div class="language-py" title="walk_ast.py">
<div class="highlight"><pre><span></span><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="n">collector</span> <span class="o">=</span> <span class="n">CollectNames</span><span class="p">()</span>
<span class="n">collector</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">collector</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="language-sh" title="walk_ast.sh">
<div class="highlight"><pre><span></span><code>python<span class="w"> </span>walk_ast.py<span class="w"> </span>simple.py
</code></pre></div>
</div>
<div class="language-out" title="walk_ast.out">
<div class="highlight"><pre><span></span><code>{&#39;double&#39;: {(1, 0)}, &#39;result&#39;: {(4, 0)}}
</code></pre></div>
</div>
<p>With a little more work we could record class names as well,
and then check that (for example)
class names use CamelCase,
while function and variable names use pothole_case.
We&rsquo;ll tackle this in the exercises.</p>
<h2 id="lint-dup">Finding Duplicate Keys</h2>
<p>Many programs store their configuration in dictionaries.
As those dictionaries grow larger,
it&rsquo;s easy for programmers to redefine values by accident.
For example,
the dictionary in this short piece of code has two entries
for the key <code>"third"</code>:</p>
<div class="language-py" title="has_duplicate_keys.py">
<div class="highlight"><pre><span></span><code><span class="n">has_duplicates</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;third&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s2">&quot;fourth&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
    <span class="s2">&quot;fourth&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
    <span class="s2">&quot;third&quot;</span><span class="p">:</span> <span class="mi">6</span>
<span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">has_duplicates</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">Python could treat this as an error,
keep the first entry,
keep the last entry,
or concatenate the entries somehow.
As the output below shows,
it chooses the third option:</p>
<div class="language-out" title="has_duplicate_keys.out">
<div class="highlight"><pre><span></span><code>{&#39;third&#39;: 6, &#39;fourth&#39;: 5}
</code></pre></div>
</div>
<p>We can build a linter that finds dictionaries like <code>has_duplicates</code>
with just a few lines of code
and the <code>Counter</code> class from Python&rsquo;s <a href="https://docs.python.org/3/library/collections.html"><code>collections</code></a> module
(which implements a specialized dictionary that counts
how many times a key has been seen).
We define a <code>visit_Dict</code> method for <code>NodeVisitor</code> 
that adds each constant key to the counter,
then look for keys that have been seen more than once:</p>
<div class="language-py" title="find_duplicate_keys.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">FindDuplicateKeys</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">visit_Dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                <span class="n">seen</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">problems</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">problems</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">problems</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">problems</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">problems</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;duplicate key(s) </span><span class="se">{{</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="se">}}</span><span class="s2"> at </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">When we parse <code>has_duplicate_keys.py</code>
and pass the AST to <code>FindDuplicateKeys</code>,
we get:</p>
<div class="language-out" title="find_duplicate_keys.out">
<div class="highlight"><pre><span></span><code>duplicate key(s) {fourth, third} at 1
</code></pre></div>
</div>
<div class="callout">
<h3>As Far as We Can Go</h3>
<p><code>FindDuplicateKeys</code> only considers constant keys,
which means it won&rsquo;t find duplicate keys that are created on the fly like this:</p>
<div class="language-py" title="function_keys.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">label</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;label&quot;</span>

<span class="n">actually_has_duplicate_keys</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="s2">&quot;la&quot;</span> <span class="o">+</span> <span class="s2">&quot;bel&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">label</span><span class="p">():</span> <span class="mi">3</span><span class="p">,</span>
    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;l&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="s2">&quot;l&quot;</span><span class="p">]):</span> <span class="mi">4</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
</div>
<p class="continue">We could try adding more code to handle this,
but there are so many different ways to generate keys on the fly
that our linter couldn&rsquo;t possibly catch them all.
The possibility of <a class="gl-ref" href="../glossary/#false_negative" markdown="1">false negatives</a> doesn&rsquo;t mean that
linting is useless, though:
every problem that linting catches
gives programmers more time to check for things that linters can&rsquo;t find.</p>
</div>
<h2 id="lint-unused">Finding Unused Variables</h2>
<p>Finding unused variables—ones that are assigned values but never used—is
more challenging than our previous examples.
The problem is <span class="ix-entry" ix-key="scope" markdown="1">scope</span>:
a variable defined in a function or method might have the same name
as one defined elsewhere,
but they are different variables.</p>
<p>Let&rsquo;s start by defining a class
that handles variables in <span class="ix-entry" ix-key="module" markdown="1">modules</span> and functions.
Since functions can be defined inside modules and other functions,
the constructor for our class creates a list that we will use as a stack
to keep track of what scopes we&rsquo;re currently in:</p>
<div class="language-py" title="find_unused_variables.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">FindUnusedVariables</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_Module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_FunctionDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
</code></pre></div>
</div>
<p>We could just use a list of three values to record information for each scope,
but using <code>namedtuple</code> (which also comes from Python&rsquo;s <code>collections</code> module)
tells readers explicitly what each scope consists of:</p>
<div class="language-py" title="find_unused_variables.py">
<div class="highlight"><pre><span></span><code><span class="n">Scope</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Scope&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;load&quot;</span><span class="p">,</span> <span class="s2">&quot;store&quot;</span><span class="p">])</span>
</code></pre></div>
</div>
<p>Each time we encounter a new scope
we push a new <code>Scope</code> triple onto the stack with a name,
a set to hold the variables that are used in the scope,
and another set to hold the variables that are defined in the scope.
We then call <code>NodeVisitor.generic_visitor</code> to trigger recursion,
pop the record we just pushed off the stack,
and report any problems:</p>
<div class="language-py" title="find_unused_variables.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Scope</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">()))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="n">unused</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">store</span> <span class="o">-</span> <span class="n">scope</span><span class="o">.</span><span class="n">load</span>
        <span class="k">if</span> <span class="n">unused</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">unused</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unused in </span><span class="si">{</span><span class="n">scope</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p>The last part of the puzzle is <code>visit_Name</code>.
If the variable&rsquo;s value is being read,
the node will have a property <code>.ctx</code> (short for &ldquo;context&rdquo;) of type <code>ast.Load</code>.
If the variable is being written to,
the node&rsquo;s <code>.ctx</code> property will be an instance of <code>ast.Store</code>.
Checking this property allows us to put the name in the right set
in the scope that&rsquo;s at the top of the stack:</p>
<div class="language-py" title="find_unused_variables.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">visit_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Load</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">load</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Store</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Unknown context&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Once again,
we can run this by reading the source of a program,
converting it to an AST,
constructing an instance of <code>FindUnusedVariables</code>,
and running its <code>visit</code> method:</p>
<div class="language-py" title="find_unused_variables.py">
<div class="highlight"><pre><span></span><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="n">finder</span> <span class="o">=</span> <span class="n">FindUnusedVariables</span><span class="p">()</span>
<span class="n">finder</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</code></pre></div>
</div>
<p>To test our code,
let&rsquo;s create a program that has some unused variables:</p>
<div class="language-py" title="has_unused_variables.py">
<div class="highlight"><pre><span></span><code><span class="n">used</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">distractor</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">not_used</span> <span class="o">=</span> <span class="n">used</span> <span class="o">+</span> <span class="n">distractor</span>


<span class="k">def</span><span class="w"> </span><span class="nf">no_unused</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">param</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span><span class="w"> </span><span class="nf">has_unused</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
    <span class="n">used</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">param</span>
    <span class="n">not_used</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">param</span>
    <span class="n">distractor</span> <span class="o">=</span> <span class="s2">&quot;distraction&quot;</span>
    <span class="k">return</span> <span class="n">used</span>
</code></pre></div>
</div>
<p>When we run our linter we get:</p>
<div class="language-out" title="find_unused_variables.out">
<div class="highlight"><pre><span></span><code>unused in has_unused: distractor, not_used
unused in global: not_used
</code></pre></div>
</div>
<h2 id="lint-summary">Summary</h2>
<p><a class="fig-ref" href="../lint/#lint-concept-map">Figure&nbsp;13.2</a> summarizes the ideas introduced in this chapter;
please see <a href="../bonus/">Appendix&nbsp;B</a> for some more related material.</p>
<figure id="lint-concept-map" class="here">
<img src="./concept_map.svg" alt="Concept map for code manipulation"/>
<figcaption>Figure&nbsp;13.2: Concepts for code manipulation.</figcaption>
</figure>

<h2 id="lint-exercises">Exercises</h2>
<h3 class="exercise">Finding Unused Parameters</h3>
<p>Modify the code that finds unused variables
to report unused function parameters as well.</p>
<h3 class="exercise">Finding Redundant Assignments</h3>
<p>Write a linter that looks for redundant assignments to variables,
i.e.,
assignments that are immediately overwritten:</p>
<div class="language-py" title="ex_redundant.py">
<div class="highlight"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># redundant</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div>
</div>
<p class="continue">(Redundant assignments are a common result of copying and pasting.)</p>
<h3 class="exercise">Checking Names</h3>
<p>Write a linter that checks that
class names are written in CamelCase
but function and variable names are in pothole_case.</p>
<h3 class="exercise">Missing Documentation</h3>
<p>Write a linter that complains about modules, classes, methods, and functions
that don&rsquo;t have docstrings.</p>
<h3 class="exercise">Missing Tests</h3>
<p>Write a linter that takes two files as input:
one that defines one or more functions
and another that defines one or more tests of those functions.
The linter looks through the tests to see what functions are being called,
then reports any functions from the first file that it hasn&rsquo;t seen.</p>
<h3 class="exercise">Chaining Methods</h3>
<ol>
<li>
<p>Modify the code that injects methods into <code>NodeVisitor</code>
    so that any previously injected methods are also called.</p>
</li>
<li>
<p>Modify the methods again so that each one signals
    whether or not it has handled recursion
    (either directly or indirectly).</p>
</li>
</ol>
<h3 class="exercise">Sorting Imports</h3>
<p><a href="https://pycqa.github.io/isort/"><code>isort</code></a> checks that the imports in a file are sorted correctly:
modules from <span class="ix-entry" ix-key="Python standard library" markdown="1">Python&rsquo;s standard library</span>
come first (in alphabetical order),
then installed modules (also in alphabetical order)
and finally local imports (ditto).
Write a linter that reports violations of these rules.
How did you distinguish between the three cases?</p>
	</main>
	<footer>
  © 2025 <a href="https://third-bit.com/">Greg Wilson</a>
  &middot;
  <a href="../">home</a>
  &middot;
  <a href="https://github.com/gvwilson/sdxpy">repository</a>
  &middot;
  <a href="../license/">license</a>
  &middot;
  <a href="mailto:gvwilson@third-bit.com">contact</a>
</footer>

      </div>
    </div>
  </body>
</html>
