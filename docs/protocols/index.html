<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="../logo.svg">
<link rel="stylesheet" href="../tango.css" type="text/css">
<link rel="stylesheet" href="../mccole.css" type="text/css">
<title>Software Design by Example &middot; Protocols</title>
<script>
  MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)']]
    }
  };
</script>
<script
  type="text/javascript"
  id="MathJax-script"
  async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


  </head>
  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <a href="https://www.routledge.com/Software-Design-by-Example-A-Tool-Based-Introduction-with-Python/Wilson/p/book/9781032725215"><img src="../sdxpy-cover.png" alt="Book cover" class="bookcover" /></a>
  
</p>

<div class="screen-reader-only">
  <a href="#printable">Skip to content</a>
</div>

<ol class="toc-chapters"><li><a href="../intro/">Introduction</a></li><li><a href="../oop/">Objects and Classes</a></li><li><a href="../dup/">Finding Duplicate Files</a></li><li><a href="../glob/">Matching Patterns</a></li><li><a href="../parse/">Parsing Text</a></li><li><a href="../test/">Running Tests</a></li><li><a href="../interp/">An Interpreter</a></li><li><a href="../func/">Functions and Closures</a></li><li><a href="../protocols/">Protocols</a></li><li><a href="../archive/">A File Archiver</a></li><li><a href="../check/">An HTML Validator</a></li><li><a href="../template/">A Template Expander</a></li><li><a href="../lint/">A Code Linter</a></li><li><a href="../layout/">Page Layout</a></li><li><a href="../perf/">Performance Profiling</a></li><li><a href="../persist/">Object Persistence</a></li><li><a href="../binary/">Binary Data</a></li><li><a href="../db/">A Database</a></li><li><a href="../build/">A Build Manager</a></li><li><a href="../pack/">A Package Manager</a></li><li><a href="../ftp/">Transferring Files</a></li><li><a href="../http/">Serving Web Pages</a></li><li><a href="../viewer/">A File Viewer</a></li><li><a href="../undo/">Undo and Redo</a></li><li><a href="../vm/">A Virtual Machine</a></li><li><a href="../debugger/">A Debugger</a></li><li><a href="../observe/">Observers</a></li><li><a href="../docgen/">Generating Documentation</a></li><li><a href="../search/">Search</a></li><li><a href="../compress/">File Compression</a></li><li><a href="../cache/">A File Cache</a></li><li><a href="../query/">A Query Builder</a></li><li><a href="../concur/">Concurrency</a></li><li><a href="../finale/">Conclusion</a></li></ol>
<ol class="toc-appendices"><li><a href="../bib/">Bibliography</a></li><li><a href="../bonus/">Bonus Material</a></li><li><a href="../syllabus/">Syllabus</a></li><li><a href="../license/">License</a></li><li><a href="../conduct/">Code of Conduct</a></li><li><a href="../contrib/">Contributing</a></li><li><a href="../glossary/">Glossary</a></li><li><a href="../colophon/">Colophon</a></li><li><a href="../contents/">Index</a></li></ol>


<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


<p><a href="https://github.com/gvwilson/sdxpy">GitHub repository</a></p>

      </div>
      <div id="printable" class="contents bordered">
	<main>
	  <div class="row notex">
  <div class="col-12 center">
    
      <h1>Protocols</h1>
    
  </div>
</div>

	  
<nav class="row-always notex">
  <div class="col-1 left">
    <a href="../func/" title="previous" class="undecorated">&#8678;</a>
  </div>
  <div class="col-10 center">
    <a href="../" title="home" class="undecorated">&#9737;</a>
  </div>
  <div class="col-1 right">
    <a href="../archive/" title="next" class="undecorated">&#8680;</a>
  </div>
</nav>


	  <ul class="keypoints">
<li>Temporarily replacing functions with mock objects can simplify testing.</li>
<li>Mock objects can record their calls and/or return variable results.</li>
<li>Python defines protocols so that code can be triggered by keywords in the language.</li>
<li>Use the context manager protocol to ensure cleanup operations always execute.</li>
<li>Use decorators to wrap functions after defining them.</li>
<li>Use closures to create decorators that take extra parameters.</li>
<li>Use the iterator protocol to make objects work with for loops.</li>
</ul>
	  <p class="terms">Terms defined: 
<a class="gl-ref" href="../glossary/#append_mode" markdown="1">append mode</a>, <a class="gl-ref" href="../glossary/#context_manager" markdown="1">context manager</a>, <a class="gl-ref" href="../glossary/#decorator" markdown="1">decorator</a>, <a class="gl-ref" href="../glossary/#infinite_recursion" markdown="1">infinite recursion</a>, <a class="gl-ref" href="../glossary/#iterator" markdown="1">iterator</a>, <a class="gl-ref" href="../glossary/#iterator_pattern" markdown="1">Iterator pattern</a>, <a class="gl-ref" href="../glossary/#mock_object" markdown="1">mock object</a>, <a class="gl-ref" href="../glossary/#protocol" markdown="1">protocol</a>
</p>
	  <p>This book is supposed to teach software design
by implementing small versions of real-world tools,
but we have reached a point where we need to learn a little more about Python itself
in order to proceed.
Our discussion of closures in <a href="../func/">Chapter&nbsp;8</a> was the first step;
in this chapter,
we will look at how Python allows users to tell it to do things at specific moments.</p>
<h2 id="protocols-mock">Mock Objects</h2>
<p>We have already seen that functions are objects referred to by variable names
just like other values.
We can use this fact to change functions at runtime to make testing easier.
For example,
if the function we want to test uses the time of day,
we can temporarily replace the real <code>time.time</code> function
with one that returns a specific value
so we know what result to expect in our test:</p>
<div class="language-py" title="mock_time.py">
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">time</span>

<span class="k">def</span><span class="w"> </span><span class="nf">elapsed</span><span class="p">(</span><span class="n">since</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">since</span>

<span class="k">def</span><span class="w"> </span><span class="nf">mock_time</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">200</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_elapsed</span><span class="p">():</span>
    <span class="n">time</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">mock_time</span>
    <span class="k">assert</span> <span class="n">elapsed</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="o">==</span> <span class="mi">150</span>
</code></pre></div>
</div>
<p>Temporary replacements like this are called <a class="gl-ref" href="../glossary/#mock_object" markdown="1">mock objects</a>
because we usually use objects even if the thing we&rsquo;re replacing is a function.
We can do this because Python lets us create objects
that can be &ldquo;called&rdquo; just like functions.
If an object <code>obj</code> has a <code>__call__</code> method,
then <code>obj(…)</code> is automatically turned into <code>obj.__call__(…)</code>
just as <code>a == b</code> is automatically turned into <code>a.__eq__(b)</code> (<a href="../parse/">Chapter&nbsp;5</a>).
For example,
the code below defines a class <code>Adder</code>
whose instances add a constant to their input:</p>
<div class="language-py" title="callable.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Adder</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

<span class="n">add_3</span> <span class="o">=</span> <span class="n">Adder</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">add_3</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;add_3(8): </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="language-out" title="callable.out">
<div class="highlight"><pre><span></span><code>add_3(8): 11
</code></pre></div>
</div>
<p>Let&rsquo;s create a reusable mock object class that:</p>
<ol>
<li>
<p>defines a <code>__call__</code> method so that instances can be called like functions;</p>
</li>
<li>
<p>declares the parameters of that method to be <code>*args</code> and <code>**kwargs</code>
    so that it can be called with any number of regular or keyword arguments;</p>
</li>
<li>
<p>stores those <span class="ix-entry" ix-key="argument" markdown="1">arguments</span>
    so we can see how the replaced function was called;
    and</p>
</li>
<li>
<p>returns either a fixed value or a value produced by a user-defined function.</p>
</li>
</ol>
<p>The class itself is only 11 lines long:</p>
<div class="language-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Fake</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calls</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
</code></pre></div>
</div>
<p>For convenience,
let&rsquo;s also define a function that replaces some function we&rsquo;ve already defined
with an instance of our <code>Fake</code> class:</p>
<div class="language-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fakeit</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span>
    <span class="n">fake</span> <span class="o">=</span> <span class="n">Fake</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="nb">globals</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">fake</span>
    <span class="k">return</span> <span class="n">fake</span>
</code></pre></div>
</div>
<p>To show how this works,
we define a function that adds two numbers
and write a test for it:</p>
<div class="language-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">adder</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="k">def</span><span class="w"> </span><span class="nf">test_with_real_function</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
</code></pre></div>
</div>
<div class="pagebreak"></div>

<p>We then use <code>fakeit</code> to replace the real <code>adder</code> function
with a mock object that always returns 99
(<a class="fig-ref" href="../protocols/#protocols-timeline">Figure&nbsp;9.1</a>):</p>
<div class="language-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">test_with_fixed_return_value</span><span class="p">():</span>
    <span class="n">fakeit</span><span class="p">(</span><span class="s2">&quot;adder&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">99</span>
</code></pre></div>
</div>
<figure id="protocols-timeline">
<img src="./timeline.svg" alt="Timeline of mock operation"/>
<figcaption>Figure&nbsp;9.1: Timeline of mock operation.</figcaption>
</figure>

<p>Another test proves that our <code>Fake</code> class records
all of the calls:</p>
<div class="language-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">test_fake_records_calls</span><span class="p">():</span>
    <span class="n">fake</span> <span class="o">=</span> <span class="n">fakeit</span><span class="p">(</span><span class="s2">&quot;adder&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">99</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">99</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="o">.</span><span class="n">calls</span> <span class="o">==</span> <span class="p">[[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">{}],</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">{}]]</span>
</code></pre></div>
</div>
<p>And finally,
the user can provide a function to calculate a return value:</p>
<div class="language-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">test_fake_calculates_result</span><span class="p">():</span>
    <span class="n">fakeit</span><span class="p">(</span><span class="s2">&quot;adder&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">23</span>
</code></pre></div>
</div>
<h2 id="protocols-protocols">Protocols</h2>
<p>Mock objects are very useful,
but the way we&rsquo;re using them is going to cause strange errors.
The problem is that
each test replaces <code>adder</code> with a mock object that does something different.
As a result,
any test that <em>doesn&rsquo;t</em> replace <code>adder</code> will use
whatever mock object was last put in place
rather than the original <code>adder</code> function.</p>
<p>We could tell users it&rsquo;s their job to put everything back after each test,
but people are forgetful.
It would be better if Python did this automatically;
luckily for us,
it provides a <a class="gl-ref" href="../glossary/#protocol" markdown="1">protocol</a> for exactly this purpose.
A protocol is a rule that specifies how programs can tell Python
to do specific things at specific moments.
Giving a class a <code>__call__</code> method is an example of this:
when Python sees <code>thing(…)</code>,
it automatically checks if <code>thing</code> has that method.
Defining an <code>__init__</code> method for a class is another example:
if a class has a method with that name,
Python calls it automatically when constructing a new instance of that class.</p>
<p>What we want for managing mock objects is
a <a class="gl-ref" href="../glossary/#context_manager" markdown="1">context manager</a>
that replaces the real function with our mock
at the start of a <span class="ix-entry" ix-key="block" markdown="1">block</span> of code
and then puts the original back at the end.
The protocol for this relies on two methods called <code>__enter__</code> and <code>__exit__</code>.
If the class is called <code>C</code>,
then when Python executes a <code>with</code> block like this:</p>
<div class="language-py" title="ex_with.py">
<div class="highlight"><pre><span></span><code><span class="k">with</span> <span class="n">C</span><span class="p">(</span><span class="err">…</span><span class="n">args</span><span class="err">…</span><span class="p">)</span> <span class="k">as</span> <span class="n">name</span><span class="p">:</span>
    <span class="err">…</span><span class="n">do</span> <span class="n">things</span><span class="err">…</span>
</code></pre></div>
</div>
<p class="continue">it does the following (<a class="fig-ref" href="../protocols/#protocols-context-manager">Figure&nbsp;9.2</a>):</p>
<ol>
<li>Call <code>C</code>&rsquo;s <span class="ix-entry" ix-key="constructor" markdown="1">constructor</span>
    to create an object that it associates with the code block.</li>
<li>Call that object&rsquo;s <code>__enter__</code> method
    and assign the result to the variable <code>name</code>.</li>
<li>Run the code inside the <code>with</code> block.</li>
<li>Call <code>name.__exit__()</code> when the block finishes.</li>
</ol>
<figure id="protocols-context-manager">
<img src="./context_manager.svg" alt="A context manager"/>
<figcaption>Figure&nbsp;9.2: Operations performed by a context manager.</figcaption>
</figure>

<p>Here&rsquo;s a mock object that inherits all the capabilities of <code>Fake</code>
and adds the two methods needed by <code>with</code>:</p>
<div class="language-py" title="mock_context.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ContextFake</span><span class="p">(</span><span class="n">Fake</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="nb">globals</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">exc_traceback</span><span class="p">):</span>
        <span class="nb">globals</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original</span>
</code></pre></div>
</div>
<p>Notice that <code>__enter__</code> doesn&rsquo;t take any extra parameters:
anything it needs must be provided via the object&rsquo;s constructor.
On the other hand,
<code>__exit__</code> will always be called with three values
that tell it whether an <span class="ix-entry" ix-key="exception" markdown="1">exception</span> occurred,
and if so,
what the exception was.
This test shows that our context manager is doing what it&rsquo;s supposed to:</p>
<div class="language-py" title="mock_context.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">subber</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>

<span class="k">def</span><span class="w"> </span><span class="nf">check_no_lasting_effects</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">subber</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">with</span> <span class="n">ContextFake</span><span class="p">(</span><span class="s2">&quot;subber&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span> <span class="k">as</span> <span class="n">fake</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">subber</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1234</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fake</span><span class="o">.</span><span class="n">calls</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">subber</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
</div>
<p>Context managers can&rsquo;t prevent people from making mistakes,
but they make it easier for people to do the right thing.
They are also an example of how programming languages often evolve:
eventually,
if enough people are doing something the same way in enough places,
support for that way of doing things is added to the language.</p>
<h2 id="protocols-decorator">Decorators</h2>
<p>Python programs rely on several other protocols,
each of which gives user-level code a way to interact with
some aspect of the Python <span class="ix-entry" ix-key="interpreter" markdown="1">interpreter</span>.
One of the most widely used is called a <a class="gl-ref" href="../glossary/#decorator" markdown="1">decorator</a>,
which allows us to wrap one function with another.</p>
<p>In order to understand how decorators work,
we must take another look at <span class="ix-entry" ix-key="closure" markdown="1">closures</span> (<a href="../func/">Chapter&nbsp;8</a>).
Suppose we want to create a function called <code>logging</code>
that prints a message before and after
each call to some other arbitrary function.
We could try to do it like this:</p>
<div class="language-py" title="wrap_infinite.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">original</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;original: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">logging</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;before call&quot;</span><span class="p">)</span>
    <span class="n">original</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;after call&quot;</span><span class="p">)</span>

<span class="n">original</span> <span class="o">=</span> <span class="n">logging</span>
<span class="n">original</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">but when we try to call <code>original</code> we wind up in an infinite loop.
The wrapped version of our function refers to <code>original</code>,
but Python looks up the function associated with that name <em>at the time of call</em>,
which means it finds our wrapper function instead of the original function
(<a class="fig-ref" href="../protocols/#protocols-recursion">Figure&nbsp;9.3</a>).
We can prevent this <a class="gl-ref" href="../glossary/#infinite_recursion" markdown="1">infinite recursion</a>
by creating a closure to <span class="ix-entry" ix-key="variable_capture" markdown="1">capture</span>
the original function for later use:</p>
<div class="pagebreak"></div>

<div class="language-py" title="wrap_capture.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">original</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;original: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">logging</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_inner</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;before call&quot;</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;after call&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_inner</span>

<span class="n">original</span> <span class="o">=</span> <span class="n">logging</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>
<span class="n">original</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="language-out" title="wrap_capture.out">
<div class="highlight"><pre><span></span><code>before call
original: example
after call
</code></pre></div>
</div>
<figure id="protocols-recursion">
<img src="./recursion.svg" alt="Infinite recursion with a wrapped function"/>
<figcaption>Figure&nbsp;9.3: Infinite recursion caused by careless use of a wrapped function.</figcaption>
</figure>

<p>Using a closure also gives us a way to pass extra arguments
when we create the wrapped function:</p>
<div class="pagebreak"></div>

<div class="language-py" title="wrap_param.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">original</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;original: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">logging</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_inner</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;++ </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_inner</span>

<span class="n">original</span> <span class="o">=</span> <span class="n">logging</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="s2">&quot;call&quot;</span><span class="p">)</span>
<span class="n">original</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="language-out" title="wrap_param.out">
<div class="highlight"><pre><span></span><code>++ call
original: example
-- call
</code></pre></div>
</div>
<p>Wrapping functions like this is so useful
that Python has built-in support for doing it.
We define the decorator function that does the wrapping as before,
but then use <code>@wrap</code> to apply it
rather than <code>name = wrap(name)</code>:</p>
<div class="language-py" title="decorator_simple.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;before call&quot;</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;after call&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_inner</span>

<span class="nd">@wrap</span>
<span class="k">def</span><span class="w"> </span><span class="nf">original</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;original: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">original</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="language-out" title="decorator_simple.out">
<div class="highlight"><pre><span></span><code>before call
original: example
after call
</code></pre></div>
</div>
<p>If we want to pass arguments at the time we apply the decorator,
though,
it seems like we&rsquo;re stuck:
a Python decorator must take exactly one argument,
which must be the function we want to decorate.
The solution is to define a function inside a function <em>inside yet another function</em>
to create a closure that captures the arguments:</p>
<div class="language-py" title="decorator_param.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">wrap</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>                  <span class="c1"># function returning a decorator</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_decorate</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>          <span class="c1"># the decorator Python will apply</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>        <span class="c1"># the wrapped function</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;++ </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># &#39;label&#39; is visible because</span>
            <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>           <span class="c1"># …it&#39;s captured in the closure</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># …of &#39;_decorate&#39;</span>
        <span class="k">return</span> <span class="n">_inner</span>
    <span class="k">return</span> <span class="n">_decorate</span>

<span class="nd">@wrap</span><span class="p">(</span><span class="s2">&quot;wrapping&quot;</span><span class="p">)</span>                 <span class="c1"># call &#39;wrap&#39; to get a decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">original</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>            <span class="c1"># decorator applied here</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;original: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">original</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="language-out" title="decorator_param.out">
<div class="highlight"><pre><span></span><code>++ wrapping
original: example
-- wrapping
</code></pre></div>
</div>
<p>Decorators didn&rsquo;t need to be this complicated.
In order to define a method that takes \( N \) parameters in Python,
we have to write a function of \( N+1 \) parameters,
the first of which represents the object for which the method is being called.
Python could have done the same thing with decorators,
i.e.,
allowed people to define a function of \( N+1 \) parameters
and have <code>@</code> fill in the first automatically:</p>
<div class="language-py" title="alternative_design.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_inner</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;entering </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_inner</span>

<span class="nd">@decorator</span><span class="p">(</span><span class="s2">&quot;message&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>           <span class="c1"># equivalent to</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>         <span class="c1"># double = decorator(double, &quot;message&quot;)</span>
</code></pre></div>
</div>
<p class="continue">But this isn&rsquo;t the path Python took,
and as a result,
decorators are harder to learn and use than they could have been.</p>
<h2 id="protocols-iterator">Iterators</h2>
<p>As a last example of how protocols work,
consider the <code>for</code> loop.
The statement <code>for thing in collection</code>
assigns items from <code>collection</code> to the variable <code>thing</code> one at a time.
Python implements this using a two-part <a class="gl-ref" href="../glossary/#iterator" markdown="1">iterator</a> protocol,
which is a version of the <a class="gl-ref" href="../glossary/#iterator_pattern" markdown="1">Iterator</a> <span class="ix-entry" ix-key="design pattern" markdown="1">design pattern</span>:</p>
<ol>
<li>
<p>If an object has an <code>__iter__</code> method,
    that method is called to create an iterator object.</p>
</li>
<li>
<p>That iterator object must have a <code>__next__</code> method,
    which must return a value each time it is called.
    When there are no more values to return,
    it must <span class="ix-entry" ix-key="raise" markdown="1">raise</span> a <code>StopIteration</code> exception.</p>
</li>
</ol>
<p>For example,
suppose we have a class that stores a list of strings
and we want to return the characters from the strings in order.
(We will use a class like this to store lines of text in <a href="../viewer/">Chapter&nbsp;23</a>.)
In our first attempt,
each object is its own iterator,
i.e.,
each object keeps track of what value to return next when looping:</p>
<div class="language-py" title="naive_iterator.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">NaiveIterator</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_row</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_col</span><span class="p">]</span>
</code></pre></div>
</div>
<p>If we think of the text in terms of rows and columns,
the <code>advance</code> method moves the column marker forward within the current row.
When we reach the end of a row,
we reset the column to 0 and advance the row index by one:</p>
<div class="language-py" title="naive_iterator.py">
<div class="highlight"><pre><span></span><code>    <span class="k">def</span><span class="w"> </span><span class="nf">_advance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_row</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
</div>
<p>Our first test seems to work:</p>
<div class="language-py" title="test_naive_iterator.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gather</span><span class="p">(</span><span class="n">buffer</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">buffer</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">char</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span><span class="w"> </span><span class="nf">test_naive_buffer</span><span class="p">():</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="n">NaiveIterator</span><span class="p">([</span><span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">gather</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;abc&quot;</span>
</code></pre></div>
</div>
<p class="continue">However,
our iterator doesn&rsquo;t work if the buffer contains an empty string:</p>
<div class="language-py" title="test_naive_iterator.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">test_naive_buffer_empty_string</span><span class="p">():</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="n">NaiveIterator</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">])</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">IndexError</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">gather</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span>
</code></pre></div>
</div>
<p class="continue">It also fails when we use a nested loop:</p>
<div class="language-py" title="test_naive_iterator.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">test_naive_buffer_nested_loop</span><span class="p">():</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="n">NaiveIterator</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">outer</span> <span class="ow">in</span> <span class="n">buffer</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">buffer</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">inner</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="s2">&quot;abab&quot;</span>
</code></pre></div>
</div>
<p>We can fix the first problem with more careful bookkeeping—we leave that
as an exercise—but
fixing the second problem requires us to re-think our design.
The problem is that we only have one pair of variables
(the <code>_row</code> and <code>_col</code> attributes of the buffer)
to store the current location,
but two loops trying to use them.
What we need to do instead is
create a separate object for each loop to use:</p>
<div class="language-py" title="better_iterator.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">BetterIterator</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BetterCursor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Each <span class="ix-entry" ix-key="cursor" markdown="1">cursor</span> keeps track of the current location
for a single loop
using code identical to what we&rsquo;ve already seen
(including the same bug with empty strings):</p>
<div class="language-py" title="better_iterator.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">BetterCursor</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text</span> <span class="o">=</span> <span class="n">text</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_row</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_col</span><span class="p">]</span>
</code></pre></div>
</div>
<p class="continue">With this change in place,
our test of nested loops passes.</p>
<h2 id="protocols-summary">Summary</h2>
<p><a class="fig-ref" href="../protocols/#protocols-concept-map">Figure&nbsp;9.4</a> summarizes
the ideas and tools introduced in this chapter.</p>
<figure id="protocols-concept-map" class="here">
<img src="./concept_map.svg" alt="Concept map of mocks, protocols, and iterators"/>
<figcaption>Figure&nbsp;9.4: Concept map.</figcaption>
</figure>

<h2 id="protocols-exercises">Exercises</h2>
<h3 class="exercise">Testing Exceptions</h3>
<p>Create a context manager that works like <code>pytest.raises</code> from the <a href="https://docs.pytest.org/"><code>pytest</code></a> module,
i.e.,
that does nothing if an expected exception is raised within its scope
but fails with an assertion error if that kind of exception is <em>not</em> raised.</p>
<h3 class="exercise">Timing Blocks</h3>
<p>Create a context manager called <code>Timer</code> that reports how long it has been
since a block of code started running:</p>
<div class="language-py" title="ex_timer.py">
<div class="highlight"><pre><span></span><code><span class="c1"># your class goes here</span>

<span class="k">with</span> <span class="n">Timer</span><span class="p">()</span> <span class="k">as</span> <span class="n">start</span><span class="p">:</span>
    <span class="c1"># …do some lengthy operation…</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="n">elapsed</span><span class="p">())</span>  <span class="c1"># time since the start of the block</span>
</code></pre></div>
</div>
<h3 class="exercise">Handling Empty Strings</h3>
<p>Modify the iterator example so that it handles empty strings correctly,
i.e.,
so that iterating over the list <code>["a", ""]</code> produces <code>["a"]</code>.</p>
<h3 class="exercise">An Even Better Cursor</h3>
<p>Rewrite the <code>BetterCursor</code> class
so that it initializes <code>self._row</code> to 0 and <code>self._col</code> to \( -1 \)
and always calls <code>self._advance()</code> as the first action in <code>self.__next__</code>.
(You will need to make a few other changes as well.)
Do you think this implementation is simpler than the one presented in this chapter?</p>
<h3 class="exercise">Logging to a File</h3>
<p>Create a decorator that takes the name of a file as an extra parameter
and appends a log message to that file
each time a function is called.
(Hint: open the file in <a class="gl-ref" href="../glossary/#append_mode" markdown="1">append mode</a>
each time it is needed.)</p>
	</main>
	<footer>
  © 2025 <a href="https://third-bit.com/">Greg Wilson</a>
  &middot;
  <a href="../">home</a>
  &middot;
  <a href="https://github.com/gvwilson/sdxpy">repository</a>
  &middot;
  <a href="../license/">license</a>
  &middot;
  <a href="mailto:gvwilson@third-bit.com">contact</a>
</footer>

      </div>
    </div>
  </body>
</html>
