<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="repo" content="https://github.com/gvwilson/sdxpy">
  <meta name="build_date" content="2024-02-22">
  <meta name="template" content="default">
  <meta name="major" content="protocols">
  <meta name="has_slides" content="true">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design by Example: Protocols</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  
  <img src="../logo.svg" alt="site logo" class="logo" />
  <a href="../">Software Design by Example</a>
  
</p>

<div class="screen-reader-only">
  <a href="#printable">Skip to content</a>
</div>

<ol class="toc-chapter">
  
  <li>
    <a href="../intro/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../oop/">
      Objects and Classes
    </a>
  </li>
  
  <li>
    <a href="../dup/">
      Finding Duplicate Files
    </a>
  </li>
  
  <li>
    <a href="../glob/">
      Matching Patterns
    </a>
  </li>
  
  <li>
    <a href="../parse/">
      Parsing Text
    </a>
  </li>
  
  <li>
    <a href="../test/">
      Running Tests
    </a>
  </li>
  
  <li>
    <a href="../interp/">
      An Interpreter
    </a>
  </li>
  
  <li>
    <a href="../func/">
      Functions and Closures
    </a>
  </li>
  
  <li>
    <a href="../protocols/">
      <strong>Protocols</strong>
    </a>
  </li>
  
  <li>
    <a href="../archive/">
      A File Archiver
    </a>
  </li>
  
  <li>
    <a href="../check/">
      An HTML Validator
    </a>
  </li>
  
  <li>
    <a href="../template/">
      A Template Expander
    </a>
  </li>
  
  <li>
    <a href="../lint/">
      A Code Linter
    </a>
  </li>
  
  <li>
    <a href="../layout/">
      Page Layout
    </a>
  </li>
  
  <li>
    <a href="../perf/">
      Performance Profiling
    </a>
  </li>
  
  <li>
    <a href="../persist/">
      Object Persistence
    </a>
  </li>
  
  <li>
    <a href="../binary/">
      Binary Data
    </a>
  </li>
  
  <li>
    <a href="../db/">
      A Database
    </a>
  </li>
  
  <li>
    <a href="../build/">
      A Build Manager
    </a>
  </li>
  
  <li>
    <a href="../pack/">
      A Package Manager
    </a>
  </li>
  
  <li>
    <a href="../ftp/">
      Transferring Files
    </a>
  </li>
  
  <li>
    <a href="../http/">
      Serving Web Pages
    </a>
  </li>
  
  <li>
    <a href="../viewer/">
      A File Viewer
    </a>
  </li>
  
  <li>
    <a href="../undo/">
      Undo and Redo
    </a>
  </li>
  
  <li>
    <a href="../vm/">
      A Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      A Debugger
    </a>
  </li>
  
  <li>
    <a href="../finale/">
      Conclusion
    </a>
  </li>
  
</ol>

<ol class="toc-appendix">
  
  <li>
    <a href="../bib/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../bonus/">
      Bonus Material
    </a>
  </li>
  
  <li>
    <a href="../syllabus/">
      Syllabus
    </a>
  </li>
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contrib/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>


<p><a href="../sdxpy-examples.zip" type="application/zip">download examples</a></p>


<p><a href="https://github.com/gvwilson/sdxpy">GitHub repository</a></p>

      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 9: Protocols</h1>


          

	  
<div class="chapterinfo">

  

  

  

  

  

  

  

  

  
  <ul class="syllabus">
  
  <li markdown="1">Temporarily replacing functions with mock objects can simplify testing.</li>
  
  <li markdown="1">Mock objects can record their calls and/or return variable results.</li>
  
  <li markdown="1">Python defines protocols so that code can be triggered by keywords in the language.</li>
  
  <li markdown="1">Use the context manager protocol to ensure cleanup operations always execute.</li>
  
  <li markdown="1">Use decorators to wrap functions after defining them.</li>
  
  <li markdown="1">Use closures to create decorators that take extra parameters.</li>
  
  <li markdown="1">Use the iterator protocol to make objects work with for loops.</li>
  
  </ul>
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  



<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#gl:append_mode" markdown="1">append mode</a>, <a class="gl-ref" href="../glossary/#gl:context_manager" markdown="1">context manager</a>, <a class="gl-ref" href="../glossary/#gl:decorator" markdown="1">decorator</a>, <a class="gl-ref" href="../glossary/#gl:infinite_recursion" markdown="1">infinite recursion</a>, <a class="gl-ref" href="../glossary/#gl:iterator" markdown="1">iterator</a>, <a class="gl-ref" href="../glossary/#gl:iterator_pattern" markdown="1">Iterator pattern</a>, <a class="gl-ref" href="../glossary/#gl:mock_object" markdown="1">mock object</a>, <a class="gl-ref" href="../glossary/#gl:protocol" markdown="1">protocol</a>
</p>


</div>


          <div class="page-toc"></div>
          <p>This book is supposed to teach software design
by implementing small versions of real-world tools,
but we have reached a point where we need to learn a little more about Python itself
in order to proceed.
Our discussion of closures in <a class="x-ref" href="../func/">Chapter 8</a> was the first step;
in this chapter,
we will look at how Python allows users to tell it to do things at specific moments.</p>
<h2 id="protocols-mock">Section 9.1: Mock Objects</h2>
<p>We have already seen that functions are objects referred to by variable names
just like other values.
We can use this fact to change functions at runtime to make testing easier.
For example,
if the function we want to test uses the time of day,
we can temporarily replace the real <code>time.time</code> function
with one that returns a specific value
so we know what result to expect in our test:</p>
<div class="code-sample lang-py" title="mock_time.py">
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">elapsed</span><span class="p">(</span><span class="n">since</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">since</span>

<span class="k">def</span> <span class="nf">mock_time</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">200</span>

<span class="k">def</span> <span class="nf">test_elapsed</span><span class="p">():</span>
    <span class="n">time</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">mock_time</span>
    <span class="k">assert</span> <span class="n">elapsed</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="o">==</span> <span class="mi">150</span>
</code></pre></div>
</div>
<p>Temporary replacements like this are called <a class="gl-ref" href="../glossary/#gl:mock_object" title="A simplified replacement for part of a program whose behavior is easy to control and predict. Mock objects are used in unit tests to simulate databases, web services, and other complex systems." markdown="1">mock objects</a>
because we usually use objects even if the thing we&rsquo;re replacing is a function.
We can do this because Python lets us create objects
that can be &ldquo;called&rdquo; just like functions.
If an object <code>obj</code> has a <code>__call__</code> method,
then <code>obj(…)</code> is automatically turned into <code>obj.__call__(…)</code>
just as <code>a == b</code> is automatically turned into <code>a.__eq__(b)</code> (<a class="x-ref" href="../parse/">Chapter 5</a>).
For example,
the code below defines a class <code>Adder</code>
whose instances add a constant to their input:</p>
<div class="code-sample lang-py" title="callable.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Adder</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

<span class="n">add_3</span> <span class="o">=</span> <span class="n">Adder</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">add_3</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;add_3(8): </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="callable.out">
<div class="highlight"><pre><span></span><code>add_3(8): 11
</code></pre></div>
</div>
<p>Let&rsquo;s create a reusable mock object class that:</p>
<ol>
<li>
<p>defines a <code>__call__</code> method so that instances can be called like functions;</p>
</li>
<li>
<p>declares the parameters of that method to be <code>*args</code> and <code>**kwargs</code>
    so that it can be called with any number of regular or keyword arguments;</p>
</li>
<li>
<p>stores those <span class="ix-entry" ix-key="argument" markdown="1">arguments</span>
    so we can see how the replaced function was called;
    and</p>
</li>
<li>
<p>returns either a fixed value or a value produced by a user-defined function.</p>
</li>
</ol>
<p>The class itself is only 11 lines long:</p>
<div class="code-sample lang-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">Fake</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calls</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
</code></pre></div>
</div>
<p>For convenience,
let&rsquo;s also define a function that replaces some function we&rsquo;ve already defined
with an instance of our <code>Fake</code> class:</p>
<div class="code-sample lang-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">fakeit</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span>
    <span class="n">fake</span> <span class="o">=</span> <span class="n">Fake</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="nb">globals</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">fake</span>
    <span class="k">return</span> <span class="n">fake</span>
</code></pre></div>
</div>
<p>To show how this works,
we define a function that adds two numbers
and write a test for it:</p>
<div class="code-sample lang-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">adder</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">test_with_real_function</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
</code></pre></div>
</div>
<div class="pagebreak"></div>

<p>We then use <code>fakeit</code> to replace the real <code>adder</code> function
with a mock object that always returns 99
(<a class="fig-ref" href="../protocols/#protocols-timeline">Figure 9.1</a>):</p>
<div class="code-sample lang-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_with_fixed_return_value</span><span class="p">():</span>
    <span class="n">fakeit</span><span class="p">(</span><span class="s2">&quot;adder&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">99</span>
</code></pre></div>
</div>
<figure id="protocols-timeline">
<img src="./timeline.svg" alt="Timeline of mock operation"/>
<figcaption markdown="1">Figure 9.1: Timeline of mock operation.</figcaption>
</figure>

<p>Another test proves that our <code>Fake</code> class records
all of the calls:</p>
<div class="code-sample lang-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_fake_records_calls</span><span class="p">():</span>
    <span class="n">fake</span> <span class="o">=</span> <span class="n">fakeit</span><span class="p">(</span><span class="s2">&quot;adder&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">99</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">99</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">99</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="o">.</span><span class="n">calls</span> <span class="o">==</span> <span class="p">[[(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">{}],</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">{}]]</span>
</code></pre></div>
</div>
<p>And finally,
the user can provide a function to calculate a return value:</p>
<div class="code-sample lang-py" title="mock_object.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_fake_calculates_result</span><span class="p">():</span>
    <span class="n">fakeit</span><span class="p">(</span><span class="s2">&quot;adder&quot;</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">adder</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">23</span>
</code></pre></div>
</div>
<h2 id="protocols-protocols">Section 9.2: Protocols</h2>
<p>Mock objects are very useful,
but the way we&rsquo;re using them is going to cause strange errors.
The problem is that
each test replaces <code>adder</code> with a mock object that does something different.
As a result,
any test that <em>doesn&rsquo;t</em> replace <code>adder</code> will use
whatever mock object was last put in place
rather than the original <code>adder</code> function.</p>
<p>We could tell users it&rsquo;s their job to put everything back after each test,
but people are forgetful.
It would be better if Python did this automatically;
luckily for us,
it provides a <a class="gl-ref" href="../glossary/#gl:protocol" title="A set of rules that something promises to obey, i.e., the contract between that thing and its users." markdown="1">protocol</a> for exactly this purpose.
A protocol is a rule that specifies how programs can tell Python
to do specific things at specific moments.
Giving a class a <code>__call__</code> method is an example of this:
when Python sees <code>thing(…)</code>,
it automatically checks if <code>thing</code> has that method.
Defining an <code>__init__</code> method for a class is another example:
if a class has a method with that name,
Python calls it automatically when constructing a new instance of that class.</p>
<p>What we want for managing mock objects is
a <a class="gl-ref" href="../glossary/#gl:context_manager" title="An object that automatically executes some operations at the start of a code block and some other operations at the end of the block." markdown="1">context manager</a>
that replaces the real function with our mock
at the start of a <span class="ix-entry" ix-key="block" markdown="1">block</span> of code
and then puts the original back at the end.
The protocol for this relies on two methods called <code>__enter__</code> and <code>__exit__</code>.
If the class is called <code>C</code>,
then when Python executes a <code>with</code> block like this:</p>
<div class="highlight"><pre><span></span><code><span class="k">with</span> <span class="n">C</span><span class="p">(</span><span class="err">…</span><span class="n">args</span><span class="err">…</span><span class="p">)</span> <span class="k">as</span> <span class="n">name</span><span class="p">:</span>
    <span class="err">…</span><span class="n">do</span> <span class="n">things</span><span class="err">…</span>
</code></pre></div>
<p class="continue">it does the following (<a class="fig-ref" href="../protocols/#protocols-context-manager">Figure 9.2</a>):</p>
<ol>
<li>Call <code>C</code>&rsquo;s <span class="ix-entry" ix-key="constructor" markdown="1">constructor</span>
    to create an object that it associates with the code block.</li>
<li>Call that object&rsquo;s <code>__enter__</code> method
    and assign the result to the variable <code>name</code>.</li>
<li>Run the code inside the <code>with</code> block.</li>
<li>Call <code>name.__exit__()</code> when the block finishes.</li>
</ol>
<figure id="protocols-context-manager">
<img src="./context_manager.svg" alt="A context manager"/>
<figcaption markdown="1">Figure 9.2: Operations performed by a context manager.</figcaption>
</figure>

<p>Here&rsquo;s a mock object that inherits all the capabilities of <code>Fake</code>
and adds the two methods needed by <code>with</code>:</p>
<div class="code-sample lang-py" title="mock_context.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">ContextFake</span><span class="p">(</span><span class="n">Fake</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="nb">globals</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">exc_traceback</span><span class="p">):</span>
        <span class="nb">globals</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original</span>
</code></pre></div>
</div>
<p>Notice that <code>__enter__</code> doesn&rsquo;t take any extra parameters:
anything it needs must be provided via the object&rsquo;s constructor.
On the other hand,
<code>__exit__</code> will always be called with three values
that tell it whether an <span class="ix-entry" ix-key="exception" markdown="1">exception</span> occurred,
and if so,
what the exception was.
This test shows that our context manager is doing what it&rsquo;s supposed to:</p>
<div class="code-sample lang-py" title="mock_context.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">subber</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">check_no_lasting_effects</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">subber</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">with</span> <span class="n">ContextFake</span><span class="p">(</span><span class="s2">&quot;subber&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span> <span class="k">as</span> <span class="n">fake</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">subber</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1234</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fake</span><span class="o">.</span><span class="n">calls</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">subber</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>
</div>
<p>Context managers can&rsquo;t prevent people from making mistakes,
but they make it easier for people to do the right thing.
They are also an example of how programming languages often evolve:
eventually,
if enough people are doing something the same way in enough places,
support for that way of doing things is added to the language.</p>
<h2 id="protocols-decorator">Section 9.3: Decorators</h2>
<p>Python programs rely on several other protocols,
each of which gives user-level code a way to interact with
some aspect of the Python <span class="ix-entry" ix-key="interpreter" markdown="1">interpreter</span>.
One of the most widely used is called a <a class="gl-ref" href="../glossary/#gl:decorator" title="A function A that can be applied to another function B when function B is being defined to change its behavior in some way." markdown="1">decorator</a>,
which allows us to wrap one function with another.</p>
<p>In order to understand how decorators work,
we must take another look at <span class="ix-entry" ix-key="closure" markdown="1">closures</span> (<a class="x-ref" href="../func/">Chapter 8</a>).
Suppose we want to create a function called <code>logging</code>
that prints a message before and after
each call to some other arbitrary function.
We could try to do it like this:</p>
<div class="code-sample lang-py" title="wrap_infinite.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">original</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;original: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">logging</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;before call&quot;</span><span class="p">)</span>
    <span class="n">original</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;after call&quot;</span><span class="p">)</span>

<span class="n">original</span> <span class="o">=</span> <span class="n">logging</span>
<span class="n">original</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<p class="continue">but when we try to call <code>original</code> we wind up in an infinite loop.
The wrapped version of our function refers to <code>original</code>,
but Python looks up the function associated with that name <em>at the time of call</em>,
which means it finds our wrapper function instead of the original function
(<a class="fig-ref" href="../protocols/#protocols-recursion">Figure 9.3</a>).
We can prevent this <a class="gl-ref" href="../glossary/#gl:infinite_recursion" title="Recursion that never stops because it never reaches a case that doesn&#x27;t require further evaluation; the recursive equivalent of an infinite loop." markdown="1">infinite recursion</a>
by creating a closure to <span class="ix-entry" ix-key="variable_capture" markdown="1">capture</span>
the original function for later use:</p>
<div class="pagebreak"></div>

<div class="code-sample lang-py" title="wrap_capture.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">original</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;original: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">logging</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_inner</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;before call&quot;</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;after call&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_inner</span>

<span class="n">original</span> <span class="o">=</span> <span class="n">logging</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>
<span class="n">original</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="wrap_capture.out">
<div class="highlight"><pre><span></span><code>before call
original: example
after call
</code></pre></div>
</div>
<figure id="protocols-recursion">
<img src="./recursion.svg" alt="Infinite recursion with a wrapped function"/>
<figcaption markdown="1">Figure 9.3: Infinite recursion caused by careless use of a wrapped function.</figcaption>
</figure>

<p>Using a closure also gives us a way to pass extra arguments
when we create the wrapped function:</p>
<div class="pagebreak"></div>

<div class="code-sample lang-py" title="wrap_param.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">original</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;original: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">logging</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_inner</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;++ </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_inner</span>

<span class="n">original</span> <span class="o">=</span> <span class="n">logging</span><span class="p">(</span><span class="n">original</span><span class="p">,</span> <span class="s2">&quot;call&quot;</span><span class="p">)</span>
<span class="n">original</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="wrap_param.out">
<div class="highlight"><pre><span></span><code>++ call
original: example
-- call
</code></pre></div>
</div>
<p>Wrapping functions like this is so useful
that Python has built-in support for doing it.
We define the decorator function that does the wrapping as before,
but then use <code>@wrap</code> to apply it
rather than <code>name = wrap(name)</code>:</p>
<div class="code-sample lang-py" title="decorator_simple.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;before call&quot;</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;after call&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_inner</span>

<span class="nd">@wrap</span>
<span class="k">def</span> <span class="nf">original</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;original: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">original</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="decorator_simple.out">
<div class="highlight"><pre><span></span><code>before call
original: example
after call
</code></pre></div>
</div>
<p>If we want to pass arguments at the time we apply the decorator,
though,
it seems like we&rsquo;re stuck:
a Python decorator must take exactly one argument,
which must be the function we want to decorate.
The solution is to define a function inside a function <em>inside yet another function</em>
to create a closure that captures the arguments:</p>
<div class="code-sample lang-py" title="decorator_param.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>                  <span class="c1"># function returning a decorator</span>
    <span class="k">def</span> <span class="nf">_decorate</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>          <span class="c1"># the decorator Python will apply</span>
        <span class="k">def</span> <span class="nf">_inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>        <span class="c1"># the wrapped function</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;++ </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># &#39;label&#39; is visible because</span>
            <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>           <span class="c1"># …it&#39;s captured in the closure</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;-- </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># …of &#39;_decorate&#39;</span>
        <span class="k">return</span> <span class="n">_inner</span>
    <span class="k">return</span> <span class="n">_decorate</span>

<span class="nd">@wrap</span><span class="p">(</span><span class="s2">&quot;wrapping&quot;</span><span class="p">)</span>                 <span class="c1"># call &#39;wrap&#39; to get a decorator</span>
<span class="k">def</span> <span class="nf">original</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>            <span class="c1"># decorator applied here</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;original: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">original</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">)</span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="decorator_param.out">
<div class="highlight"><pre><span></span><code>++ wrapping
original: example
-- wrapping
</code></pre></div>
</div>
<p>Decorators didn&rsquo;t need to be this complicated.
In order to define a method that takes \( N \) parameters in Python,
we have to write a function of \( N+1 \) parameters,
the first of which represents the object for which the method is being called.
Python could have done the same thing with decorators,
i.e.,
allowed people to define a function of \( N+1 \) parameters
and have <code>@</code> fill in the first automatically:</p>
<div class="code-sample lang-py" title="alternative_design.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_inner</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;entering </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_inner</span>

<span class="nd">@decorator</span><span class="p">(</span><span class="s2">&quot;message&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>           <span class="c1"># equivalent to</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>         <span class="c1"># double = decorator(double, &quot;message&quot;)</span>
</code></pre></div>
</div>
<p class="continue">But this isn&rsquo;t the path Python took,
and as a result,
decorators are harder to learn and use than they could have been.</p>
<h2 id="protocols-iterator">Section 9.4: Iterators</h2>
<p>As a last example of how protocols work,
consider the <code>for</code> loop.
The statement <code>for thing in collection</code>
assigns items from <code>collection</code> to the variable <code>thing</code> one at a time.
Python implements this using a two-part <a class="gl-ref" href="../glossary/#gl:iterator" title="A function or object that produces each value from a collection in turn for processing." markdown="1">iterator</a> protocol,
which is a version of the <a class="gl-ref" href="../glossary/#gl:iterator_pattern" title="A design pattern that uses iterators to hide the differences between different kinds of data structures so that everything can be processed using loops." markdown="1">Iterator</a> <span class="ix-entry" ix-key="design pattern" markdown="1">design pattern</span>:</p>
<ol>
<li>
<p>If an object has an <code>__iter__</code> method,
    that method is called to create an iterator object.</p>
</li>
<li>
<p>That iterator object must have a <code>__next__</code> method,
    which must return a value each time it is called.
    When there are no more values to return,
    it must <span class="ix-entry" ix-key="raise" markdown="1">raise</span> a <code>StopIteration</code> exception.</p>
</li>
</ol>
<p>For example,
suppose we have a class that stores a list of strings
and we want to return the characters from the strings in order.
(We will use a class like this to store lines of text in <a class="x-ref" href="../viewer/">Chapter 23</a>.)
In our first attempt,
each object is its own iterator,
i.e.,
each object keeps track of what value to return next when looping:</p>
<div class="code-sample lang-py" title="naive_iterator.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">NaiveIterator</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_row</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_col</span><span class="p">]</span>
</code></pre></div>
</div>
<p>If we think of the text in terms of rows and columns,
the <code>advance</code> method moves the column marker forward within the current row.
When we reach the end of a row,
we reset the column to 0 and advance the row index by one:</p>
<div class="code-sample lang-py" title="naive_iterator.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">_advance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_row</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div>
</div>
<p>Our first test seems to work:</p>
<div class="code-sample lang-py" title="test_naive_iterator.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">gather</span><span class="p">(</span><span class="n">buffer</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">buffer</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">char</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">test_naive_buffer</span><span class="p">():</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="n">NaiveIterator</span><span class="p">([</span><span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">gather</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;abc&quot;</span>
</code></pre></div>
</div>
<p class="continue">However,
our iterator doesn&rsquo;t work if the buffer contains an empty string:</p>
<div class="code-sample lang-py" title="test_naive_iterator.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_naive_buffer_empty_string</span><span class="p">():</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="n">NaiveIterator</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">])</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">IndexError</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">gather</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span>
</code></pre></div>
</div>
<p class="continue">It also fails when we use a nested loop:</p>
<div class="code-sample lang-py" title="test_naive_iterator.py">
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_naive_buffer_nested_loop</span><span class="p">():</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="n">NaiveIterator</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">])</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">outer</span> <span class="ow">in</span> <span class="n">buffer</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">buffer</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">inner</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="s2">&quot;abab&quot;</span>
</code></pre></div>
</div>
<p>We can fix the first problem with more careful bookkeeping—we leave that
as an exercise—but
fixing the second problem requires us to re-think our design.
The problem is that we only have one pair of variables
(the <code>_row</code> and <code>_col</code> attributes of the buffer)
to store the current location,
but two loops trying to use them.
What we need to do instead is
create a separate object for each loop to use:</p>
<div class="code-sample lang-py" title="better_iterator.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">BetterIterator</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BetterCursor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">)</span>
</code></pre></div>
</div>
<p>Each <span class="ix-entry" ix-key="cursor" markdown="1">cursor</span> keeps track of the current location
for a single loop
using code identical to what we&rsquo;ve already seen
(including the same bug with empty strings):</p>
<div class="code-sample lang-py" title="better_iterator.py">
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">BetterCursor</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text</span> <span class="o">=</span> <span class="n">text</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_col</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_advance</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_row</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">_col</span><span class="p">]</span>
</code></pre></div>
</div>
<p class="continue">With this change in place,
our test of nested loops passes.</p>
<h2 id="protocols-summary">Section 9.5: Summary</h2>
<p><a class="fig-ref" href="../protocols/#protocols-concept-map">Figure 9.4</a> summarizes
the ideas and tools introduced in this chapter.</p>
<figure id="protocols-concept-map" class="here">
<img src="./concept_map.svg" alt="Concept map of mocks, protocols, and iterators"/>
<figcaption markdown="1">Figure 9.4: Concept map.</figcaption>
</figure>

<h2 id="protocols-exercises">Section 9.6: Exercises</h2>
<h3 class="exercise">Testing Exceptions</h3>
<p>Create a context manager that works like <code>pytest.raises</code> from the <a href="https://docs.pytest.org/"><code>pytest</code></a> module,
i.e.,
that does nothing if an expected exception is raised within its scope
but fails with an assertion error if that kind of exception is <em>not</em> raised.</p>
<h3 class="exercise">Timing Blocks</h3>
<p>Create a context manager called <code>Timer</code> that reports how long it has been
since a block of code started running:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># your class goes here</span>

<span class="k">with</span> <span class="n">Timer</span><span class="p">()</span> <span class="k">as</span> <span class="n">start</span><span class="p">:</span>
    <span class="c1"># …do some lengthy operation…</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">start</span><span class="o">.</span><span class="n">elapsed</span><span class="p">())</span>  <span class="c1"># time since the start of the block</span>
</code></pre></div>
<h3 class="exercise">Handling Empty Strings</h3>
<p>Modify the iterator example so that it handles empty strings correctly,
i.e.,
so that iterating over the list <code>["a", ""]</code> produces <code>["a"]</code>.</p>
<h3 class="exercise">An Even Better Cursor</h3>
<p>Rewrite the <code>BetterCursor</code> class
so that it initializes <code>self._row</code> to 0 and <code>self._col</code> to \( -1 \)
and always calls <code>self._advance()</code> as the first action in <code>self.__next__</code>.
(You will need to make a few other changes as well.)
Do you think this implementation is simpler than the one presented in this chapter?</p>
<h3 class="exercise">Logging to a File</h3>
<p>Create a decorator that takes the name of a file as an extra parameter
and appends a log message to that file
each time a function is called.
(Hint: open the file in <a class="gl-ref" href="../glossary/#gl:append_mode" title="An option for writing to a file in which new data is appended to existing data rather than replacing it." markdown="1">append mode</a>
each time it is needed.)</p>
        </main>
      </div>
    </div>
  </body>
</html>
