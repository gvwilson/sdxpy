---
template: slides
---

## The Problem

-   Not all software needs formal testing
    -   Check one-off data analysis script incrementally
-   But 98% of the code in [SQLite][sqlite] is there to test the other 2%
    -   For which I am grateful
-   Good tools make tests easier to write
    -   So that programmers have fewer excuses not to write them
-   This lesson build a unit testing framework like [pytest][pytest]
    -   Most frameworks in most other languages share its design

---

## Functions in Lists

-   We can put functions in lists

[% inc pat="func_list.*" fill="py out" %]

---

## Signatures

-   We have to know how to call the functions
    -   They must have the same [%g signature "signature" %]

[% inc pat="signature.*" fill="py out" %]

---

class: aside

## Checking

-   Use `type` to see if something is a function

[% inc pat="type_int.*" fill="py out" %]

[% inc pat="type_func.*" fill="py out" %]

---

class: aside

## Checking

-   But built-in functions have a different type

[% inc pat="type_len.*" fill="py out" %]

-   So use `callable` to check if something can be called

[% inc pat="callable.*" fill="py out" %]

---

## Testing Terminology

-   Apply the function we want to test to a [%g fixture "fixture" %]
-   Compare the [%g actual_result "actual result" %]
    to the [%g expected_result "expected result" %]
-   Possible outcomes are:
    -   [%g pass_test "pass" %]: the target function worked
    -   [%g fail_test "fail" %]: the target function didn't do what we expected
    -   [%g error_test "error" %]: something went wrong with the test itself
-   Typically use `assert` to check results
    -   If condition is `True`, does nothing
    -   Otherwise, raises an `AssertionError`
-   Failed assertions usually cause the program to halt
    -   But we can catch the exception ourselves if we want

---

## A Function and Some Tests

[% inc file="manual.py" keep="sign" %]
[% inc file="manual.py" keep="tests" %]

---

## What We Want

[% inc file="manual.py" keep="save" %]
[% inc file="manual.out" %]

---

## How We Do It

[% inc file="manual.py" keep="run" %]

-   Easy to create new tests
-   But we have to remember to add each one to `TESTS`

---

## How Python Stores Variables

-   Python stores variables in (something very much like) a dictionary

[% inc pat="globals.*" fill="py out" %]

---

## Further Proof

[% inc pat="globals_plus.*" fill="py out" %]

--

-   The function `locals` gives local variables

---

## Introspection

-   We know how to loop over a dictionary's keys

[% inc file="find_test_funcs.py" keep="main" %]
[% inc file="find_test_funcs.out" %]

--

-   When we print a function, Python shows its name and address

---

## A Better Test Runner

[% inc file="runner.py" keep="run" %]

--

-   Really should check that tests are callable

---

class: summary

## Summary	       

[% figure
   slug="test-concept-map"
   img="concept_map.svg"
   alt="Concept map of unit testing framework"
   caption="Concept map"
%]
