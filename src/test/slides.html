---
template: slides
---

## Background

-   Not all software needs formal testing
    -   Check one-off data analysis script incrementally
-   But 98% of the code in [SQLite][sqlite] is there to test the other 2%
    -   For which I am grateful
-   Good tools make tests easier to write
    -   So that programmers have fewer excuses not to write them
-   This lesson build a unit testing framework like [pytest][pytest]
    -   Most frameworks in most other languages share its design

---

## The Big Idea

<p class="shout">A program is just another data structure.</p>

[% figure
   slug="test-func-obj"
   img="func_obj.svg"
   alt="Bytes as characters, pixels, or instructions"
   caption="Bytes can be interpreted as characters, pixels, or instructions."
%]

---

## Functions are Objects

-   `def` defines a variable whose value is the function's instructions

[% inc file="func_obj.py" keep="def" %]

-   We can assign that value to another variable

[% inc file="func_obj.py" keep="alias" %]
[% inc file="func_obj.out" %]

-   `(…)` means "run the instructions this variable refers to"

---

class: aside

## Checking

-   Use `type` to see if something is a function

[% inc pat="type_int.*" fill="py out" %]

[% inc pat="type_func.*" fill="py out" %]

---

class: aside

## Checking

-   But built-in functions have a different type

[% inc pat="type_len.*" fill="py out" %]

-   So use `callable` to check if something can be called

[% inc pat="callable.*" fill="py out" %]

---

## Functions in Lists

-   We can put functions in lists

[% inc pat="func_list.*" fill="py out" %]

---

## Signatures

-   We have to know how to call the functions
    -   They must have the same [%g signature "signature" %]

[% inc pat="signature.*" fill="py out" %]

---

## Testing Terminology

-   Apply the function we want to test to a [%g fixture "fixture" %]
-   Compare the [%g actual_result "actual result" %] to the [%g expected_result "expected result" %]
-   Possible outcomes are:
    -   [%g pass_test "pass" %]: the target function worked
    -   [%g fail_test "fail" %]: the target function didn't do what we expected
    -   [%g error_test "error" %]: something went wrong with the test itself
-   Typically use `assert` to check results
    -   If condition is `True`, does nothing
    -   Otherwise, raises an `AssertionError`
-   Failed assertions usually cause the program to halt
    -   But we can catch the exception ourselves if we want

---

## A Function and Some Tests

[% inc file="manual.py" keep="sign" %]
[% inc file="manual.py" keep="tests" %]

---

## What We Want

[% inc file="manual.py" keep="save" %]
[% inc file="manual.out" %]

---

## How We Do It

[% inc file="manual.py" keep="run" %]

-   Easy to create new tests

-   But we have to remember to add each function to `TESTS`

---

## How Python Stores Variables

-   Python stores variables in (something very much like) a dictionary

[% inc pat="globals.*" fill="py out" %]

---

## Further Proof

[% inc pat="globals_plus.*" fill="py out" %]

--

-   The function `locals` gives local variables

---

## Introspection

-   We know how to loop over a dictionary's keys

[% inc file="find_test_funcs.py" keep="main" %]
[% inc file="find_test_funcs.out" %]

--

-   When we print a function, Python shows its name and address

---

## A Better Test Runner

[% inc file="runner.py" keep="run" %]

--

-   Really should check that tests are callable

---

## Who's Your Audience?

[% figure
   slug="test-comprehension"
   img="comprehension.svg"
   alt="Abstract vs. comprehension"
   caption="Abstraction vs. comprehension for novices and experts."
%]

-   Experts understand lower and higher abstraction levels than novices

-   Preferred level shifts with experience

-   Code that is optimal for one reader may not be optimal for another

---

class: summary

## Summary	       

[% figure
   slug="test-concept-map"
   img="concept_map.svg"
   alt="Concept map of unit testing framework"
   caption="Concept map"
%]

---

class: exercise

## Looping Over `globals`

What happens if you run:

```python
for name in globals():
    print(name)
```

What happens if you run:

```python
name = None
for name in globals():
    print(name)
```

Why?

---

class: exercise

## Counting Results

1.  Modify the test framework so that it reports which tests passed, failed, or had errors
    and also reports a summary of how many tests produced each result.

2.  Write unit tests to check that your answer to part 1 works correctly.

---

class: exercise

## Setup and Teardown

Testing frameworks often allow programmers to specify a `setup` function
that is to be run before each test
and a corresponding `teardown` function
that is to be run after each test.
(`setup` usually re-creates complicated test fixtures,
while `teardown` functions are sometimes needed to clean up after tests,
e.g., to close database connections or delete temporary files.)

Modify the testing tool in this chapter so that
if a file of tests contains a function called `setup`
then the tool calls it exactly once before running each test in the file.
Add a similar way to register a `teardown` function.

---

class: exercise

## Module Names

Our last test runner generated names `m0`, `m1`, and so on
so that each module would have a unique name.
What happens if we don't do this?
I.e.,
what happens if we use the same constant string for all modules that we load?
