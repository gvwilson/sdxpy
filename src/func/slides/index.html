---
title: "Functions and Closures"
template: slides
---

## Background

-   The little programming language of [%x interp %] isn't extensible

-   So add a way to define and call functions

-   And then look at design tactics this opens up

---

## Definition and Call

[% inc file="../example_def.py" keep="def" %]

-   Name

-   (Possibly empty) list of parameter names

-   Body (usually a `seq`)

--

[% inc file="../example_def.py" keep="call" %]

-   Values can be expressions (not in a sub-list)

---

class: aside

## Eager and Lazy

-   [%g eager_evaluation "Eager evaluation" %]:
    arguments are evaluated *before* call

-   [%g lazy_evaluation "Lazy evaluation" %]:
    pass expression sub-lists into the function to be evaluated on demand

    -   Gives the called function a chance to inspect or modify expressions
        before using them

-   Python and most other languages (including ours) are eager

-   R is lazy

-   A design choice

---

## Storing a Function

-   Like any other value

[% inc file="../example_def.py" keep="store" %]

--

-   We could define functions like this

[% inc file="../example_def.py" keep="alt" %]

--

-   JavaScript makes heavy use of
    [%g anonymous_function "anonymous functions" %]

-   Python supports limited [%g lambda_expression "lambda expressions" %]

[% inc file="../example_def.py" keep="lambda" %]

---

## Implementing Call

1.  Evaluate all of these expressions.

2.  Look up the function.

3.  Create a new environment whose keys are the parameters' names
    and whose values are the expressions' values.

4.  Call `do` to run the function's action and captures the result.

5.  Discard environment created in step 3.

6.  Return the function's result.

---

## The Environment

-   A variable `x` in a function shouldn't clobber
    a variable with the same name in its caller

-   Use a list of dictionaries to implement a
    [%g call_stack "call stack" %]

-   Each dictionary called a [%g stack_frame "stack frame" %]

-   Look down the stack to find the name

-   If not found, add to the current (top-most) frame

---

## Implementing Definition

[% inc file="../func.py" keep="def" %]

---

## Implementing Call

[% inc file="../func.py" keep="call" %]

---

## A Test

[% inc pat="../func.*" fill="tll out" %]

---

## Dynamic Scoping

-   Searching active stack for a variable is called [%g dynamic_scoping "dynamic scoping" %]

-   Have to trace execution to figure out what a variable might refer to

[% inc pat="../dynamic.*" fill="tll out" %]

---

## Lexical Scoping

-   Almost all languages used [%g lexical_scoping "lexical scoping" %]

-   Decide what a name refers to based on the structure of the program

-   More efficient for the computer: doesn't have to search each time

-   More efficient for the person: limits scope of reasoning

-   And enables a very powerful programming technique

---

## Closures

-   Define a function inside a function and return the inner function

[% inc pat="../closure.*" fill="py out" %]

-   The inner function [%g variable_capture "captures" %] the variables in the enclosing function

-   A way to make data private

---

## A More Useful Example

[% inc pat="../adder.*" fill="py out" %]

--

[% figure
   slide=True
   slug="func-closure"
   img="../closure.svg"
   alt="Closures"
   caption="Closures"
%]

---

## Objects

[% inc pat="../oop.*" fill="py out" %]

---

## Objects

[% figure
   slide=True
   slug="func-objects"
   img="../objects.svg"
   alt="Objects as closures"
   caption="Implementing objects using closures"
%]

---

## Wrapping Functions

[% inc pat="../wrap_infinite.*" fill="py out" %]

-   Well, that didn't work

---

## Capture the Original

[% inc pat="../wrap_capture.*" fill="py out" %]

---

## Parameters

[% inc pat="../wrap_param.*" fill="py out" %]

---

## Decorators

[% inc pat="../decorator_simple.*" fill="py out" %]

---

## Design Flaw

-   A decorator must take exactly one argument,
    so how do we pass other parameters to the decorator itself?

-   Simple-to-learn answer would have been to treat function being decorated
    like `self` in method definition and call

[% inc file="../decorators_simple.py" %]

-   Instead, we have to create a closure

---

## Decorator Parameters

[% inc pat="../decorator_param.*" fill="py out" %]

---

class: summary

## Summary	       

[% figure
   slide=True
   slug="func-concept-map"
   img="../concept_map.svg"
   alt="Concept map of functions and closures"
   caption="Concept map"
%]
